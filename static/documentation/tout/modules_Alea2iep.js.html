<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>modules/Alea2iep.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Arete3d.html">Arete3d</a></li><li><a href="Cube.html">Cube</a></li><li><a href="Cube3d.html">Cube3d</a></li><li><a href="Droite3d.html">Droite3d</a></li><li><a href="Fraction.html">Fraction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Fraction.html#ajouteEntier">ajouteEntier</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#differenceFraction">differenceFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#diviseEntier">diviseEntier</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#diviseEntierIrred">diviseEntierIrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#diviseFraction">diviseFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#egal">egal</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#entierDivise">entierDivise</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#entierDiviseIrred">entierDiviseIrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#entierMoinsFraction">entierMoinsFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#estUneSimplification">estUneSimplification</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#fractionDecimale">fractionDecimale</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#fractionEgale">fractionEgale</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#inferieurlarge">inferieurlarge</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#inferieurstrict">inferieurstrict</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#inverse">inverse</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#inverseIrrred">inverseIrrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#multiplieEntier">multiplieEntier</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#multiplieEntierIrred">multiplieEntierIrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#oppose">oppose</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#opposeIrred">opposeIrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#produitFraction">produitFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#produitFractions">produitFractions</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#puissanceFraction">puissanceFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#representation">representation</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#representationIrred">representationIrred</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#simplifie">simplifie</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#sommeFraction">sommeFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#sommeFractions">sommeFractions</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#superieurlarge">superieurlarge</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#superieurstrict">superieurstrict</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#texProduitFraction">texProduitFraction</a></li><li data-type='method' style='display: none;'><a href="Fraction.html#texQuotientFraction">texQuotientFraction</a></li></ul></li><li><a href="Grandeur.html">Grandeur</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Grandeur.html#convertirEn">convertirEn</a></li></ul></li><li><a href="ListeFraction.html">ListeFraction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ListeFraction.html#completeListe">completeListe</a></li></ul></li><li><a href="module-modules_outils.Relatif.html">Relatif</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~getCardNegatifs">getCardNegatifs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~getSigneNumber">getSigneNumber</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~getSigneProduitNumber">getSigneProduitNumber</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~getSigneProduitString">getSigneProduitString</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~getSigneString">getSigneString</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~orthographeFacteursNegatifs">orthographeFacteursNegatifs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~setRegleSigneProduit">setRegleSigneProduit</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Relatif.html#~setRegleSigneQuotient">setRegleSigneQuotient</a></li></ul></li><li><a href="module-modules_outils.Triangles.html">Triangles</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getAngles">getAngles</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getAnglesValeurs">getAnglesValeurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getCotes">getCotes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getLongueurs">getLongueurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getLongueursValeurs">getLongueursValeurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getNom">getNom</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getPerimetre">getPerimetre</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~getSommets">getSommets</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~isPlatTriangleAngles">isPlatTriangleAngles</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~isPlatTriangleLongueurs">isPlatTriangleLongueurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~isTrueTriangleAngles">isTrueTriangleAngles</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.Triangles.html#~isTrueTriangleLongueurs">isTrueTriangleLongueurs</a></li></ul></li><li><a href="module-modules_outils-Personne.html">Personne</a></li><li><a href="NoteLaCouleur.html">NoteLaCouleur</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NoteLaCouleur.html#testBoucle">testBoucle</a></li><li data-type='method' style='display: none;'><a href="NoteLaCouleur.html#testInstruction">testInstruction</a></li><li data-type='method' style='display: none;'><a href="NoteLaCouleur.html#testSequence">testSequence</a></li></ul></li><li><a href="Pave3d.html">Pave3d</a></li><li><a href="Point3d.html">Point3d</a></li><li><a href="Polygone3d.html">Polygone3d</a></li><li><a href="Prisme3d.html">Prisme3d</a></li><li><a href="Syracuse.html">Syracuse</a></li><li><a href="Vecteur3d.html">Vecteur3d</a></li></ul><h3>Modules</h3><ul><li><a href="module-modules_dom.html">modules/dom</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.addElement">addElement</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.addText">addText</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.enforceElt">enforceElt</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.get">get</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#.setStyles">setStyles</a></li><li data-type='method' style='display: none;'><a href="module-modules_dom.html#~hasProp">hasProp</a></li></ul></li><li><a href="module-modules_fractions.html">modules/fractions</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_fractions.html#.fraction">fraction</a></li><li data-type='method' style='display: none;'><a href="module-modules_fractions.html#.obtenirListeFractionsIrreductibles">obtenirListeFractionsIrreductibles</a></li><li data-type='method' style='display: none;'><a href="module-modules_fractions.html#.obtenirListeFractionsIrreductiblesFaciles">obtenirListeFractionsIrreductiblesFaciles</a></li></ul></li><li><a href="module-modules_messages.html">modules/messages</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_messages.html#.addFeedback">addFeedback</a></li><li data-type='method' style='display: none;'><a href="module-modules_messages.html#.messageFeedback">messageFeedback</a></li><li data-type='method' style='display: none;'><a href="module-modules_messages.html#.messageUtilisateur">messageUtilisateur</a></li></ul></li><li><a href="module-modules_outils.html">modules/outils</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-modules_outils.html#.ppcm">ppcm</a></li><li data-type='member' style='display: none;'><a href="module-modules_outils.html#~nomsPossibles">nomsPossibles</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.abs">abs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.arrondi">arrondi</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.arrondiVirgule">arrondiVirgule</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.calcul">calcul</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.calculAligne">calculAligne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.carreParfait">carreParfait</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.changementDeBaseOrthoTri">changementDeBaseOrthoTri</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.changementDeBaseTriOrtho">changementDeBaseTriOrtho</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.chercheMinMaxFonction">chercheMinMaxFonction</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.cherchePolynomeDegre3aExtremaFixes">cherchePolynomeDegre3aExtremaFixes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.choice">choice</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.choisitLettresDifferentes">choisitLettresDifferentes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.choisitNombresEntreMetN">choisitNombresEntreMetN</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.combinaisonListes">combinaisonListes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.compareFractions">compareFractions</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.compareNombres">compareNombres</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.compteOccurences">compteOccurences</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.couleurAleatoire">couleurAleatoire</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.creerBoutonMathalea2d">creerBoutonMathalea2d</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.creerCouples">creerCouples</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.creerDocumentAmc">creerDocumentAmc</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.creerModal">creerModal</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.creerNomDePolygone">creerNomDePolygone</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.cribleEratostheneN">cribleEratostheneN</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.criblePolynomeEntier">criblePolynomeEntier</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.decompositionFacteursPremiers">decompositionFacteursPremiers</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.decompositionFacteursPremiersArray">decompositionFacteursPremiersArray</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.detectSafariChromeBrowser">detectSafariChromeBrowser</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.deuxColonnes">deuxColonnes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.eclatePuissance">eclatePuissance</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureAlgebrique">ecritureAlgebrique</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureAlgebriquec">ecritureAlgebriquec</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureAlgebriqueSauf1">ecritureAlgebriqueSauf1</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureNombreRelatif">ecritureNombreRelatif</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureNombreRelatifc">ecritureNombreRelatifc</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureParentheseSiMoins">ecritureParentheseSiMoins</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ecritureParentheseSiNegatif">ecritureParentheseSiNegatif</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.egal">egal</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enleveElement">enleveElement</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enleveElementBis">enleveElementBis</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enleveElementNo">enleveElementNo</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enleveElementNoBis">enleveElementNoBis</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enumerate">enumerate</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.enumerateSansPuceSansNumero">enumerateSansPuceSansNumero</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.estentier">estentier</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.exportQcmAmc">exportQcmAmc</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.exposant">exposant</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.extraireRacineCarree">extraireRacineCarree</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.factorisation">factorisation</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.filtreDictionnaire">filtreDictionnaire</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.filtreDictionnaireValeurCle">filtreDictionnaireValeurCle</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.filtreDictionnaireValeurTableauCle">filtreDictionnaireValeurTableauCle</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.fractionSimplifiee">fractionSimplifiee</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.href">href</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.htmlConsigne">htmlConsigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.htmlEnumerate">htmlEnumerate</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.htmlLigne">htmlLigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.htmlParagraphe">htmlParagraphe</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.imagePointParTransformation">imagePointParTransformation</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.inferieur">inferieur</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.inferieurouegal">inferieurouegal</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.infoMessage">infoMessage</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.introLatex">introLatex</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.introLatexCoop">introLatexCoop</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.itemize">itemize</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.jour">jour</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.joursParMois">joursParMois</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.katexPopup">katexPopup</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.katexPopup2">katexPopup2</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.lampeMessage">lampeMessage</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.lettreDepuisChiffre">lettreDepuisChiffre</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.lettreMinusculeDepuisChiffre">lettreMinusculeDepuisChiffre</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeDeChosesAImprimer">listeDeChosesAImprimer</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeDeNotes">listeDeNotes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeDesDiviseurs">listeDesDiviseurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeDiviseurs">listeDiviseurs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeNombresPremiersStrictJusqua">listeNombresPremiersStrictJusqua</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeQuestionsToContenu">listeQuestionsToContenu</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeQuestionsToContenuSansNumero">listeQuestionsToContenuSansNumero</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.listeQuestionsToContenuSansNumeroEtSansConsigne">listeQuestionsToContenuSansNumeroEtSansConsigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.machineMathsVideo">machineMathsVideo</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.MatriceCarree">MatriceCarree</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.matriceCarree">matriceCarree</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.minToHoraire">minToHoraire</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.minToHour">minToHour</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.miseEnEvidence">miseEnEvidence</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalImage">modalImage</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalPdf">modalPdf</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalTexteCourt">modalTexteCourt</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalTexteLong">modalTexteLong</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalUrl">modalUrl</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalVideo">modalVideo</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.modalYoutube">modalYoutube</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.nombreAvecEspace">nombreAvecEspace</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.nombreDeChiffresDansLaPartieDecimale">nombreDeChiffresDansLaPartieDecimale</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.nombreDecimal">nombreDecimal</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.nomDuJour">nomDuJour</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.nomDuMois">nomDuMois</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.numAlpha">numAlpha</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.numTrie">numTrie</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.objet">objet</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.objetF">objetF</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.objetM">objetM</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.obtenirListeFacteursPremiers">obtenirListeFacteursPremiers</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.obtenirListeFractionsIrreductibles">obtenirListeFractionsIrreductibles</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.obtenirListeFractionsIrreductiblesFaciles">obtenirListeFractionsIrreductiblesFaciles</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.obtenirListeNombresPremiers">obtenirListeNombresPremiers</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.ordreDeGrandeur">ordreDeGrandeur</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.partieEntiereEnLettres">partieEntiereEnLettres</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.personne">personne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.personnes">personnes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.pgcd">pgcd</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.possedeUnCaractereInterdit">possedeUnCaractereInterdit</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.premiereLettreEnMajuscule">premiereLettreEnMajuscule</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.premierMultipleSuperieur">premierMultipleSuperieur</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.premiersEntreBornes">premiersEntreBornes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.prenom">prenom</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.prenomF">prenomF</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.prenomM">prenomM</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.prenomPronom">prenomPronom</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.printlatex">printlatex</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.produitDeDeuxFractions">produitDeDeuxFractions</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.produitMatriceMatrice3x3">produitMatriceMatrice3x3</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.produitMatriceVecteur3x3">produitMatriceVecteur3x3</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.produitsEnCroix">produitsEnCroix</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.puissance">puissance</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.puissanceEnProduit">puissanceEnProduit</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.quatriemeProportionnelle">quatriemeProportionnelle</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.quotientier">quotientier</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.randint">randint</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.range">range</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.range1">range1</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.rangeMinMax">rangeMinMax</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.reduireAxPlusB">reduireAxPlusB</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.reduirePolynomeDegre3">reduirePolynomeDegre3</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.reorganiseProduitPuissance">reorganiseProduitPuissance</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.resolutionSystemeLineaire2x2">resolutionSystemeLineaire2x2</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.resolutionSystemeLineaire3x3">resolutionSystemeLineaire3x3</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.rienSi1">rienSi1</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.scratchTraductionFr">scratchTraductionFr</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.shuffle">shuffle</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.shuffle2tableaux">shuffle2tableaux</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.shuffleLettres">shuffleLettres</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.signe">signe</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.simpExp">simpExp</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.simplificationDeFractionAvecEtapes">simplificationDeFractionAvecEtapes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.simpNotPuissance">simpNotPuissance</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.sommeDesChiffres">sommeDesChiffres</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.sommeDesTermesParSigne">sommeDesTermesParSigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.sp">sp</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.stringNombre">stringNombre</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.strRandom">strRandom</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.superieur">superieur</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.superieurouegal">superieurouegal</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.tableauColonneLigne">tableauColonneLigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texCadreParOrange">texCadreParOrange</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texConsigne">texConsigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texEnumerate">texEnumerate</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texEnumerateSansNumero">texEnumerateSansNumero</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texFraction">texFraction</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texFractionParentheses">texFractionParentheses</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texFractionReduite">texFractionReduite</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texFractionSigne">texFractionSigne</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texGraphique">texGraphique</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texIntroduction">texIntroduction</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texMasse">texMasse</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texMulticols">texMulticols</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texNombre">texNombre</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texNombre2">texNombre2</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texNombrec">texNombrec</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texNombreCoul">texNombreCoul</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texParagraphe">texParagraphe</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texPrix">texPrix</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texRacineCarree">texRacineCarree</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texSymbole">texSymbole</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texteEnCouleur">texteEnCouleur</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texteEnCouleurEtGras">texteEnCouleurEtGras</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texteGras">texteGras</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texteOuPas">texteOuPas</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.texTexte">texTexte</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.tikzMachineDiag">tikzMachineDiag</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.tikzMachineMaths">tikzMachineMaths</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.tirerLesDes">tirerLesDes</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.tridictionnaire">tridictionnaire</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.triePositifsNegatifs">triePositifsNegatifs</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.troncature">troncature</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.TrouverSolutionMathador">TrouverSolutionMathador</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.unMoisDeTemperature">unMoisDeTemperature</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.unSiPositifMoinsUnSinon">unSiPositifMoinsUnSinon</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.valeurBase">valeurBase</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.warnMessage">warnMessage</a></li><li data-type='method' style='display: none;'><a href="module-modules_outils.html#.xcas">xcas</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#acos">acos</a></li><li><a href="global.html#AfficheCoteSegment">AfficheCoteSegment</a></li><li><a href="global.html#AfficheLongueurSegment">AfficheLongueurSegment</a></li><li><a href="global.html#AfficheMesureAngle">AfficheMesureAngle</a></li><li><a href="global.html#AfficherCrayon">AfficherCrayon</a></li><li><a href="global.html#afficherTempo">afficherTempo</a></li><li><a href="global.html#afficherTempoId">afficherTempoId</a></li><li><a href="global.html#afficherUnParUn">afficherUnParUn</a></li><li><a href="global.html#affiniteOrtho">affiniteOrtho</a></li><li><a href="global.html#aireTriangle">aireTriangle</a></li><li><a href="global.html#ajouteChampTexte">ajouteChampTexte</a></li><li><a href="global.html#ajouterAx">ajouterAx</a></li><li><a href="global.html#ajouterAy">ajouterAy</a></li><li><a href="global.html#allerA">allerA</a></li><li><a href="global.html#angle">angle</a></li><li><a href="global.html#angleCodage">angleCodage</a></li><li><a href="global.html#angleCodageMasquer">angleCodageMasquer</a></li><li><a href="global.html#angleCodageMontrer">angleCodageMontrer</a></li><li><a href="global.html#angleModulo">angleModulo</a></li><li><a href="global.html#angleOriente">angleOriente</a></li><li><a href="global.html#angleradian">angleradian</a></li><li><a href="global.html#angleScratchTo2d">angleScratchTo2d</a></li><li><a href="global.html#appartientSegment">appartientSegment</a></li><li><a href="global.html#apps">apps</a></li><li><a href="global.html#Arc">Arc</a></li><li><a href="global.html#ArcMainLevee">ArcMainLevee</a></li><li><a href="global.html#ArcPointPointAngle">ArcPointPointAngle</a></li><li><a href="global.html#asin">asin</a></li><li><a href="global.html#atan">atan</a></li><li><a href="global.html#attendre">attendre</a></li><li><a href="global.html#autoCorrection">autoCorrection</a></li><li><a href="global.html#avance">avance</a></li><li><a href="global.html#Axes">Axes</a></li><li><a href="global.html#baisseCrayon">baisseCrayon</a></li><li><a href="global.html#barycentre">barycentre</a></li><li><a href="global.html#bissectrice">bissectrice</a></li><li><a href="global.html#bissectriceAuCompas">bissectriceAuCompas</a></li><li><a href="global.html#cacherParDiv">cacherParDiv</a></li><li><a href="global.html#carre">carre</a></li><li><a href="global.html#carre1point1longueur">carre1point1longueur</a></li><li><a href="global.html#carreIndirect">carreIndirect</a></li><li><a href="global.html#centreCercleCirconscrit">centreCercleCirconscrit</a></li><li><a href="global.html#centreGraviteTriangle">centreGraviteTriangle</a></li><li><a href="global.html#Cercle">Cercle</a></li><li><a href="global.html#cercle3d">cercle3d</a></li><li><a href="global.html#CercleCentrePoint">CercleCentrePoint</a></li><li><a href="global.html#cercleCirconscrit">cercleCirconscrit</a></li><li><a href="global.html#CercleMainLevee">CercleMainLevee</a></li><li><a href="global.html#CibleCarree">CibleCarree</a></li><li><a href="global.html#CibleCouronne">CibleCouronne</a></li><li><a href="global.html#CibleRonde">CibleRonde</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CodageAngleDroit">CodageAngleDroit</a></li><li><a href="global.html#codageAngleDroit">codageAngleDroit</a></li><li><a href="global.html#codageAngleDroitMasquer">codageAngleDroitMasquer</a></li><li><a href="global.html#CodageBissectrice">CodageBissectrice</a></li><li><a href="global.html#CodageMediatrice">CodageMediatrice</a></li><li><a href="global.html#CodageMilieu">CodageMilieu</a></li><li><a href="global.html#CodeAngle">CodeAngle</a></li><li><a href="global.html#CodeSegment">CodeSegment</a></li><li><a href="global.html#CodeSegments">CodeSegments</a></li><li><a href="global.html#codeTikz">codeTikz</a></li><li><a href="global.html#compasCercleCentrePoint">compasCercleCentrePoint</a></li><li><a href="global.html#compasCoucher">compasCoucher</a></li><li><a href="global.html#compasDeplacer">compasDeplacer</a></li><li><a href="global.html#compasEcarter">compasEcarter</a></li><li><a href="global.html#compasEcarter2Points">compasEcarter2Points</a></li><li><a href="global.html#compasEcarterAvecRegle">compasEcarterAvecRegle</a></li><li><a href="global.html#compasLever">compasLever</a></li><li><a href="global.html#compasMasquer">compasMasquer</a></li><li><a href="global.html#compasMontrer">compasMontrer</a></li><li><a href="global.html#compasRetourner">compasRetourner</a></li><li><a href="global.html#compasRotation">compasRotation</a></li><li><a href="global.html#compasTracerArc2Angles">compasTracerArc2Angles</a></li><li><a href="global.html#compasTracerArcCentrePoint">compasTracerArcCentrePoint</a></li><li><a href="global.html#compasZoom">compasZoom</a></li><li><a href="global.html#Cone3d">Cone3d</a></li><li><a href="global.html#ConstructionBissectrice">ConstructionBissectrice</a></li><li><a href="global.html#ConstructionMediatrice">ConstructionMediatrice</a></li><li><a href="global.html#cos">cos</a></li><li><a href="global.html#cosineInterpolate">cosineInterpolate</a></li><li><a href="global.html#Courbe">Courbe</a></li><li><a href="global.html#Courbe2">Courbe2</a></li><li><a href="global.html#courbeInterpolee">courbeInterpolee</a></li><li><a href="global.html#crayonDeplacer">crayonDeplacer</a></li><li><a href="global.html#crayonMasquer">crayonMasquer</a></li><li><a href="global.html#crayonMontrer">crayonMontrer</a></li><li><a href="global.html#crayonRotation">crayonRotation</a></li><li><a href="global.html#creeIdPourComparaison">creeIdPourComparaison</a></li><li><a href="global.html#creerLutin">creerLutin</a></li><li><a href="global.html#Cylindre3d">Cylindre3d</a></li><li><a href="global.html#dansLaCibleCarree">dansLaCibleCarree</a></li><li><a href="global.html#dansLaCibleRonde">dansLaCibleRonde</a></li><li><a href="global.html#degres">degres</a></li><li><a href="global.html#demicercle3d">demicercle3d</a></li><li><a href="global.html#demiDroite">demiDroite</a></li><li><a href="global.html#demiDroiteAvecExtremite">demiDroiteAvecExtremite</a></li><li><a href="global.html#demiTourPoint">demiTourPoint</a></li><li><a href="global.html#demiTourPolygone">demiTourPolygone</a></li><li><a href="global.html#deplaceLabel">deplaceLabel</a></li><li><a href="global.html#deplacer">deplacer</a></li><li><a href="global.html#distancePointDroite">distancePointDroite</a></li><li><a href="global.html#Droite">Droite</a></li><li><a href="global.html#DroiteGraduee">DroiteGraduee</a></li><li><a href="global.html#DroiteGraduee2">DroiteGraduee2</a></li><li><a href="global.html#droiteHorizontaleParPoint">droiteHorizontaleParPoint</a></li><li><a href="global.html#DroiteMainLevee">DroiteMainLevee</a></li><li><a href="global.html#droiteParPointEtParallele">droiteParPointEtParallele</a></li><li><a href="global.html#droiteParPointEtPente">droiteParPointEtPente</a></li><li><a href="global.html#droiteParPointEtPerpendiculaire">droiteParPointEtPerpendiculaire</a></li><li><a href="global.html#droiteParPointEtVecteur">droiteParPointEtVecteur</a></li><li><a href="global.html#droiteVerticaleParPoint">droiteVerticaleParPoint</a></li><li><a href="global.html#elimineDoublons">elimineDoublons</a></li><li><a href="global.html#Ellipse">Ellipse</a></li><li><a href="global.html#equerreDeplacer">equerreDeplacer</a></li><li><a href="global.html#equerreMasquer">equerreMasquer</a></li><li><a href="global.html#equerreMontrer">equerreMontrer</a></li><li><a href="global.html#equerreRotation">equerreRotation</a></li><li><a href="global.html#equerreZoom">equerreZoom</a></li><li><a href="global.html#exerciceCustom">exerciceCustom</a></li><li><a href="global.html#exerciceMathLive">exerciceMathLive</a></li><li><a href="global.html#exerciceNumerique">exerciceNumerique</a></li><li><a href="global.html#exerciceQcm">exerciceQcm</a></li><li><a href="global.html#Fond_ecran">Fond_ecran</a></li><li><a href="global.html#FractionParPosition">FractionParPosition</a></li><li><a href="global.html#graphiqueInterpole">graphiqueInterpole</a></li><li><a href="global.html#Grille">Grille</a></li><li><a href="global.html#grille">grille</a></li><li><a href="global.html#GrilleHorizontale">GrilleHorizontale</a></li><li><a href="global.html#grilleHorizontale">grilleHorizontale</a></li><li><a href="global.html#grilleVerticale">grilleVerticale</a></li><li><a href="global.html#hauteur">hauteur</a></li><li><a href="global.html#hauteurTriangle">hauteurTriangle</a></li><li><a href="global.html#homothetie">homothetie</a></li><li><a href="global.html#homothetie3d">homothetie3d</a></li><li><a href="global.html#HomothetieAnimee">HomothetieAnimee</a></li><li><a href="global.html#homothetiePoint">homothetiePoint</a></li><li><a href="global.html#homothetiePolygone">homothetiePolygone</a></li><li><a href="global.html#html">html</a></li><li><a href="global.html#htmlBouton">htmlBouton</a></li><li><a href="global.html#image">image</a></li><li><a href="global.html#isArrayInArray">isArrayInArray</a></li><li><a href="global.html#item_to_contenu">item_to_contenu</a></li><li><a href="global.html#LabelPoint">LabelPoint</a></li><li><a href="global.html#labelX">labelX</a></li><li><a href="global.html#LabelY">LabelY</a></li><li><a href="global.html#labelY">labelY</a></li><li><a href="global.html#Labyrinthe">Labyrinthe</a></li><li><a href="global.html#latexParPoint">latexParPoint</a></li><li><a href="global.html#LatexReperageSurUnAxe">LatexReperageSurUnAxe</a></li><li><a href="global.html#leveCrayon">leveCrayon</a></li><li><a href="global.html#loadGiac">loadGiac</a></li><li><a href="global.html#loadIep">loadIep</a></li><li><a href="global.html#loadMathLive">loadMathLive</a></li><li><a href="global.html#loadMG32">loadMG32</a></li><li><a href="global.html#loadPrism">loadPrism</a></li><li><a href="global.html#loadScratchblocks">loadScratchblocks</a></li><li><a href="global.html#longueur">longueur</a></li><li><a href="global.html#masquer">masquer</a></li><li><a href="global.html#mathalea2d">mathalea2d</a></li><li><a href="global.html#mediane">mediane</a></li><li><a href="global.html#medianeTriangle">medianeTriangle</a></li><li><a href="global.html#mediatrice">mediatrice</a></li><li><a href="global.html#mediatriceAuCompas">mediatriceAuCompas</a></li><li><a href="global.html#mediatriceRegleEquerre">mediatriceRegleEquerre</a></li><li><a href="global.html#mettrexA">mettrexA</a></li><li><a href="global.html#mettreyA">mettreyA</a></li><li><a href="global.html#mg32DisplayAll">mg32DisplayAll</a></li><li><a href="global.html#milieu">milieu</a></li><li><a href="global.html#montrer">montrer</a></li><li><a href="global.html#montrerParDiv">montrerParDiv</a></li><li><a href="global.html#my_svg_font">my_svg_font</a></li><li><a href="global.html#NommePolygone">NommePolygone</a></li><li><a href="global.html#NomVecteurParPosition">NomVecteurParPosition</a></li><li><a href="global.html#norme">norme</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#orienter">orienter</a></li><li><a href="global.html#orthoCentre">orthoCentre</a></li><li><a href="global.html#paralleleRegleEquerre2points3epoint">paralleleRegleEquerre2points3epoint</a></li><li><a href="global.html#parallelogramme2points1hauteur">parallelogramme2points1hauteur</a></li><li><a href="global.html#parallelogramme2sommetsConsecutifsCentre">parallelogramme2sommetsConsecutifsCentre</a></li><li><a href="global.html#parallelogramme3points">parallelogramme3points</a></li><li><a href="global.html#parallelogramme3sommetsConsecutifs">parallelogramme3sommetsConsecutifs</a></li><li><a href="global.html#parallelogrammeAngleCentre">parallelogrammeAngleCentre</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#Pavage">Pavage</a></li><li><a href="global.html#Pave">Pave</a></li><li><a href="global.html#perpendiculaireRegleEquerre2points3epoint">perpendiculaireRegleEquerre2points3epoint</a></li><li><a href="global.html#Point">Point</a></li><li><a href="global.html#pointAdistance">pointAdistance</a></li><li><a href="global.html#PointCliquable">PointCliquable</a></li><li><a href="global.html#pointCreer">pointCreer</a></li><li><a href="global.html#pointDansRepere">pointDansRepere</a></li><li><a href="global.html#pointDeplacer">pointDeplacer</a></li><li><a href="global.html#pointIntersectionCC">pointIntersectionCC</a></li><li><a href="global.html#pointIntersectionDD">pointIntersectionDD</a></li><li><a href="global.html#pointIntersectionLC">pointIntersectionLC</a></li><li><a href="global.html#pointMasquer">pointMasquer</a></li><li><a href="global.html#pointMontrer">pointMontrer</a></li><li><a href="global.html#pointNommer">pointNommer</a></li><li><a href="global.html#pointsCreer">pointsCreer</a></li><li><a href="global.html#pointSurCercle">pointSurCercle</a></li><li><a href="global.html#pointSurDroite">pointSurDroite</a></li><li><a href="global.html#pointSurSegment">pointSurSegment</a></li><li><a href="global.html#Polygone">Polygone</a></li><li><a href="global.html#polygoneAvecNom">polygoneAvecNom</a></li><li><a href="global.html#PolygoneMainLevee">PolygoneMainLevee</a></li><li><a href="global.html#polygoneRapide">polygoneRapide</a></li><li><a href="global.html#polygoneRegulier">polygoneRegulier</a></li><li><a href="global.html#polygoneRegulierIndirect">polygoneRegulierIndirect</a></li><li><a href="global.html#polygoneRegulierParCentreEtRayon">polygoneRegulierParCentreEtRayon</a></li><li><a href="global.html#polygoneTracer">polygoneTracer</a></li><li><a href="global.html#Polyline">Polyline</a></li><li><a href="global.html#projectionOrtho">projectionOrtho</a></li><li><a href="global.html#propositionsQcm">propositionsQcm</a></li><li><a href="global.html#qcmDisponible">qcmDisponible</a></li><li><a href="global.html#questionAchat">questionAchat</a></li><li><a href="global.html#rapporteurCrayonMarqueAngle">rapporteurCrayonMarqueAngle</a></li><li><a href="global.html#rapporteurDeplacer">rapporteurDeplacer</a></li><li><a href="global.html#rapporteurDeplacerRotation2Points">rapporteurDeplacerRotation2Points</a></li><li><a href="global.html#rapporteurMasquer">rapporteurMasquer</a></li><li><a href="global.html#rapporteurMasquerGraduationsExterieures">rapporteurMasquerGraduationsExterieures</a></li><li><a href="global.html#rapporteurMasquerGraduationsInterieures">rapporteurMasquerGraduationsInterieures</a></li><li><a href="global.html#rapporteurMontrer">rapporteurMontrer</a></li><li><a href="global.html#rapporteurMontrerGraduationsExterieures">rapporteurMontrerGraduationsExterieures</a></li><li><a href="global.html#rapporteurMontrerGraduationsInterieures">rapporteurMontrerGraduationsInterieures</a></li><li><a href="global.html#rapporteurRotation">rapporteurRotation</a></li><li><a href="global.html#rapporteurTracerDemiDroiteAngle">rapporteurTracerDemiDroiteAngle</a></li><li><a href="global.html#rapporteurZoom">rapporteurZoom</a></li><li><a href="global.html#regleDemiDroiteOriginePoint">regleDemiDroiteOriginePoint</a></li><li><a href="global.html#regleDeplacer">regleDeplacer</a></li><li><a href="global.html#regleDroite">regleDroite</a></li><li><a href="global.html#regleMasquer">regleMasquer</a></li><li><a href="global.html#regleMasquerGraduations">regleMasquerGraduations</a></li><li><a href="global.html#regleModifierLongueur">regleModifierLongueur</a></li><li><a href="global.html#regleMontrer">regleMontrer</a></li><li><a href="global.html#regleMontrerGraduations">regleMontrerGraduations</a></li><li><a href="global.html#regleProlongerSegment">regleProlongerSegment</a></li><li><a href="global.html#regleRotation">regleRotation</a></li><li><a href="global.html#regleSegment">regleSegment</a></li><li><a href="global.html#regleZoom">regleZoom</a></li><li><a href="global.html#renommePolygone">renommePolygone</a></li><li><a href="global.html#requerreDeplacer">requerreDeplacer</a></li><li><a href="global.html#requerreGlisserEquerre">requerreGlisserEquerre</a></li><li><a href="global.html#requerreMasquer">requerreMasquer</a></li><li><a href="global.html#requerreMontrer">requerreMontrer</a></li><li><a href="global.html#requerreRotation">requerreRotation</a></li><li><a href="global.html#requerreZoom">requerreZoom</a></li><li><a href="global.html#rotation">rotation</a></li><li><a href="global.html#rotation3d">rotation3d</a></li><li><a href="global.html#RotationAnimee">RotationAnimee</a></li><li><a href="global.html#rotationPoint">rotationPoint</a></li><li><a href="global.html#rotationPolygone">rotationPolygone</a></li><li><a href="global.html#rotationV3d">rotationV3d</a></li><li><a href="global.html#scratchblock">scratchblock</a></li><li><a href="global.html#script">script</a></li><li><a href="global.html#Segment">Segment</a></li><li><a href="global.html#segmentAvecExtremites">segmentAvecExtremites</a></li><li><a href="global.html#segmentCodage">segmentCodage</a></li><li><a href="global.html#segmentCodageMasquer">segmentCodageMasquer</a></li><li><a href="global.html#segmentCodageMontrer">segmentCodageMontrer</a></li><li><a href="global.html#SegmentMainLevee">SegmentMainLevee</a></li><li><a href="global.html#SensDeRotation">SensDeRotation</a></li><li><a href="global.html#SensDeRotation3d">SensDeRotation3d</a></li><li><a href="global.html#setReponse">setReponse</a></li><li><a href="global.html#seyes">seyes</a></li><li><a href="global.html#similitude">similitude</a></li><li><a href="global.html#sin">sin</a></li><li><a href="global.html#Sphere3d">Sphere3d</a></li><li><a href="global.html#SVG_Axe_horizontal">SVG_Axe_horizontal</a></li><li><a href="global.html#SVG_Axe_vertical">SVG_Axe_vertical</a></li><li><a href="global.html#SVG_chemin">SVG_chemin</a></li><li><a href="global.html#SVG_engrenages">SVG_engrenages</a></li><li><a href="global.html#SVG_fleche_machine_maths">SVG_fleche_machine_maths</a></li><li><a href="global.html#SVG_fraction">SVG_fraction</a></li><li><a href="global.html#SVG_graduation">SVG_graduation</a></li><li><a href="global.html#SVG_grille">SVG_grille</a></li><li><a href="global.html#SVG_label">SVG_label</a></li><li><a href="global.html#SVG_machine_diag_3F1_act_mono">SVG_machine_diag_3F1_act_mono</a></li><li><a href="global.html#SVG_machine_diag_3F12">SVG_machine_diag_3F12</a></li><li><a href="global.html#SVG_machine_maths">SVG_machine_maths</a></li><li><a href="global.html#SVG_tracer_droite_flecheH">SVG_tracer_droite_flecheH</a></li><li><a href="global.html#SVG_tracer_droite_flecheV">SVG_tracer_droite_flecheV</a></li><li><a href="global.html#SVG_tracer_flecheH">SVG_tracer_flecheH</a></li><li><a href="global.html#SVG_tracer_flecheV">SVG_tracer_flecheV</a></li><li><a href="global.html#SVG_tracer_point">SVG_tracer_point</a></li><li><a href="global.html#SvgReperageSurUnAxe">SvgReperageSurUnAxe</a></li><li><a href="global.html#SymetrieAnimee">SymetrieAnimee</a></li><li><a href="global.html#symetrieAxiale">symetrieAxiale</a></li><li><a href="global.html#symetrieAxialePoint">symetrieAxialePoint</a></li><li><a href="global.html#symetrieAxialePolygone">symetrieAxialePolygone</a></li><li><a href="global.html#Tableau">Tableau</a></li><li><a href="global.html#Tableau_de_variation">Tableau_de_variation</a></li><li><a href="global.html#tan">tan</a></li><li><a href="global.html#textarea_to_array">textarea_to_array</a></li><li><a href="global.html#texteDeplacer">texteDeplacer</a></li><li><a href="global.html#texteMasquer">texteMasquer</a></li><li><a href="global.html#TexteParPoint">TexteParPoint</a></li><li><a href="global.html#texteParPosition">texteParPosition</a></li><li><a href="global.html#textePoint">textePoint</a></li><li><a href="global.html#textePosition">textePosition</a></li><li><a href="global.html#TexteSurSegment">TexteSurSegment</a></li><li><a href="global.html#tournerD">tournerD</a></li><li><a href="global.html#tournerG">tournerG</a></li><li><a href="global.html#TraceBarre">TraceBarre</a></li><li><a href="global.html#TraceBarreHorizontale">TraceBarreHorizontale</a></li><li><a href="global.html#traceCompas">traceCompas</a></li><li><a href="global.html#TraceGraphiqueCartesien">TraceGraphiqueCartesien</a></li><li><a href="global.html#TracePoint">TracePoint</a></li><li><a href="global.html#TracePointSurDroite">TracePointSurDroite</a></li><li><a href="global.html#tracer">tracer</a></li><li><a href="global.html#trait">trait</a></li><li><a href="global.html#traitMasquer">traitMasquer</a></li><li><a href="global.html#traitRapide">traitRapide</a></li><li><a href="global.html#translation">translation</a></li><li><a href="global.html#translation2Points">translation2Points</a></li><li><a href="global.html#translation3d">translation3d</a></li><li><a href="global.html#TranslationAnimee">TranslationAnimee</a></li><li><a href="global.html#translationPoint">translationPoint</a></li><li><a href="global.html#translationPolygone">translationPolygone</a></li><li><a href="global.html#triangle1longueur2angles">triangle1longueur2angles</a></li><li><a href="global.html#triangle2longueurs1angle">triangle2longueurs1angle</a></li><li><a href="global.html#triangle2points1angle1longueur">triangle2points1angle1longueur</a></li><li><a href="global.html#triangle2points1angle1longueurOppose">triangle2points1angle1longueurOppose</a></li><li><a href="global.html#triangle2points1hauteur">triangle2points1hauteur</a></li><li><a href="global.html#triangle2points2angles">triangle2points2angles</a></li><li><a href="global.html#triangle2points2longueurs">triangle2points2longueurs</a></li><li><a href="global.html#triangle3longueurs">triangle3longueurs</a></li><li><a href="global.html#triangleEquilateral">triangleEquilateral</a></li><li><a href="global.html#triangleEquilateral2Sommets">triangleEquilateral2Sommets</a></li><li><a href="global.html#triangleRectangle2Cotes">triangleRectangle2Cotes</a></li><li><a href="global.html#triangleRectangleCoteHypotenuse">triangleRectangleCoteHypotenuse</a></li><li><a href="global.html#txt_to_objet_parametres_exercice">txt_to_objet_parametres_exercice</a></li><li><a href="global.html#updateMessageErreur">updateMessageErreur</a></li><li><a href="global.html#Vecteur">Vecteur</a></li><li><a href="global.html#waitFor">waitFor</a></li><li><a href="global.html#waitForGiac">waitForGiac</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/Alea2iep.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable camelcase */
import { vecteur, polygoneAvecNom, translation, symetrieAxiale, appartientDroite, point, pointAdistance, droite, droiteParPointEtPerpendiculaire, segment, triangle2points2longueurs, cercle, pointIntersectionLC, homothetie, longueur, milieu, pointSurSegment, rotation, pointIntersectionDD, translation2Points, droiteParPointEtParallele, projectionOrtho, centreCercleCirconscrit, angleOriente, norme } from './2d.js'
import { calcul, randint, nombreAvecEspace, arrondi, texNombre } from './outils.js'
import iepLoadPromise from 'instrumenpoche'
import { context } from './context.js'

/*
 * Classe parente de tous les objets Alea2iep
 *
 * @author Rmi Angot
 */
export default function Alea2iep () {
  this.idIEP = 0 // Identifiant pour les tracs
  this.idHTML = 0 // Identifiant pour les div et le svg
  this.tempo = 5 // Pause par dfaut aprs une instruction
  this.vitesse = 10 // Vitesse par dfaut pour les dplacements d'instruments
  this.couleur = 'blue' // Couleur par dfaut
  this.couleurCompas = 'forestgreen'
  this.couleurTexte = 'black'
  this.couleurPoint = 'black' // Couleur du nom des points
  this.couleurCodage = '#f15929'
  this.couleurTraitsDeConstruction = 'gray'
  this.epaisseur = 2
  this.epaisseurTraitsDeConstruction = 1
  this.pointilles = false
  this.liste_script = [] // Liste des instructions xml mise  jour par les mthodes

  this.translationX = 0
  this.translationY = 10 // Par dfaut l'angle en haut  gauche est le point de coordonnes (0,10)

  this.recadre = function (xmin, ymax) {
    this.translationX = 1 - xmin
    this.translationY = ymax + 3
  }

  // Garde en mmoire les coordonnes extrmes des objets crs
  this.xMin = 0
  this.yMin = 0
  this.xMax = 0
  this.yMax = 0

  this.taille = function (width, height) {
    this.liste_script.push(`&lt;viewBox width="${width}" height="${height}" />`)
  }
  // Transforme les coordonnes MathALEA2D en coordonnes pour le XML d'IEP
  this.x = function (A) {
    const x = calcul((A.x + this.translationX) * 30, 0)
    if (A.x > this.xMax) {
      this.xMax = A.x
    }
    if (A.x &lt; this.xMin) {
      this.xMin = A.x
    }
    return x
  }
  this.y = function (A) {
    const y = calcul((-A.y + this.translationY) * 30, 0)
    if (A.y &lt; this.yMin) {
      this.yMin = A.y
    }
    if (A.y > this.yMax) {
      this.yMax = A.y
    }
    return y
  }

  // Sauvegarde de l'tat des instruments
  this.regle = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    longueur: 15,
    zoom: 100
  }

  this.crayon = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    zoom: 100
  }

  this.equerre = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    zoom: 100
  }

  this.requerre = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    zoom: 100
  }

  this.rapporteur = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    zoom: 100
  }

  this.compas = {
    visibilite: false,
    position: point(0, 0),
    angle: 0,
    orientation: 'droite',
    ecartement: 0,
    leve: false,
    zoom: 100
  }

  this.xml = ''

  /**
   * Renvoie le script xml
   *
   */
  this.script = function () {
    if (this.xml.length > 1) {
      return this.xml
    } else {
      let codeXML = '&lt;?xml version="1.0" encoding="UTF-8"?>\n'
      codeXML += '&lt;INSTRUMENPOCHE version="2">\n'
      codeXML += this.liste_script.join('\n')
      codeXML += '\n&lt;/INSTRUMENPOCHE>'
      return codeXML
    }
  }

  /**
   * Renvoie le code HTML de l'animation
   * @param {int} numeroExercice - Numro de l'exercice
   * @param {int} i - Numro de la question
   */
  this.html = function (id1, id2) {
    if (context.isHtml) {
      const id = `IEP_${id1}_${id2}`
      window.listeScriptsIep[id] = this.script() // On ajoute le script
      const codeHTML = `&lt;div id="IEPContainer${id}" >&lt;/div>`
      window.listeAnimationsIepACharger.push(id)
      return codeHTML
    }
  }

  /**
   *
   * @param {int} numeroExercice - Numro de l'exercice
   * @param {int} i - Numro de la question
   * @return Code HTML avec le bouton qui affiche ou masque un div avec l'animation
   */
  this.htmlBouton = function (id1, id2 = '') {
    if (context.isHtml) {
      const id = `IEP_${id1}_${id2}`
      window.listeScriptsIep[id] = this.script() // On ajoute le script
      const codeHTML = `&lt;br>&lt;button class="ui mini compact button" id="btnAnimation${id}" onclick="toggleVisibilityIEP('${id}')" style="margin-top:20px">&lt;i class="large play circle outline icon">&lt;/i>Voir animation&lt;/button>
            &lt;div id="IEPContainer${id}" style="display: none;" >&lt;/div>`
      if (!window.toggleVisibilityIEP) {
        window.toggleVisibilityIEP = function (id) {
          const element = document.getElementById(`IEPContainer${id}`)
          const elementBtn = document.getElementById(`btnAnimation${id}`)
          const xml = window.listeScriptsIep[id]
          if (element.style.display === 'none') {
            element.style.display = 'block'
            element.style.marginTop = '30px'
            elementBtn.innerHTML = '&lt;i class="large stop circle outline icon">&lt;/i>Masquer animation'
            iepLoadPromise(element, xml, { zoom: true, autostart: true }).then(iepApp => {
              // la figure est charge
            }).catch(error => { console.log(error) })
          } else {
            element.style.display = 'none'
            elementBtn.innerHTML = '&lt;i class="large play circle outline icon">&lt;/i>Voir animation'
          }
        }
      }
      return codeHTML
    } else {
      return ''
    }
  }

  /**
 **************************
 *** FONCTIONS COMMUNES ***
 **************************
 */

  /**
   *
   * @param {string} objet - 'regle', 'equerre', 'requerre, 'compas', 'rapporteur' ou 'crayon'
   * @param {point} A - Point (0, 0) par dfaut
   * @param {objet} options - { tempo : 10 }
   */
  this.montrer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    if (!this[objet].visibilite || this[objet].position !== A) { // On ajoute une ligne xml que si l'objet est cach ou doit apparaitre  un autre endroit
      let codeXML = ''
      let A1
      if (typeof A === 'undefined') { // A1 est une copie de A ou (0,0) si A n'est pas dfini
        A1 = this[objet].position
      } else {
        A1 = A
      }
      if (this[objet].visibilite) { // S'il est dj visible, montrer devient un dplcer
        this.deplacer(objet, A1, { tempo: tempo, vitesse: vitesse })
      } else {
        codeXML = `&lt;action objet="${objet}" mouvement="montrer" abscisse="${this.x(A1)}" ordonnee="${this.y(A1)}" tempo="${tempo}" />`
        this[objet].visibilite = true
      }
      this[objet].position = A1
      this.liste_script.push(codeXML)
    }
  }

  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.regleMontrer = function (A, options) {
    this.montrer('regle', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.crayonMontrer = function (A, options) {
    this.montrer('crayon', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.equerreMontrer = function (A, options) {
    this.montrer('equerre', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.requerreMontrer = function (A, options) {
    this.montrer('requerre', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.compasMontrer = function (A, options) {
    this.montrer('compas', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.rapporteurMontrer = function (A, options) {
    this.montrer('rapporteur', A, options)
  }

  /**
   *
   * @param {string} objet
   * @param {objet} param1
   */
  this.masquer = function (objet, { tempo = this.tempo } = {}) {
    if (this[objet].visibilite) { // On ajoute une ligne xml que si l'objet est visible
      const codeXML = `&lt;action objet="${objet}" mouvement="masquer" tempo="${tempo}" />`
      this[objet].visibilite = false
      this.liste_script.push(codeXML)
    }
  }
  /**
   *
   * @param {objet} options
   */
  this.regleMasquer = function (options) {
    this.masquer('regle', options)
  }
  /**
   *
   * @param {objet} options
   */
  this.crayonMasquer = function (options) {
    this.masquer('crayon', options)
  }
  /**
   *
   * @param {objet} options
   */
  this.equerreMasquer = function (options) {
    this.masquer('equerre', options)
  }
  /**
   *
   * @param {objet} options
   */
  this.requerreMasquer = function (options) {
    this.masquer('requerre', options)
  }
  /**
   *
   * @param {objet} options
   */
  this.compasMasquer = function (options) {
    this.masquer('compas', options)
  }
  /**
   *
   * @param {objet} options
   */
  this.rapporteurMasquer = function (options) {
    this.masquer('rapporteur', options)
  }

  /**
 *
 * @param {string} objet
 * @param {point} A
 * @param {objet} options
 */
  this.deplacer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    if (this[objet].position !== A) { // On n'ajoute une commande xml que s'il y a vraiment un dplacement
      const codeXML = `&lt;action objet="${objet}" mouvement="translation" abscisse="${this.x(A)}" ordonnee="${this.y(A)}" tempo="${tempo}" vitesse="${vitesse}" />`
      this[objet].position = A
      this.liste_script.push(codeXML)
    }
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.regleDeplacer = function (A, options) {
    this.deplacer('regle', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.texteDeplacer = function (id, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    const codeXML = `&lt;action objet="texte" id="${id}" mouvement="translation" abscisse="${this.x(A)}" ordonnee="${this.y(A)}" tempo="${tempo}" vitesse="${vitesse}" />`
    this.liste_script.push(codeXML)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.crayonDeplacer = function (A, options) {
    this.deplacer('crayon', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.equerreDeplacer = function (A, options) {
    this.deplacer('equerre', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.requerreDeplacer = function (A, options) {
    this.deplacer('requerre', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.compasDeplacer = function (A, options) {
    this.deplacer('compas', A, options)
  }
  /**
   *
   * @param {point} A
   * @param {objet} options
   */
  this.rapporteurDeplacer = function (A, options) {
    this.deplacer('rapporteur', A, options)
  }

  /**
 *
 * @param {string} objet
 * @param {int} angle
 * @param {objet} options
 */
  this.rotation = function (objet, a, { tempo = this.tempo, sens = calcul(this.vitesse / 2, 0) } = {}) {
    let angle
    if (a.typeObjet === 'point') {
      const d = droite(this[objet].position, a)
      angle = d.angleAvecHorizontale
    } else {
      angle = a
    }
    if (this[objet].angle !== a) { // Si la rotation est inutile, on ne la fait pas
      // Les angles de MathALEA2D et de IEP sont opposs !!!!!
      const codeXML = `&lt;action objet="${objet}" mouvement="rotation" angle="${-1 * angle}" tempo="${tempo}" sens="${sens}" />`
      this[objet].angle = angle
      if (typeof angle === 'number' &amp;&amp; isFinite(angle)) {
        this.liste_script.push(codeXML)
      } else {
        console.log('Angle de rotation non dfini pour l\'objet .', objet)
      }
    }
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.regleRotation = function (angle, options) {
    this.rotation('regle', angle, options)
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.crayonRotation = function (angle, options) {
    this.rotation('crayon', angle, options)
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.equerreRotation = function (angle, options) {
    this.rotation('equerre', angle, options)
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.requerreRotation = function (angle, options) {
    this.rotation('requerre', angle, options)
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.compasRotation = function (angle, options) {
    this.rotation('compas', angle, options)
  }
  /**
 *
 * @param {int} angle
 * @param {objet} options
 */
  this.rapporteurRotation = function (angle, options) {
    this.rotation('rapporteur', angle, options)
  }
  /**
 *
 * @param {int} pourcentage 200 pour doubler la taille
 * @param {objet} options tempo = 0 par dfaut
 */
  this.regleZoom = function (k, { tempo = 0 } = {}) {
    this.regle.zoom = k
    this.liste_script.push(`&lt;action echelle="${k}" mouvement="zoom" objet="regle" tempo="${tempo}" />`)
  }
  /**
 *
 * @param {int} pourcentage 200 pour doubler la taille
 * @param {objet} options tempo = 0 par dfaut
 */
  this.equerreZoom = function (k, { tempo = 0 } = {}) {
    this.equerre.zoom = k
    this.liste_script.push(`&lt;action echelle="${k}" mouvement="zoom" objet="equerre" tempo="${tempo}" />`)
  }
  /**
 *
 * @param {int} pourcentage 200 pour doubler la taille
 * @param {objet} options tempo = 0 par dfaut
 */
  this.requerreZoom = function (k, { tempo = 0 } = {}) {
    this.requerre.zoom = k
    this.liste_script.push(`&lt;action echelle="${k}" mouvement="zoom" objet="requerre" tempo="${tempo}" />`)
  }
  /**
 *
 * @param {int} pourcentage 200 pour doubler la taille
 * @param {objet} options tempo = 0 par dfaut
 */
  this.rapporteurZoom = function (k, { tempo = 0 } = {}) {
    this.rapporteur.zoom = k
    this.liste_script.push(`&lt;action echelle="${k}" mouvement="zoom" objet="rapporteur" tempo="${tempo}" />`)
  }
  /**
 *
 * @param {int} pourcentage 200 pour doubler la taille
 * @param {objet} options tempo = 0 par dfaut
 */
  this.compasZoom = function (k, { tempo = 0 } = {}) {
    this.compas.zoom = k
    this.liste_script.push(`&lt;action echelle="${k}" mouvement="zoom" objet="compas" />`)
  }

  /**
 **************************
 ********* POINT **********
 **************************
 */

  /**
 * Crer un point avec la croix pour le situer et son nom en bas  droite par dfaut. L'id sera sauvegard dans l'objet point. S'il n'est pas dfini alors on prend le premier entier disponible.
 * @param {point} A
 * @param {objet} options { label: A.nom, tempo: this.tempo, couleur: this.couleurPoint, couleurLabel: this.couleurTexte, id }
 *
 */
  this.pointCreer = function (A, { dx = 0.1, dy, label = A.nom, tempo = this.tempo, couleur = this.couleurPoint, couleurLabel = this.couleurTexte, id } = {}) {
    if (typeof id !== 'undefined') {
      A.id = id
    } else {
      this.idIEP++
      A.id = this.idIEP
    }
    let codeXML
    if (label) {
      codeXML = `&lt;action abscisse="${this.x(A)}" ordonnee="${this.y(A)}" couleur="${couleur}" id="${A.id}" mouvement="creer" objet="point" />`
      // codeXML += `\n&lt;action couleur="${couleurLabel}" nom="${label}" id="${this.idIEP}" mouvement="nommer" objet="point" tempo="${tempo}"  />`
      const M = point(A.x, A.y)
      if (typeof dx !== 'undefined') {
        M.x += dx
      }
      if (typeof dy !== 'undefined') {
        M.y += dy
      }
      this.textePoint(`$${label}$`, M, { tempo: 0, couleur: couleurLabel })
    } else {
      codeXML = `&lt;action abscisse="${this.x(A)}" ordonnee="${this.y(A)}" couleur="${couleur}" id="${A.id}" mouvement="creer" objet="point" tempo="${tempo}" />`
    }
    this.liste_script.push(codeXML)
  }
  /**
 * Cration de plusieurs points
 * Le dernier argument peut tre une option qui sera applique  tous les points
 *
 * @param  {...points} points Points spars par des virgules
 */
  this.pointsCreer = function (...args) {
    if (args[args.length - 1].typeObjet === 'point') {
      for (const point of args) {
        this.pointCreer(point, { tempo: 0 })
      }
    } else {
      const options = args[args.length - 1]
      const enleveDernier = arr => arr.slice(0, -1)
      for (const point of enleveDernier(args)) {
        this.pointCreer(point, options)
      }
    }
  }
  /**
 * Masquer un point
 * @param {point} A
 * @param {objet} options Dfaut : { tempo: 0 }
 */
  this.pointMasquer = function (A, { tempo = 0 } = {}) {
    this.liste_script.push(`&lt;action id="${A.id}" mouvement="masquer" objet="point" tempo="${tempo}" />`)
  }
  /**
   * Montrer un point qui aurait t cach
   * @param {point} A
   * @param {objet} options Dfaut ; { tempo : this.tempo }
   */
  this.pointMontrer = function (A, { tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action id="${A.id}" mouvement="montrer" objet="point" tempo="${tempo}" />`)
  }
  /**
   * Anime la translation d'un point
   * @param {point} A
   * @param {int} x Abscisse du point d'arrive
   * @param {int} y Ordonne du point d'arrive
   * @param {objet} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse }
   */
  this.pointDeplacer = function (A, x, y, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    const B = point(x, y)
    this.liste_script.push(`&lt;action abscisse="${this.x(B)}" ordonnee="${this.y(B)}" id="${A.id}" mouvement="translation" objet="point" tempo="${tempo}" vitesse="${vitesse}" />`)
  }
  /**
   * Ajoute un label au point
   * @param {point} A
   * @param {string} nom
   * @param {objet} options dx pour le dplacement vertical du nom du point, dy pour le dplacemetn horizontal, couleur: this.couleurPoint, tempo: this.tempo
   */
  this.pointNommer = function (A, nom, { dx, dy, couleur = this.couleurPoint, tempo = this.tempo } = {}) {
    // const coordonneesTexte = ''
    const M = point(A.x, A.y)
    if (typeof dx !== 'undefined') {
      M.x += dx
    }
    if (typeof dy !== 'undefined') {
      M.y += dy
    }
    this.textePoint(`$${nom}$`, M, { tempo: tempo, couleur: couleur })
    // this.liste_script.push(`&lt;action couleur="${couleur}" nom="${nom}" id="${A.id}" mouvement="nommer" objet="point" tempo="${tempo}" ${coordonneesTexte} />`)
  }

  /**
 **************************
 ********* COMPAS *********
 **************************
 */

  /**
* Change l'orientation du compas. Par dfaut, elle est vers la droite. L'orientation courante du compas est sauvegarde dans this.compas.orientation
* @param {objet} options Dfaut : { tempo: this.tempo}
*/
  this.compasRetourner = function ({ tempo = this.tempo } = {}) {
    const codeXML = `&lt;action mouvement="retourner" objet="compas" tempo="${tempo}" />`
    if (this.compas.orientation === 'droite') {
      this.compas.orientation = 'gauche'
    } else {
      this.compas.orientation = 'droite'
    }
    this.liste_script.push(codeXML)
  }
  /**
   *
   * @param {int} longueur cartement en cm
   * @param {objet} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse }
   */
  this.compasEcarter = function (l, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    const codeXML = `&lt;action ecart="${calcul(l * 30, 1)}" mouvement="ecarter" objet="compas" tempo="${tempo}" vitesse="${vitesse}" />`
    this.compas.ecartement = l
    this.liste_script.push(codeXML)
  }
  /**
   * Fais apparaitre la rgle  l'horizontale, met le compas vertical et carte le compas le long de la rgle pour lire son cartement
   * @param {int} longueur
   * @param {*} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }
   */
  this.compasEcarterAvecRegle = function (l, { tempo = this.tempo, vitesse = this.vitesse, sens = this.vitesse / 2 } = {}) {
    this.regleRotation(0, { tempo: 0, sens: sens })
    this.regleMontrer(this.compas.position, { tempo: 0 })
    this.regleDeplacer(this.compas.position, { tempo: 0, vitesse: vitesse })
    this.compasMontrer()
    this.compasRotation(0, { tempo: 0, sens: sens })
    this.compasEcarter(l, { tempo: tempo, vitesse: vitesse, sens: sens })
  }
  /**
 *
 * @param {point} A Pointe du compas
 * @param {point} B Mine du compas
 * @param {objet} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }
 */
  this.compasEcarter2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2) } = {}) {
    this.compasMontrer(A)
    this.compasDeplacer(A, { tempo: tempo, vitesse: vitesse })
    const s = segment(A, B)
    s.isVisible = false
    const angle = s.angleAvecHorizontale
    this.compasRotation(angle, { tempo: tempo, sens: sens })
    this.compasEcarter(longueur(A, B), { tempo: tempo, vitesse: vitesse })
  }
  /**
 * Remettre le compas en position standard. Son tat est sauvegard dans le boolen this.compas.leve.
 * @param {objet} options Dfaut : { tempo: this.tempo }
 */
  this.compasLever = function ({ tempo = this.tempo } = {}) {
    if (!this.compas.leve) { // On ne fait rien si le compas est dj lev
      const codeXML = `&lt;action mouvement="lever" objet="compas" tempo="${tempo} />`
      this.compas.leve = true
      this.liste_script.push(codeXML)
    }
  }
  /**
 * Voir le compas en vue de dessus avant qu'il trace un arc de cercle
 * @param {objet} options Dfaut : { tempo: this.tempo }
 */
  this.compasCoucher = function ({ tempo = this.tempo } = {}) {
    if (this.compas.leve) { // On ne fait rien si le compas est dj lev
      const codeXML = `&lt;action mouvement="coucher" objet="compas" tempo="${tempo}" />`
      this.compas.leve = false
      this.liste_script.push(codeXML)
    }
  }
  /**
 * Trace un arc de cercle en gardant l'cartement et le centre actuel. L'angle de dpart sera choisi pour tre le plus proche de l'angle actuel
 * @param {int} angle1
 * @param {int} angle2
 * @param {objet} options Dfaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }
 * @return {id}
 */
  this.compasTracerArc2Angles = function (angle1, angle2, { tempo = this.tempo, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {
    const pointillesTexte = pointilles ? 'pointille="tiret"' : ''
    this.idIEP += 1
    if (Math.abs(this.compas.angle - angle1) > Math.abs(this.compas.angle - angle2)) { // On cherche  commencer par le point le plus proche de la position courante du compas
      [angle1, angle2] = [angle2, angle1]
    }
    let codeXML = `&lt;action sens="${sens}" angle="${-angle1}" mouvement="rotation" objet="compas" tempo="${tempo}" />\n`
    codeXML += '&lt;action mouvement="lever" objet="compas" />\n'
    codeXML += `&lt;action sens="${sens}" angle="${-angle1}" mouvement="rotation" objet="compas" />\n`
    let sensTexte
    if (angle2 > angle1) {
      sensTexte = sens
    } else {
      sensTexte = -1 * sens
    }
    codeXML += `&lt;action couleur="${couleur}" epaisseur="${epaisseur}" sens="${sensTexte}" debut="${-angle1}" fin="${-angle2}" mouvement="tracer" objet="compas"  ${pointillesTexte} id="${this.idIEP}" />\n`
    codeXML += `&lt;action mouvement="coucher" objet="compas" tempo="${tempo}"/>`
    this.compas.angle = angle2
    this.liste_script.push(codeXML)
    return this.idIEP
  }
  /**
   * Trace un arc de cercle autour d'un point. La longueur de l'arc est dtermine par l'option delta en degr qui est ajoute de part et d'autre du point
   * @param {point} centre
   * @param {point} point
   * @param {objet} options Dfaut : { delta: 10, tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }
   * @return {id}
   */
  this.compasTracerArcCentrePoint = function (centre, point, { delta = 10, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {
    this.compasMontrer()
    this.compasDeplacer(centre, { tempo: tempo, vitesse: vitesse })
    const s = segment(centre, point)
    s.visibility = false
    const angle1 = s.angleAvecHorizontale - delta
    const angle2 = s.angleAvecHorizontale + delta
    if ((Math.abs(this.compas.ecartement - longueur(this.compas.position, point))) > 0.1) {
      this.compasEcarter(longueur(centre, point), { tempo: tempo, vitesse: vitesse })
    }
    return this.compasTracerArc2Angles(angle1, angle2, { tempo: tempo, vitesse: vitesse, epaisseur: epaisseur, sens: sens, couleur: couleur, pointilles: pointilles })
  }
  /**
 *
 * @param {point} centre
 * @param {point} point Point de dpart du trac du cercle
 * @param {objet} options Dfaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }
 */
  this.compasCercleCentrePoint = function (centre, point, { tempo = this.tempo, couleur = this.couleur, vitesse = this.vitesse, sens = calcul(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {
    this.compasEcarter2Points(centre, point, { vitesse: vitesse, tempo: tempo })
    const d = droite(centre, point)
    const angle1 = d.angleAvecHorizontale
    this.compasTracerArc2Angles(angle1, angle1 + 360, { tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, couleur: couleur, pointilles: pointilles })
  }

  /**
 **************************
 ******** REQUERRE ********
 **************************
 */

  /**
   *
   * @param {int} dplacement en nombre de cm (le dplacement peut tre positif ou ngatif)
   * @param {*} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse }
   */
  this.requerreGlisserEquerre = function (a, { tempo = this.tempo, vitesse = this.vitesse } = {}) {
    this.liste_script.push(`&lt;action abscisse="${a * 30}" mouvement="glisser" objet="requerre" tempo="${tempo}" vitesse="${vitesse}" />`)
  }

  /**
 **************************
 ******* RAPPORTEUR *******
 **************************
 */

  // Non pris en charge par le lecteur JS
  // this.rapporteurCirculaire = function (tempo=this.tempo) {
  // //     this.liste_script.push(`&lt;action mouvement="circulaire" objet="rapporteur" tempo="${tempo}"/>`)
  // }
  // this.rapporteurSemiCirculaire = function (tempo=this.tempo) {
  // //     this.liste_script.push(`&lt;action mouvement="semicirculaire" objet="rapporteur" tempo="${tempo}"/>`)
  // }

  /**
   * Masque la graduation externe du rapporteur (laisse l'autre graduation visible)
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.rapporteurMasquerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="masquer_nombres" objet="rapporteur" tempo="${tempo}"/>`)
  }
  /**
   * Montre la graduation extrieure si elle avait t prcdemment cache
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.rapporteurMontrerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="montrer_nombres" objet="rapporteur" tempo="${tempo}"/>`)
  }
  /**
   * Masque la graduation interne du rapporteur (laisse l'autre graduation visible)
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.rapporteurMasquerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="vide" objet="rapporteur" tempo="${tempo}"/>`)
  }
  /**
   * Montre la graduation interne si elle avait t prcdemment cache
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.rapporteurMontrerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="graduations" objet="rapporteur" tempo="${tempo}"/>`)
  }
  /**
 * Met le rapporteur en position avec le centre en A et le 0 de droite alogn avec le point B
 * @param {point} A
 * @param {point} B
 * @param {objet} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }
 */
  this.rapporteurDeplacerRotation2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2) } = {}) {
    const d = droite(A, B)
    d.isVisible = false
    this.rapporteurMontrer()
    this.rapporteurDeplacer(A, { tempo: tempo, vitesse: vitesse })
    this.rapporteurRotation(d.angleAvecHorizontale, { tempo: tempo, vitesse: vitesse, sens: sens })
  }
  /**
 * Fais une petite marque (couleur et paisseur d'un trait de construction) sur une graduation du rapporteur
 * @param {int} angle
 * @param {objet} options Dfaut : { tempo: this.tempo, vitesse: this.vitesse, couleur: this.couleurTraitsDeConstruction, epaisseur: this.epaisseurTraitsDeConstruction }
 */
  this.rapporteurCrayonMarqueAngle = function (angle, { tempo = this.tempo, vitesse = this.vitesse, couleur = this.couleurTraitsDeConstruction, epaisseur = this.epaisseurTraitsDeConstruction } = {}) {
    const O = this.rapporteur.position
    const M = pointAdistance(O, 5.2, angle + this.rapporteur.angle)
    const N = pointAdistance(O, 5.5, angle + this.rapporteur.angle)
    this.crayonMontrer()
    this.crayonDeplacer(M, { tempo: tempo, vitesse: vitesse })
    this.tracer(N, { tempo: tempo, vitesse: vitesse, couleur: couleur, epaisseur: epaisseur })
  }
  /**
 * Le crayon va faire une marque sur la graduation du rapporteur, le rapporteur va se cacher et on trace une demi-droite dont on peut choisir la "longueur" (par dfaut 90% de celle de la rgle)
 * @param {point} A Centre du rapporteur
 * @param {point} B Point avec lequel le 0 de droite sera align
 * @param {int} angle
 * @param {objet} options { longueur: 0.9 * this.regle.longueur, couleur: this.couleur, tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2, epaisseur: this.epaisseur, pointilles: this.pointilles }
 */
  this.rapporteurTracerDemiDroiteAngle = function (A, B, angle, { longueur = 0.9 * this.regle.longueur, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {
    if (angle > 0) {
      this.rapporteurDeplacerRotation2Points(A, B, { tempo: tempo, vitesse: vitesse, sens: sens })
      this.rapporteurCrayonMarqueAngle(angle, { tempo: tempo, vitesse: vitesse, sens: sens })
    } else {
      const B2 = rotation(B, A, 180)
      this.rapporteurDeplacerRotation2Points(A, B2, { tempo: tempo, vitesse: vitesse, sens: sens })
      this.rapporteurCrayonMarqueAngle(180 - Math.abs(angle), { tempo: tempo, vitesse: vitesse, sens: sens })
    }
    const d = droite(A, B)
    d.isVisible = false
    const M = pointAdistance(A, calcul(5.2 * this.rapporteur.zoom / 100, 1), d.angleAvecHorizontale + angle)
    this.rapporteurMasquer({ tempo: tempo })
    this.regleDemiDroiteOriginePoint(A, M, { longueur: longueur, couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })
  }

  /**
 **************************
 ********* REGLE **********
 **************************
 */

  /**
 * Masquer les graduations sur la rgle
 * @param {objet} options Dfaut : { tempo: this.tempo }
 */
  this.regleMasquerGraduations = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="vide" objet="regle" tempo="${tempo}"/>`)
  }
  /**
 * Montrer les graduations sur la rgle si elles avaient t masques
 * @param {objet} options Dfaut : { tempo: this.tempo }
 */
  this.regleMontrerGraduations = function ({ tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action mouvement="graduations" objet="regle" tempo="${tempo}"/>`)
  }
  /**
   * Modifie la taille de la rgle
   * @param {int} longueur
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.regleModifierLongueur = function (longueur = 20, { tempo = this.tempo } = {}) {
    this.regle.longueur = longueur
    this.liste_script.push(`&lt;action mouvement="modifier_longueur" objet="regle" longueur="${longueur}" tempo="${tempo}"/>`)
  }
  /**
 * Trace une demi-droite d'origine O passant par A (ou en direction de A si les points sont trop loigns)
 * @param {point} O Origine
 * @param {point} A Direction
 * @param {objet} options Dfaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}
 */
  this.regleDemiDroiteOriginePoint = function (O, A, options = {}) {
    if (!options.longueur) {
      options.longueur = this.regle.longueur
    }
    const M = pointSurSegment(O, A, options.longueur)
    this.regleSegment(O, M, options)
  }

  /**
   * Trace une droite passanrt par les points A et B
   * @param {point} A
   * @param {point} B
   * @param {objet} options Dfaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}
   */
  this.regleDroite = function (A, B, options = {}) {
    if (!options.longueur) {
      options.longueur = this.regle.longueur
    }
    const M = homothetie(B, A, calcul((-options.longueur * 0.5 + longueur(A, B) * 0.5) / longueur(A, B)))
    const N = homothetie(A, B, calcul((-options.longueur * 0.5 + longueur(A, B) * 0.5) / longueur(A, B)))
    if (this.x(A) &lt;= this.x(B)) {
      this.regleMontrer(M)
      this.regleRotation(N, options)
      this.regleSegment(M, N, options)
    } else {
      this.regleMontrer(N)
      this.regleRotation(M, options)
      this.regleSegment(N, M, options)
    }
  }
  /**
 * Avec la rgle, on prolonge le segment de l cm du cot de la 2e extrmit si l est positif sinon du ct de la premire extrmit
 * @param {point} A
 * @param {point} B
 * @param {objet} options Dfaut {longueur: 3, tempo: this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}
 */
  this.regleProlongerSegment = function (A, B, options = {}) {
    if (!options.longueur) {
      options.longueur = this.regle.longueur - 3
    }
    if (options.longueur > 0) {
      const B1 = pointSurSegment(B, A, 3)
      const B2 = pointSurSegment(B, A, -options.longueur)
      this.regleSegment(B1, B2, options)
    } else {
      const A1 = pointSurSegment(A, B, 3)
      const A2 = pointSurSegment(A, B, options.longueur)
      this.regleSegment(A1, A2, options)
    }
  }

  /**
 **************************
 ********* TRAITS *********
 **************************
 */

  /**
 * Le crayon trace un trait de sa position courante jusqu'au point B
 * @param {point} B
 * @param {objet} options Dfaut { tempo: this.tempo, vitesse: this.vitesse, epaisseur: this.epaisseur, couleur: this.couleur, pointilles: this.pointilles, vecteur: false }
 * @return {id} id utilise pour le trac
 */
  this.tracer = function (B, { tempo = this.tempo, vitesse = this.vitesse, epaisseur = this.epaisseur, couleur = this.couleur, pointilles = this.pointilles, vecteur = false } = {}) {
    const pointillesTexte = pointilles ? 'pointille="tiret"' : ''
    const vecteurTexte = vecteur ? 'style="vecteur"' : ''
    this.idIEP += 1
    const codeXML = `&lt;action abscisse="${this.x(B)}" ordonnee="${this.y(B)}" epaisseur="${epaisseur}" couleur="${couleur}" mouvement="tracer" objet="crayon" tempo="${tempo}" vitesse="${vitesse}"  ${pointillesTexte} ${vecteurTexte} id="${this.idIEP}" />`
    this.crayon.position = B
    this.liste_script.push(codeXML)
    return this.idIEP
  }
  /**
   * Trace au crayon le segment [AB]
   * @param {point} A Premire extrmit
   * @param {point} B Deuxime extrmit
   * @param {*} options
   * @return {id} id utilise pour le trac
   */
  this.trait = function (A, B, options = {}) {
    this.crayonDeplacer(A, options)
    return this.tracer(B, options)
  }
  /**
   * Trace au crayon le segment [AB] sans tempo et avec une vitesse multiplie par 1 000
   * @param {point} A Premire extrmit
   * @param {point} B Deuxime extrmit
   * @param {*} options
   * @return {id} id utilise pour le trac
   */
  this.traitRapide = function (A, B, options = {}) {
    options.tempo = 0
    options.vitesse = 10000
    this.crayonDeplacer(A, options)
    return this.tracer(B, options)
  }
  /**
 * Masque le trait d'id fourni
 * @param {int} id
 * @param {objet} options Dfaut : { tempo: 0, vitesse: 200 }
 */
  this.traitMasquer = function (id, { tempo = 0, vitesse = 200 } = {}) {
    this.liste_script.push(`&lt;action mouvement="masquer" objet="trait" id="${id}" vitesse="${vitesse}" />`)
  }
  /**
   *
   * @param {segment/point} Segment  tracer ou premire extrmit
   * @param {objet/point} options ou deuxime extrmit
   * @param {objet} options si les deux premiers arguments taient des points
   * @returns {id} identifiant utilis pour le trait
   */
  this.regleSegment = function (arg1, arg2, arg3) {
    let A, B, options, id
    if (arg1.typeObjet === 'segment') {
      A = arg1.extremite1
      B = arg1.extremite2
      options = arg2
    } else {
      A = arg1
      B = arg2
      options = arg3
    }
    if (A.x &lt;= B.x) { // Toujours avoir la rgle de gauche  droite
      this.regleMontrer(A, options)
      this.regleRotation(B, options)
    } else {
      this.regleMontrer(B, options)
      this.regleRotation(A, options)
    }
    if (longueur(this.crayon.position, A) &lt; longueur(this.crayon.position, B)) { // Le crayon ira au point le plus proche
      this.crayonMontrer(A, options)
      id = this.tracer(B, options)
    } else {
      this.crayonMontrer(B, options)
      id = this.tracer(A, options)
    }
    return id
  }
  /**
   * Trace un polygone avec les options par dfaut que l'on ne peut pas changer ici
   * @param  {...points} sommets du polygonne spars par des virgules
   */
  this.polygoneTracer = function (...sommets) {
    for (let i = 0; i &lt; sommets.length - 1; i++) {
      this.regleSegment(sommets[i], sommets[i + 1])
    }
    this.regleSegment(sommets[sommets.length - 1], sommets[0])
  }

  /**
   * Trace un polygone avec traitRapide()
   * @param  {...points} sommets du polygonne spars par des virgules
   */
  this.polygoneRapide = function (...sommets) {
    for (let i = 0; i &lt; sommets.length - 1; i++) {
      this.traitRapide(sommets[i], sommets[i + 1])
    }
    this.traitRapide(sommets[sommets.length - 1], sommets[0])
  }

  /**
 **************************
 ********* TEXTE **********
 **************************
 */

  /**
   * Ecris un texte coll au point. On peut choisir un fond, un cadre, l'opacit du fond, la police...
   * @param {string} texte
   * @param {point} A
   * @param {objet} options Dfaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }
   * @return {id}
   */
  this.textePoint = function (texte, A, { tempo = this.tempo, police = false, couleur = this.couleurTexte, taille, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas } = {}) {
    this.idIEP++
    const policeTexte = police ? `police="${police}"` : ''
    let options = ''
    if (typeof couleurFond !== 'undefined') {
      options += ` couleur_fond="${couleurFond}"`
    }
    if (typeof opaciteFond !== 'undefined') {
      options += ` opacite_fond="${opaciteFond}"`
    }
    if (typeof couleurCadre !== 'undefined') {
      options += ` couleur_cadre="${couleurCadre}"`
    }
    if (typeof epaisseurCadre !== 'undefined') {
      options += ` epaisseur_cadre="${epaisseurCadre}"`
    }
    if (typeof marge !== 'undefined') {
      options += ` marge="${marge}"`
    }
    if (typeof margeGauche !== 'undefined') {
      options += ` marge_gauche="${margeGauche}"`
    }
    if (typeof margeDroite !== 'undefined') {
      options += ` marge_droite="${margeDroite}"`
    }
    if (typeof margeBas !== 'undefined') {
      options += ` marge_bas="${margeBas}"`
    }
    if (typeof margeHaut !== 'undefined') {
      options += ` marge_haut="${margeHaut}"`
    }
    if (typeof taille !== 'undefined') {
      options += ` taille="${taille}"`
    }
    let codeXML = `&lt;action abscisse="${this.x(A)}" ordonnee="${this.y(A)}" id="${this.idIEP}" mouvement="creer" objet="texte" />`
    codeXML += `\n&lt;action ${policeTexte} couleur="${couleur}" texte="${texte}" id="${this.idIEP}" mouvement="ecrire" objet="texte" ${options} tempo="${tempo}" />`
    this.liste_script.push(codeXML)
    return this.idIEP
  }
  /**
   * Ecris un texte coll au point de coordonnes (x,y). On peut choisir un fond, un cadre, l'opacit du fond, la police...
   * @param {string} texte
   * @param {int} x Abscisse du coin en haut  gauche
   * @param {int} y Ordonne du coin en haut  gauche
   * @param {objet} options Dfaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }
   */
  this.textePosition = function (texte, x, y, options) {
    const A = point(x, y)
    return this.textePoint(texte, A, options)
  }

  this.longueurSegment = function (A, B, dy, options) {
    const l = calcul(longueur(A, B, 1))
    const v = vecteur(A, B)
    const w = vecteur(-v.y * dy / norme(v), v.x * dy / norme(v))
    const ancrage = translation(translation(pointSurSegment(A, B, l / 2 - 0.7), w), vecteur(0, 1))
    return this.textePoint(`${l} cm`, ancrage, options)
  }

  this.mesureAngle = function (A, O, B) {
    const a = angleOriente(A, O, B)
    const C = translation(homothetie(rotation(A, O, a / 2), O, 1.3 / longueur(O, A)), vecteur(-0.2, 0.5))
    return this.textePoint(Math.abs(a) + '', C)
  }
  /**
 * Masque le trait d'id fourni
 * @param {int} id
 * @param {objet} options Dfaut : { tempo: 0 }
 */
  this.texteMasquer = function (id, { tempo = 0 } = {}) {
    this.liste_script.push(`&lt;action mouvement="masquer" objet="texte" id="${id}"  />`)
  }

  /**
   * Met l'animation en pause forant l'utilisateur  appuyer sur lecture pour voir la suite
   */
  this.pause = function () {
    this.liste_script.push('&lt;action mouvement="pause" />')
  }

  /**
 **************************
 ******* CODAGES **********
 **************************
 */

  /**
   *
   * @param {segment/point} Segment  coder ou premire extrmit
   * @param {objet/point} options ou deuxime extrmit
   * @param {objet} options si les deux premiers arguments taient des points. Dfaut : { tempo: this.tempo, couleur: this.couleurCodage, codage: '//', }
   * @return {id}
  */
  this.segmentCodage = function (arg1, arg2 = {}, arg3 = {}) {
    let s
    let options = {}
    if (arg1.typeObjet === 'segment') {
      s = arg1
      options = arg2
    } else {
      s = segment(arg1, arg2)
      options = { ...arg3 }
    }
    if (options.tempo === undefined) {
      options.tempo = this.tempo
    }
    if (options.couleur === undefined) {
      options.couleur = this.couleurCodage
    }
    if (options.codage === undefined) {
      options.codage = '\\'
    }
    this.idIEP++
    const id = this.idIEP
    const M = milieu(s.extremite1, s.extremite2)
    const codeXML = `&lt;action abscisse="${this.x(M)}" ordonnee="${this.y(M)}" forme="${options.codage}"  couleur="${options.couleur}" id="${id}" tempo="${options.tempo}" mouvement="creer" objet="longueur" />`
    this.liste_script.push(codeXML)
    return id
  }
  /**
   *
   * @param {int} id Identifiant du codage
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.segmentCodageMasquer = function (id, { tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action id="${id}" mouvement="masquer" objet="longueur" tempo="${tempo}" />`)
  }
  /**
   *
   * @param {int} id Identifiant du codage
   * @param {objet} options Dfaut : { tempo: this.tempo }
   */
  this.segmentCodageMontrer = function (id, { tempo = this.tempo } = {}) {
    this.liste_script.push(`&lt;action id="${id}" mouvement="montrer" objet="longueur" tempo="${tempo}" />`)
  }
  /**
   * Trace le petit carr au crayon
   * @param {point} A Point sur un ct de l'angle
   * @param {point} B Sommet de l'angle
   * @param {point} C Point sur un ct de l'angle
   * @param {objet} options Dfaut : {longueur : 0.3, couleur: this.couleurCodage}
   * @return {array} [idTrait1, idTrait2]
   */
  this.codageAngleDroit = function (A, B, C, options = {}) {
    this.crayonMontrer()
    if (options.longueur === undefined) {
      options.longueur = 0.3
    }
    if (options.couleur === undefined) {
      options.couleur = this.couleurCodage
    }
    const C1 = pointSurSegment(B, C, options.longueur)
    const A1 = pointSurSegment(B, A, options.longueur)
    const M = translation2Points(A1, B, C1)
    const options1 = { ...options } // On recopie options pour ouvoir en changer le tempo du premier trac
    options1.tempo = 0
    const trait1 = this.trait(C1, M, options1)
    const trait2 = this.trait(M, A1, options)
    return [trait1, trait2]
  }
  /**
   * Masque le codage d'un angle droit
   * @param {int} id Identifiant du codage d'un angle droit
   * @param {objet} options Dfaut { tempo: 0 }
   */
  this.codageAngleDroitMasquer = function (id, { tempo = 0 } = {}) {
    this.traitMasquer(id[0], { tempo: tempo })
    this.traitMasquer(id[1], { tempo: tempo })
  }

  /**
   * Code un angle. L'option codage peut tre "simple", "/", "//", "///", "O"
   * "double", "double/", "double//", "double///", "doubleO"
   * "triple", "triple/", "triple//", "triple///", "tripleO"
   * "plein", "plein/", "plein//", "plein///", "pleinO"
   * @param {point} A Point sur un ct de l'angle
   * @param {point} B Sommet de l'angle
   * @param {point} C Point sur un ct de l'angle
   * @param {objet} options Dfaut : { rayon : 1, couleur: this.couleurCodage, codage: 'plein'}
   * @return {id} L'identifiant correspond  l'identifiant des 3 points de l'angle spars par _
   */
  this.angleCodage = function (B, A, C, { couleur = this.couleurCodage, codage = 'plein', rayon = 1, tempo = this.tempo } = {}) {
    const id = B.id + '_' + A.id + '_' + C.id
    const d1 = droite(A, B)
    const d2 = droite(A, C)
    d1.isVisible = false
    d2.isVisible = false
    const angle1 = -d1.angleAvecHorizontale
    const angle2 = -d2.angleAvecHorizontale
    const codeXML = `&lt;action abscisse="${this.x(A)}" ordonnee="${this.y(A)}" rayon="${rayon * 30}" angle1="${angle1}" angle2="${angle2}" forme="${codage}"  couleur="${couleur}" id="${id}" tempo="${tempo}" mouvement="creer" objet="angle" />`
    this.liste_script.push(codeXML)
    return id
  }

  /**
   * Masque un codage pralablement cr
   * @param {point} A
   * @param {point} B
   * @param {point} C
   * @param {objet} options Dfaut { tempo: 0 }
   */
  this.angleCodageMasquer = function (B, A, C, { tempo = 0 } = {}) {
    const id = B.id + '_' + A.id + '_' + C.id
    this.liste_script.push(`&lt;action id="${id}" mouvement="masquer" objet="angle" tempo="${tempo}" />`)
  }
  /**
   * Montre un codage pralablement cr
   * @param {point} A
   * @param {point} B
   * @param {point} C
   * @param {objet} options Dfaut { tempo: 0 }
   */
  this.angleCodageMontrer = function (B, A, C, { tempo = 0 } = {}) {
    const id = B.id + '_' + A.id + '_' + C.id
    this.liste_script.push(`&lt;action id="${id}" mouvement="montrer" objet="angle" tempo="${tempo}" />`)
  }

  /**
   * Affiche une image (donne par son URL) au point A
   * @param {string} url
   * @returns {id}
   */
  this.image = function (url, A = point(0, 0)) {
    this.idIEP++
    let codeXML
    codeXML = `&lt;action id="${this.idIEP}" url="${url}" mouvement="chargement" objet="image" />`
    codeXML += `\n&lt;action abscisse="${this.x(A)}" ordonnee="${this.y(A)}" id="${this.idIEP}" mouvement="translation" objet="image" vitesse="100000" />`
    this.liste_script.push(codeXML)
    return this.idIEP
  }

  /**
 *****************************************
 ********* MACROS-CONSTRUCTIONS **********
 *****************************************
 */

  /**
   * Trace la parallle  (AB) passant par C avec la rgle et l'querre. Peut prolonger le segment [AB] si le pied de la hauteur est trop loign des extrmits du segment
   * @param {point} A
   * @param {point} B
   * @param {point} C
   * @param {*} options
   */
  this.paralleleRegleEquerre2points3epoint = function (A, B, C, options) {
    let G, D, H1
    // G est le point le plus  gauche, D le plus  droite et H le projet de C sur (AB)
    // H1 est un point de (AB)  gauche de H, c'est l o seront la rgle et l'querre avant de glisser
    if (A.x &lt; B.x) {
      G = A
      D = B
    } else {
      G = B
      D = A
    }
    const d = droite(A, B)
    const H = projectionOrtho(C, d)
    if (H.x &lt; D.x) {
      H1 = pointSurSegment(H, D, -2) // H1 sera plus  gauche que H
    } else if (H.x > D.x) {
      H1 = pointSurSegment(H, D, 2)
    } else {
      H1 = pointSurSegment(H, G, 2)
    }
    const C1 = projectionOrtho(H1, droiteParPointEtParallele(C, d))
    // C1 est le point d'arrive de l'querre aprs avoir gliss
    const M = pointSurSegment(C1, C, 6)
    // Le trac de la parallle ne fera que 6 cm pour ne pas dpassr de l'querre. M est la fin de ce trac

    if (H.x &lt; G.x &amp;&amp; longueur(H, G) > 3) { // Si le pied de la hauteur est trop  gauche
      this.regleProlongerSegment(D, G)
      this.regleMasquer()
    }
    if (H.x > D.x &amp;&amp; longueur(H, D) > 3) { // Si le pied de la hauteur est trop  gauche
      this.regleProlongerSegment(G, D)
    }

    this.equerreMontrer(H1)
    if (M.x > C1.x) {
      this.equerreRotation(d.angleAvecHorizontale - 90)
    } else {
      this.equerreRotation(d.angleAvecHorizontale + 90)
    }
    if (H1.y > C1.y) {
      if (this.regle.visibilite) {
        this.regleDeplacer(H1, { vitesse: this.vitesse, tempo: 0 })
        this.regleRotation(C1, { sens: this.vitesse / 2, tempo: 0 })
      } else {
        this.regleDeplacer(H1, { vitesse: 1000, tempo: 0 })
        this.regleRotation(C1, { sens: 1000, tempo: 0 })
      }
    } else {
      const C12 = pointSurSegment(C1, H1, -2) // On monte un peu plus la rgle pour que a soit plus crdible
      if (this.regle.visibilite) {
        this.regleDeplacer(C12, { vitesse: this.vitesse, tempo: 0 })
        this.regleRotation(H1, { sens: this.vitesse / 2, tempo: 0 })
      } else {
        this.regleDeplacer(C12, { vitesse: 1000, tempo: 0 })
        this.regleRotation(H1, { sens: 1000, tempo: 0 })
      }
    }
    this.regleMontrer()
    this.equerreDeplacer(C1, options)
    this.crayonMontrer()
    this.crayonDeplacer(C1, options)
    this.tracer(M, options)
  }
  /**
     * Trace la perpendiculaire  (AB) passant par C avec la rgle et l'querre. Peut prolonger le segment [AB] si le pied de la hauteur est trop loign des extrmits du segment
     * @param {point} A
     * @param {point} B
     * @param {point} C
     * @param {*} options
     */
  this.perpendiculaireRegleEquerre2points3epoint = function (A, B, C, options) {
    const longueurRegle = this.regle.longueur
    const zoomEquerre = this.equerre.zoom
    const d = droite(A, B)
    let dist
    if (appartientDroite(C, A, B)) {
      dist = 7.5
    } else {
      const H = projectionOrtho(C, d)
      dist = longueur(H, C) + 2
    }
    this.equerreZoom(calcul(dist * 100 / 7.5))
    this.regleModifierLongueur(Math.max(dist * 2, 15))

    this.perpendiculaireRegleEquerreDroitePoint(d, C)
    this.equerreZoom(zoomEquerre)
    this.regleModifierLongueur(longueurRegle)
  }

  this.perpendiculaireRegleEquerreDroitePoint = function (d, P) {
    const H = projectionOrtho(P, d)
    const A = rotation(P, H, 90)
    const B = rotation(A, H, 180)
    const alpha = angleOriente(point(10000, H.y), H, B)
    this.equerreRotation(alpha)
    this.equerreMontrer(H)
    this.regleSegment(H, P)
    this.equerreMasquer()
    this.codageAngleDroit(A, H, P)
    this.regleProlongerSegment(P, H, { longueur: longueur(P, H) * 2 })
  }

  /**
 *****************************************
 ********* DROITES REMARQUABLES **********
 *****************************************
 */

  /**
 * Trace la mdiatrice de [AB] au compas. Le paramtrage des longueurs correspond  la distance entre le milieu du segment et le point d'intersection des arcs de cercles
 *
 * @param {point} A
 * @param {point} B
 * @param {objet} options Dfaut : {longueur1: 3, longueur2: 3, codage: 'X', couleurCodage : this.couleurCodage, couleurCompas: this.couleurCompas}
 * @return {array} [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]
  */
  this.mediatriceAuCompas = function (A, B, options = {}) {
    if (options.longueur1 === undefined) {
      options.longueur1 = 3
    }
    if (options.longueur2 === undefined) {
      options.longueur2 = -3
    }
    if (options.codage === undefined) {
      options.codage = 'X'
    }
    if (options.couleurCodage === undefined) {
      options.couleurCodage = this.couleurCodage
    }
    if (options.couleurCompas === undefined) {
      options.couleurCompas = this.couleurCompas
    }
    const O = milieu(A, B)
    const O2 = rotation(A, O, -90)
    const M = pointSurSegment(O, O2, options.longueur1)
    const N = pointSurSegment(O, O2, options.longueur2)
    this.compasMontrer()
    this.compasDeplacer(A, options)
    let arc1, arc2, arc3, arc4
    if (options.longueur1 === -1 * options.longueur2) { // Si la distance est la mme des deux cts, on peut faire les arcs de part et d'autre
      this.compasEcarter(longueur(A, M), { vitesse: options.vitesse, sens: options.vitesse })
      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc2 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc3 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc4 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
    } else {
      this.compasEcarter(longueur(A, M), options)
      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc2 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc3 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
      arc4 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })
    }
    this.compasMasquer()
    if (M.x &lt;= N.x) {
      this.regleDroite(M, N, options)
    } else {
      this.regleDroite(N, M, options)
    }
    this.regleMasquer()
    const codage1 = this.segmentCodage(A, O, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })
    const codage2 = this.segmentCodage(O, B, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })
    const codageCarre = this.codageAngleDroit(A, O, O2, { couleur: options.couleurCodage, tempo: options.tempo, vitesse: options.vitesse })
    return [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]
  }
  /**
   * Trace la mdiatrice du segment [AB] avec la mthode Rgle + querre.
   * @param {point} A
   * @param {point} B
   * @param {boolen} codage
   */
  this.mediatriceRegleEquerre = function (A, B, codage = 'X') {
    const O = milieu(A, B)
    this.regleMontrer()
    this.regleDeplacer(A)
    this.regleRotation(B)
    this.crayonMontrer()
    const O2 = rotation(A, O, -90)
    const O3 = rotation(A, O, 90)
    const M = pointSurSegment(O, O2, 0.2)
    const N = pointSurSegment(O, O3, 0.2)
    if (this.y(M) > this.y(N)) {
      this.trait(O, M)
    } else {
      this.trait(O, N)
    }
    this.regleMasquer()
    if (this.x(A) &lt; this.x(B)) {
      this.equerreDeplacer(A)
      this.equerreMontrer()
      this.equerreRotation(B)
    } else {
      this.equerreDeplacer(B)
      this.equerreMontrer()
      this.equerreRotation(A)
    }
    this.equerreDeplacer(O)
    this.crayonDeplacer(O)
    this.trait(O, O2)
    this.equerreMasquer()
    this.regleDroite(O2, O3)
    this.regleMasquer()
    this.segmentCodage(A, O, codage)
    this.segmentCodage(O, B, codage)
    this.codageAngleDroit(A, O, O2)
  }
  /**
   * Trace la hauteur issue de C dans un triangle ABC. Prolonge si besoin le segment [AB] pour avoir le pied de la hauteur et le codage de l'angle droit.
   * @param {point} A 1er point de la base
   * @param {point} B 2e point de la base
   * @param {point} C Sommet dont est issue la hauteur
   * @param {boolen} codage angle droit ajout si true
   */
  this.hauteur = function (A, B, C, codage = true) {
    const d = droite(A, B)
    d.isVisible = false
    const H = projectionOrtho(C, d)
    let G, D
    if (this.x(A) &lt; this.x(B)) {
      G = A
      D = B
    } else {
      G = B
      D = A
    }
    if (this.x(H) &lt; this.x(G)) { // si le pied de la hauteur est trop  gauche
      this.regleProlongerSegment(D, G, longueur(G, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)
    }
    if (this.x(H) > this.x(D)) { // si le pied de la hauteur est trop  droite
      this.regleProlongerSegment(G, D, longueur(D, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)
    }
    if (this.x(H) &lt; this.x(G) || this.x(H) > this.x(D)) {
      this.regleMasquer()
    }
    if (this.x(A) &lt; this.x(B)) {
      this.equerreDeplacer(A)
      this.equerreMontrer()
      this.equerreRotation(B)
    } else {
      this.equerreDeplacer(B)
      this.equerreMontrer()
      this.equerreRotation(A)
    }
    this.equerreDeplacer(H)
    this.crayonMontrer()
    this.crayonDeplacer(H)
    this.trait(H, C)
    this.equerreMasquer()
    if (codage) {
      this.codageAngleDroit(A, H, C)
    }
    this.crayonMasquer()
  }
  /**
 * Trace la mdiane issue de C passant par le milieu de [AB]
 * @param {point} A
 * @param {point} B
 * @param {point} C
 * @param {objet} options
 */
  this.mediane = function (A, B, C, options = {}) {
    if (options.codage === undefined) {
      options.codage = 'X'
    }
    if (options.couleurTraitsDeConstruction === undefined) {
      options.couleurTraitsDeConstruction = this.couleurTraitsDeConstruction
    }
    if (options.epaisseurTraitsDeConstruction === undefined) {
      options.epaisseurTraitsDeConstruction = this.epaisseurTraitsDeConstruction
    }
    const O = milieu(A, B)
    this.regleMontrer(A, options)
    this.regleRotation(B, options)
    this.crayonMontrer()
    const O2 = rotation(A, O, -90)
    const O3 = rotation(A, O, 90)
    const M = pointSurSegment(O, O2, 0.2)
    const N = pointSurSegment(O, O3, 0.2)
    if (M.y > N.y) {
      this.trait(O, M, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })
    } else {
      this.trait(O, N, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })
    }
    this.regleSegment(O, C, options)
    if (options.codage) {
      this.segmentCodage(A, O, options)
      this.segmentCodage(O, B, options)
    }
  }
  /**
 * Trace la bissectrice de l'angle ABC au compas.
 * @param {point} A
 * @param {point} B
 * @param {point} C
 * @param {objet} param3
 * @returns {objet} {arc1, arc2, arc3, arc4}
 */
  this.bissectriceAuCompas = function (A, B, C, { codage = '/', l = 2, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, pointilles = this.pointilles, couleurCodage = this.couleurCodage, masquerTraitsDeConstructions = true } = {}) {
    const A1 = pointSurSegment(B, A, l)
    const C1 = pointSurSegment(B, C, l)
    // const demiangle = calcul(angleOriente(A, B, C) / 2);
    const angle = angleOriente(A, B, C)
    const M = rotation(B, A1, -(180 - angle))
    const options = { couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, pointilles: false }
    const arc1 = this.compasTracerArcCentrePoint(B, A1, options)
    const arc2 = this.compasTracerArcCentrePoint(B, C1, options)
    const arc3 = this.compasTracerArcCentrePoint(A1, M, options)
    const arc4 = this.compasTracerArcCentrePoint(C1, M, options)
    this.compasMasquer()
    this.regleDemiDroiteOriginePoint(B, M, { longueur: longueur(B, A), couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })
    this.regleMasquer()
    this.crayonMasquer()
    if (codage) {
      this.angleCodage(A, B, M, { couleur: couleurCodage, codage: codage, tempo: tempo })
      this.angleCodage(M, B, C, { couleur: couleurCodage, codage: codage, tempo: tempo })
    }
    if (masquerTraitsDeConstructions) {
      this.traitMasquer(arc1)
      this.traitMasquer(arc2)
      this.traitMasquer(arc3)
      this.traitMasquer(arc4)
    }
    return { arc1: arc1, arc2: arc2, arc3: arc3, arc4: arc4 }
  }
  /**
 * Construit les 3 mdiatrices des cts du triangle ABC puis le cercle circonscrit au triangle
 * @param {point} A
 * @param {point} B
 * @param {point} C
 * @param {objet} options
 */
  this.cercleCirconscrit = function (A, B, C, options = {}) {
    if (options.couleur === undefined) {
      options.couleur = this.couleur
    }
    if (options.couleurMediatrice === undefined) {
      options.couleurMediatrice = options.couleur
    }
    if (options.couleurCercle === undefined) {
      options.couleurCercle = options.couleur
    }
    options.codage = 'X'
    options.couleur = options.couleurMediatrice
    const m1 = this.mediatriceAuCompas(A, B, options)
    this.traitMasquer(m1[0]) // On cache les arcs de cercle une fois la mdiatrice trace
    this.traitMasquer(m1[1])
    this.traitMasquer(m1[2])
    this.traitMasquer(m1[3])
    options.codage = '||'
    const m2 = this.mediatriceAuCompas(B, C, options)
    this.traitMasquer(m2[0])
    this.traitMasquer(m2[1])
    this.traitMasquer(m2[2])
    this.traitMasquer(m2[3])
    options.codage = '///'
    const m3 = this.mediatriceAuCompas(A, C, options)
    this.traitMasquer(m3[0])
    this.traitMasquer(m3[1])
    this.traitMasquer(m3[2])
    this.traitMasquer(m3[3])
    const O = centreCercleCirconscrit(A, B, C)
    options.couleur = options.couleurCercle
    this.compasCercleCentrePoint(O, A, options)
  }

  /**
 *****************************************
 ************** TRIANGLES ****************
 *****************************************
 */

  /**
   * Macro de construction d'un triangle  partir de ses 3 dimensions. Le premier point aura pour coordonnes (6,0).
   * @param {string} ABC Une chaine de caractre de 3 lettre
   * @param {*} AB Distance entre le 1er et le 2e sommet
   * @param {*} AC Distance entre le 1er et le 3e sommet
   * @param {*} BC Distance entre le 2e et le 3e sommet
   * @param {boolean} description Affichage d'un texte descriptif des tapes de la construction
   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)
   */
  this.triangle3longueurs = function (ABC, AB, AC, BC, description = true) {
    const A = point(6, 0)
    const B = pointAdistance(A, AB, randint(-20, 20))
    const p = triangle2points2longueurs(A, B, AC, BC)
    const C = p.listePoints[2]
    if (ABC.length !== 3) {
      description = false
    } else {
      A.nom = ABC[0]
      B.nom = ABC[1]
      C.nom = ABC[2]
    }

    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)
    this.pointCreer(A)
    // this.regleRotation(droite(A,B).angleAvecHorizontale)
    // this.regleMontrer(A)
    this.regleSegment(A, B)
    this.pointCreer(B)
    this.crayonMasquer()
    if (description) this.textePosition(`${A.nom + C.nom} = ${nombreAvecEspace(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${nombreAvecEspace(AC)} cm.`, 0, -3)
    this.couleur = 'forestgreen'
    this.epaisseur = 2
    this.compasMontrer(A)
    this.compasEcarterAvecRegle(AC)
    this.compasTracerArcCentrePoint(A, C, 40)
    if (description) this.textePosition(`${B.nom + C.nom} = ${nombreAvecEspace(BC)} cm donc ${C.nom} appartient au cercle de centre ${B.nom} et de rayon ${nombreAvecEspace(BC)} cm.`, 0, -4)
    this.compasDeplacer(B)
    this.compasEcarterAvecRegle(BC)
    this.compasTracerArcCentrePoint(B, C)
    this.compasMasquer()
    this.couleur = 'blue'
    this.epaisseur = 3
    if (description) this.textePosition(`Le point ${C.nom} est  une intersection des deux cercles.`, 0, -5)
    this.pointCreer(C)
    this.regleSegment(B, C)
    this.regleSegment(C, A)
    this.crayonMasquer()
    this.regleMasquer()
    return [A, B, C]
  }
  /**
   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)
   *   partir de la donne de la longueur d'un ct et de la longueur de l'hypotnuse.
   *  Le premier sommet aura pour coordonnes (6, 0)
   * @param {string} ABC Une chaine de caractre de 3 lettre
   * @param {*} AB Distance entre le 1er et le 2e sommet
   * @param {*} AC Distance entre le 1er et le 3e sommet (hypotnuse)
   * @param {boolean} description Affichage d'un texte descriptif des tapes de la construction
   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)
   */
  this.triangleRectangleCoteHypotenuse = function (ABC, AB, AC, description = true) { // Triangle rectangle en B
    const A = point(6, 0)
    const B = pointAdistance(A, AB, randint(-20, 20))
    const dAB = droite(A, B)
    dAB.isVisible = false
    const dBC = droiteParPointEtPerpendiculaire(B, dAB)
    dBC.isVisible = false
    const cAC = cercle(A, AC)
    cAC.isVisible = false
    const C = pointIntersectionLC(dBC, cAC)
    const c = homothetie(C, B, 1.2)
    if (ABC.length !== 3) {
      description = false
    } else {
      A.nom = ABC[0]
      B.nom = ABC[1]
      C.nom = ABC[2]
    }

    if (longueur(A, C) > 8) this.equerreZoom(150)
    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)
    this.equerreRotation(dAB.angleAvecHorizontale)
    this.pointCreer(A)
    this.regleSegment(A, B)
    this.pointCreer(B)
    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient  la perpendiculaire  (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)
    this.equerreMontrer(A)
    this.equerreDeplacer(B)
    this.tracer(c)
    this.equerreMasquer()
    this.codageAngleDroit(A, B, C)
    this.crayonMasquer()
    if (description) this.textePosition(`${A.nom + C.nom} = ${nombreAvecEspace(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${nombreAvecEspace(AC)} cm.`, 0, -4)
    this.compasMontrer(A)
    this.compasEcarterAvecRegle(AC)
    this.couleur = 'forestgreen'
    this.epaisseur = 2
    this.compasTracerArcCentrePoint(A, C)
    this.couleur = 'blue'
    this.epaisseur = 2
    if (description) this.textePosition(`${C.nom} est  une intersection de la perpendiculaire et du cercle.`, 0, -5)
    this.crayonMontrer(C)
    this.pointCreer(C)
    this.compasMasquer()
    this.regleSegment(A, C)
    this.regleMasquer()
    this.crayonMasquer()
    return [A, B, C]
  }

  /**
   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)
   *   partir de la donne de la longueur des deux cts de l'angle droit.
   *  Le premier sommet aura pour coordonnes (6, 0)
   * @param {string} ABC Une chaine de caractre de 3 lettre
   * @param {*} AB Distance entre le 1er et le 2e sommet
   * @param {*} AC Distance entre le 1er et le 3e sommet (hypotnuse)
   * @param {boolean} description Affichage d'un texte descriptif des tapes de la construction
   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)
   */
  this.triangleRectangle2Cotes = function (ABC, AB, BC, description = true) { // Triangle rectangle en B
    const A = point(6, 0)
    const B = pointAdistance(A, AB, randint(-20, 20))
    const dAB = droite(A, B)
    dAB.isVisible = false
    const dBC = droiteParPointEtPerpendiculaire(B, dAB)
    dBC.isVisible = false
    const cBC = cercle(B, BC)
    cBC.isVisible = false
    const C = pointIntersectionLC(dBC, cBC)
    const c = homothetie(C, B, 1.2)
    if (ABC.length !== 3) {
      description = false
    } else {
      A.nom = ABC[0]
      B.nom = ABC[1]
      C.nom = ABC[2]
    }

    if (longueur(A, C) > 8) this.equerreZoom(150)
    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)
    this.equerreRotation(dAB.angleAvecHorizontale)
    this.pointCreer(A)
    this.regleSegment(A, B)
    this.pointCreer(B)
    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient  la perpendiculaire  (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)
    this.equerreMontrer(A)
    this.equerreDeplacer(B)
    this.tracer(c)
    this.equerreMasquer()
    this.codageAngleDroit(A, B, C)
    if (description) this.textePosition(`${B.nom + C.nom} = ${nombreAvecEspace(BC)} cm donc ${C.nom} est  ${nombreAvecEspace(BC)} cm de ${B.nom} sur la perpendiculaire  (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -4)
    this.regleMontrer(B)
    this.regleRotation(C)
    this.crayonDeplacer(C)
    this.pointCreer(C)
    this.couleur = 'blue'
    this.epaisseur = 2
    this.compasMasquer()
    this.regleSegment(A, C)
    this.regleMasquer()
    this.crayonMasquer()

    return [A, B, C]
  }
  /**
   * Macro de construction d'un triangle  partir d'une longueur et des 2 angles adajcents au ct connu. Le premier point aura pour coordonnes (6,0).
   * @param {string} ABC Une chaine de caractre de 3 lettre
   * @param {*} AB Distance entre le 1er et le 2e sommet
   * @param {*} BAC Angle au 1er sommet
   * @param {*} CBA Angle au 2e sommet
   * @param {boolean} description Affichage d'un texte descriptif des tapes de la construction
   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)
   */
  this.triangle1longueur2angles = function (NOM, AB, BAC, CBA, description = true, mesure = false) {
    const angle = randint(-20, 20)
    const a1 = BAC
    const a2 = CBA
    const A = point(6, 0)
    const B = pointAdistance(A, AB, angle)
    const D = pointAdistance(A, 5.2, a1 + angle)
    const D2 = pointSurSegment(A, D, 10)
    const D1 = pointSurSegment(D, D2, 0.4)
    const E = pointAdistance(B, 3, 180 - a2 + angle)
    const E2 = pointSurSegment(B, E, 10)
    const E1 = pointSurSegment(E, E2, -0.4)
    const F = pointAdistance(B, 5.2, 180 - a2 + angle)
    const F1 = pointSurSegment(F, E2, 0.4)
    const d = rotation(droite(A, B), A, a1)
    D.isVisible = false
    const d2 = rotation(droite(B, A), B, -a2)
    d2.isVisible = false
    const C = pointIntersectionDD(d, d2)
    if (NOM.length !== 3) {
      description = false
    } else {
      A.nom = NOM[0]
      B.nom = NOM[1]
      C.nom = NOM[2]
    }
    this.couleur = 'blue'
    this.epaisseur = 3
    this.pointCreer(A)
    if (description) this.textePosition(`On trace le ct [${A.nom + B.nom}] de ${nombreAvecEspace(AB)} cm.`, 0, -4)
    this.regleSegment(A, B)
    this.pointCreer(B)
    this.couleur = 'grey'
    this.epaisseur = 1
    this.rapporteurMontrer(A)
    this.rapporteurDeplacer(A)
    this.rapporteurRotation(angle)
    if (description) this.textePosition(`On place un repre  ${a1} degrs pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)
    this.epaisseur = 3
    this.trait(D, D1, 20)
    this.epaisseur = 1
    this.rapporteurMasquer()
    this.regleSegment(A, D2)
    this.regleMasquer()
    this.angleCodage(B, A, C)
    this.rapporteurMontrer(A)
    this.rapporteurDeplacer(B)
    if (description) this.textePosition(`On place un repre  ${a2} degrs pour tracer la demi-droite [${B.nom + C.nom}).`, 0, -6)
    this.epaisseur = 3
    this.trait(E, E1, 10)
    this.trait(F, F1, 20)
    this.epaisseur = 1
    this.rapporteurMasquer()
    this.regleMontrer(B)
    this.regleSegment(B, E2)
    this.angleCodage(C, B, A)
    this.pointCreer(C, '', 0)
    this.pointNommer(C, C.nom, -0.5, 1)
    this.couleur = 'blue'
    this.epaisseur = 3
    this.regleSegment(B, C)
    this.regleSegment(C, A)
    this.regleMasquer()
    this.crayonMasquer()
    if (description &amp;&amp; mesure) this.textePosition(`On peut mesurer ${A.nom + C.nom}  ${nombreAvecEspace(longueur(A, C, 1))} cm et ${B.nom + C.nom}  ${nombreAvecEspace(longueur(B, C, 1))} cm.`, 0, -7)

    return [A, B, C]
  }
  /**
   * Macro de construction d'un triangle  partir des longueurs des deux cts d'un angle Le premier point a pour coordonnes (6,0).
   * @param {string} ABC Une chaine de caractre de 3 lettre
   * @param {*} AB Distance entre le 1er et le 2e sommet
   * @param {*} AC Distance entre le 1er et le 3e sommet
   * @param {*} BAC Angle au 1er sommet
   * @param {boolean} description Affichage d'un texte descriptif des tapes de la construction
   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)
   */
  this.triangle2longueurs1angle = function (NOM, AB, AC, BAC, description = true, mesure = false) {
    const angle = randint(-20, 20)
    const a1 = BAC
    const A = point(6, 0)
    const B = pointAdistance(A, AB, angle)
    const D = pointAdistance(A, 5.2, a1 + angle)
    const D2 = pointSurSegment(A, D, 10)
    const D1 = pointSurSegment(D, D2, 0.4)
    const C = pointSurSegment(A, D2, AC)
    if (NOM.length !== 3) {
      description = false
    } else {
      A.nom = NOM[0]
      B.nom = NOM[1]
      C.nom = NOM[2]
    }
    this.couleur = 'blue'
    this.epaisseur = 3
    this.pointCreer(A)
    if (description) this.textePosition(`On trace le ct [${A.nom + B.nom}] de ${nombreAvecEspace(AB)} cm.`, 0, -4)
    this.regleSegment(A, B)
    this.pointCreer(B)
    this.couleur = 'grey'
    this.epaisseur = 1
    this.rapporteurMontrer(A)
    this.rapporteurDeplacer(A)
    this.rapporteurRotation(angle)
    if (description) this.textePosition(`On place un repre  ${a1} degrs pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)
    this.epaisseur = 3
    this.trait(D, D1, 20)
    this.epaisseur = 1
    this.rapporteurMasquer()
    this.regleSegment(A, D2)
    this.angleCodage(B, A, C)
    this.rapporteurMasquer()
    if (description) this.textePosition(`On place le point ${C.nom} sur la demi-droite [${A.nom + C.nom})  ${AC} cm de ${A.nom}.`, 0, -6)
    this.epaisseur = 3
    this.couleur = 'blue'
    this.crayonDeplacer(C)
    this.pointCreer(C)
    this.regleSegment(A, C)
    this.crayonMasquer()
    if (description) this.textePosition(`On trace le ct [${B.nom + C.nom}].`, 0, -7)
    this.regleMontrer(C)
    this.crayonMontrer(C)
    this.regleSegment(C, B)
    this.regleMasquer()
    this.crayonMasquer()
    return [A, B, C]
  }

  /**
   * Trace un triangle quilatral  partir de la donne de 2 points
   * @param {point} A
   * @param {point} B
   * @param {string} nomC
   * @return {array} [A, B, C]
   */
  this.triangleEquilateral2Sommets = function (A, B, nomC = '') {
    const C = rotation(B, A, 60)
    C.nom = nomC
    this.traitRapide(A, B)
    this.pointCreer(A, A.nom, 0)
    this.pointCreer(B, B.nom, 0)
    this.compasEcarter2Points(A, B)
    this.compasTracerArcCentrePoint(A, C)
    this.compasTracerArcCentrePoint(B, C)
    this.pointCreer(C)
    this.compasMasquer()
    this.regleSegment(A, C)
    this.regleSegment(C, B)
    this.regleMasquer()
    this.crayonMasquer()
    this.segmentCodage(A, B)
    this.segmentCodage(A, C)
    this.segmentCodage(B, C)
    return [A, B, C]
  }
  /**
   * Trace un triangle quilatral  partir de la donne de la longueur du ct. Le premier point a pour coordonnes (6;0)
   * @param {string} NOM
   * @param {number} AB
   * @return {array} [A, B, C]
   */

  this.triangleEquilateral = function (NOM, AB) {
    const A = point(6, 0)
    const B = pointAdistance(A, AB, randint(-20, 20))
    const C = rotation(B, A, 60)
    if (NOM.length === 3) {
      A.nom = NOM[0]
      B.nom = NOM[1]
      C.nom = NOM[2]
    }
    this.regleSegment(A, B)
    this.pointCreer(A)
    this.pointCreer(B)
    this.compasEcarter2Points(A, B)
    this.compasTracerArcCentrePoint(A, C)
    this.compasTracerArcCentrePoint(B, C)
    this.pointCreer(C)
    this.compasMasquer()
    this.regleSegment(A, C)
    this.regleSegment(C, B)
    this.regleMasquer()
    this.crayonMasquer()
    this.segmentCodage(A, B)
    this.segmentCodage(A, C)
    this.segmentCodage(B, C)
    return [A, B, C]
  }

  /**
 ************************************************
 ************** PARALLELOGRAMMES ****************
 ************************************************
 */

  /**
   * Trace un paralllogramme  partir de la donne de 3 sommets conscutifs
   * @param {point} A
   * @param {point} B
   * @param {point} C
   * @param {string} nomD
   * @param {boolean} description
   * @param {boolean} csDejaTraces  true (par dfaut), les 2 cts seront faits immdiatement, sinon, on les tracera  la rgle.
   */
  this.parallelogramme3sommetsConsecutifs = function (A, B, C, nomD = '', description = true, csDejaTraces = true) {
    const D = translation2Points(C, B, A)
    D.nom = nomD
    const xMin = Math.min(A.x, B.x, C.x, D.x)
    const yMin = Math.min(A.y, B.y, C.y, D.y)
    // const xMax = Math.max(A.x, B.x, C.x, D.x)
    // const yMax = Math.max(A.y, B.y, C.y, D.y)
    this.traitRapide(A, B)
    this.traitRapide(B, C)
    this.pointCreer(A, A.nom, 0)
    this.pointCreer(B, B.nom, 0)
    this.pointCreer(C, C.nom, 0)
    this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un paralllogramme donc ses cts opposs sont de mme longueur.`, xMin - 1, yMin - 1)
    this.compasEcarter2Points(B, A)
    this.textePosition(`${B.nom + A.nom} = ${C.nom + D.nom}`, xMin - 1, yMin - 2)
    this.compasTracerArcCentrePoint(C, D)
    this.compasEcarter2Points(B, C)
    this.textePosition(`${B.nom + C.nom} = ${A.nom + D.nom}`, xMin - 1, yMin - 3)
    this.compasTracerArcCentrePoint(A, D, 10)
    this.pointCreer(D)
    this.compasMasquer()
    this.regleSegment(C, D)
    this.regleSegment(D, A)
    this.regleMasquer()
    this.crayonMasquer()
    this.segmentCodage(A, B, { codage: '///', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(D, C, { codage: '///', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(B, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(A, D, { codage: '//', couleur: this.couleurCodage, tempo: 0 })
  }
  /**
   * Trace le paralllogramme ABCD de centre O  partir de [AB] et O.
   * @param {point} A
   * @param {point} B
   * @param {point} O
   * @param {string} nomC
   * @param {string} nomD
   * @param {boolean} description
   */
  this.parallelogramme2sommetsConsecutifsCentre = function (A, B, O, nomC = '', nomD = '', description = true) {
    const C = translation2Points(O, A, O)
    C.nom = nomC
    const D = translation2Points(O, B, O)
    D.nom = nomD
    const nom = A.nom + B.nom + C.nom + D.nom
    if (longueur(A, C) > 12 || longueur(B, D) > 12) {
      this.regleModifierLongueur(30)
    }
    const xMin = Math.min(A.x, B.x, C.x, D.x)
    const yMin = Math.min(A.y, B.y, C.y, D.y)
    // const xMax = Math.max(A.x, B.x, C.x, D.x)
    // const yMax = Math.max(A.y, B.y, C.y, D.y)
    this.traitRapide(A, B)
    this.pointCreer(A, { tempo: 0 })
    this.pointCreer(B, { tempo: 0 })
    this.pointCreer(O, { tempo: 0 })
    if (description &amp;&amp; nom.length === 4) {
      this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un paralllogramme donc ses diagonales se coupent en leur milieu.`, xMin - 1, yMin - 1)
    }
    this.pointilles = true
    this.epaisseur = 1
    this.couleur = this.couleurTraitsDeConstruction
    this.regleDemiDroiteOriginePoint(A, O, { longueur: longueur(A, C) + 3 })
    this.regleMasquer()
    this.crayonMasquer()
    this.compasEcarter2Points(A, O)
    if (description &amp;&amp; nom.length === 4) {
      this.textePosition(`${A.nom + O.nom} = ${O.nom + C.nom}`, xMin - 1, yMin - 2)
    }
    this.pointilles = false
    this.compasTracerArcCentrePoint(O, C)
    this.compasMasquer()
    this.pointilles = true
    this.regleDemiDroiteOriginePoint(B, O, { longueur: longueur(B, D) + 3 })
    this.regleMasquer()
    this.crayonMasquer()
    this.pointilles = false
    this.compasEcarter2Points(B, O)
    if (description &amp;&amp; nom.length === 4) {
      this.textePosition(`${B.nom + O.nom} = ${O.nom + D.nom}`, xMin - 1, yMin - 3)
    }
    this.compasTracerArcCentrePoint(O, D)
    this.compasMasquer()
    this.couleur = 'blue'
    this.epaisseur = 3
    this.pointCreer(D)
    this.regleSegment(A, D)
    this.regleSegment(D, C)
    this.regleSegment(C, B)
    this.regleMasquer()
    this.compasMasquer()
    this.crayonMasquer()
    this.segmentCodage(A, O, { codage: '//', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(O, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(B, O, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })
    this.segmentCodage(O, D, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })
  }
  /**
   * Trace la paralllogramme ABCD de centre O en partant de [AD), [AB) et O (mais sans voir la position de B et D au dpart)
   * @param {point} D
   * @param {point} A
   * @param {point} B
   * @param {point} O
   */
  this.parallelogrammeAngleCentre = function (D, A, B, O) {
    const B1 = pointSurSegment(A, B, longueur(A, B) + 2)
    const D1 = pointSurSegment(A, D, longueur(A, D) + 2)
    const C = translation2Points(B, A, D)
    this.traitRapide(A, B1)
    this.traitRapide(A, D1)
    this.pointCreer(O, { tempo: 0 })
    this.pointCreer(A, { tempo: 0 })
    this.regleDemiDroiteOriginePoint(A, O, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1, pointilles: true })
    this.pointilles = false
    this.regleMasquer()
    this.crayonMasquer()
    this.compasEcarter2Points(A, O)
    this.compasTracerArcCentrePoint(O, C, { couleur: this.couleurTraitsDeConstruction })
    this.compasMasquer()
    this.paralleleRegleEquerre2points3epoint(B1, A, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })
    this.equerreMasquer()
    this.regleDroite(C, D, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })
    this.paralleleRegleEquerre2points3epoint(A, D1, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })
    this.equerreMasquer()
    this.regleDroite(C, B, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })
    this.pointCreer(D, { tempo: 0 })
    this.pointCreer(B, { tempo: 0 })
    this.pointCreer(C, { tempo: 0 })
    this.regleSegment(B, C)
    this.regleSegment(C, D)
    this.regleMasquer()
    this.crayonMasquer()
  }

  /**
   ************************************************
   ************** Carrs ****************
   ************************************************
   */

  /**
   * Macro cre par Sophie Desruelle
   * @param {objet} A
   * @param {number} c
   * @returns polygoneAvecNom
   */
  this.carre1point1longueur = function (nom, A, c) {
    const interligne = 1
    A = point(5, 0, nom[0])
    const B = pointAdistance(A, c, randint(-20, 20), nom[1])
    const C = rotation(A, B, -90, nom[2])
    const D = rotation(B, A, 90, nom[3])
    const E = pointSurSegment(A, D, c + 2, 'E')
    const F = pointSurSegment(D, C, c + 2, 'F')
    this.equerreZoom((c + 3) * 100 / 7.5)
    this.tempo = 20

    this.textePosition(`1) On veut construire un carr dont les cts mesurent ${c} cm, donc on commence par tracer un segment, ici [${nom[0] + nom[1]}], de cette longueur.`, 0, -2)

    this.pointCreer(A, { tempo: 0 }) // On coupe la pause pour ne pas voir le dplacement du point
    this.pointNommer(A, A.nom, { dx: -0.5, dy: 0 }) // On dplace le label du point A vers la gauche
    this.regleSegment(A, B)
    this.pointCreer(B)
    this.regleMasquer()
    this.longueurSegment(A, B, -1)

    this.textePosition(`2) Un carr possde 4 angles droits, donc on trace la perpendiculaire  (${nom[0] + nom[1]}) passant par ${nom[0]}.`, 0, -2 - 1 * interligne)

    this.equerreMontrer()
    this.equerreDeplacer(A)
    this.equerreRotation(B)
    this.trait(A, E)
    this.equerreMasquer()
    this.codageAngleDroit(B, A, D)

    this.textePosition(`3) Les 4 cts d'un carr sont de la mme longueur, donc on place le point ${nom[3]} sur cette perpendiculaire,  ${c} cm de ${nom[0]}.`, 0, -2 - 2 * interligne)

    this.regleSegment(A, D)
    this.pointCreer(D, { tempo: 0 })
    this.pointNommer(D, D.nom, { dx: -0.7, dy: 0.5 })
    this.regleMasquer()
    this.segmentCodage(A, B)
    this.segmentCodage(A, D)

    this.textePosition(`4) De mme, on trace la perpendiculaire  (${nom[0] + nom[3]}) passant par ${nom[3]}, puis on place le point ${nom[2]} sur cette perpendiculaire,  ${c} cm de ${nom[3]}.`, 0, -2 - 3 * interligne)

    this.equerreMontrer()
    this.equerreDeplacer(D)
    this.equerreRotation(A)
    this.trait(D, F)
    this.equerreMasquer()
    this.codageAngleDroit(A, D, C)

    this.regleSegment(D, C)
    this.pointCreer(C, { tempo: 0 })
    this.pointNommer(C, C.nom, { dx: 0, dy: 0.9 })
    this.regleMasquer()
    this.segmentCodage(D, C)

    this.textePosition(`5) On trace le segment [${nom[1] + nom[2]}].`, 0, -2 - 4 * interligne)

    this.regleSegment(C, B)
    this.regleMasquer()
    this.segmentCodage(B, C)

    this.textePosition(`6) On vrifie que ${nom[1] + nom[2]} = ${c} cm et que les deux derniers angles tracs sont droits.`, 0, -2 - 5 * interligne)

    this.equerreMontrer(C, { tempo: 0 })
    this.equerreRotation(D)
    this.equerreMasquer()
    this.codageAngleDroit(D, C, B)

    this.equerreMontrer(B, { tempo: 0 })
    this.equerreRotation(C)
    this.equerreMasquer()
    this.codageAngleDroit(C, B, A)
    return polygoneAvecNom(A, B, C, D)
  }

  /********************************************/
  /** *********** Transformations **************/
  /********************************************/

  /**
   *
   * @param {objet} p  le point dont on veut construire l'image
   * @param {objet} centre le centre de la rotation
   * @param {number} angle l'angle de la rotation
   * @param {string} nom le nom de l'image (si pas prcis ce sera le nom de l'antcdent avec un ')
   * @param {objet} param4 options couleur et couleurCodage
   * @author Jean-Claude Lhote
   */
  this.rotationPoint = function (p, centre, angle, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = true } = {}) {
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    if (nom === undefined || nom === '') {
      nom = p.nom + "'"
    }
    const image = rotation(p, centre, angle, nom) // on dfinit le point image (pour le viser avec la rgle on ajoute une apostrophe au nom)
    this.regleSegment(centre, p) // On trace le support du rapporteur
    this.rapporteurMontrer(centre)
    this.rapporteurTracerDemiDroiteAngle(centre, p, angle) // On trace le deuxime ct
    this.regleMasquer()
    this.rapporteurMasquer()
    this.compasEcarter2Points(centre, p) // on prend l'cartement du compas
    this.compasTracerArcCentrePoint(centre, image) // On fait l'arc qui coupe la demi-droite
    this.compasMasquer()
    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // On marque le point image (qui est nomm)
    if (codage) {
      if (Math.abs(angle) === 90) {
        this.codageAngleDroit(p, centre, image, { couleur: couleurCodage })
      } else {
        this.angleCodage(p, centre, image, { couleur: couleurCodage })
        this.textePoint(Math.abs(angle) + '', translation(homothetie(rotation(p, centre, angle / 2), centre, 1.3 / longueur(centre, p)), vecteur(-0.2, 0.5)))
      }
    }
  }

  /**
   *
   * @param {objet} p point dont on construit l'image et qui doit tre trac.
   * @param {objet} d axe de symtrie.
   * @param {string} nom nom de l'image
   * @param {objet} options couleur et couleurCodage
   * @author Liouba Leroux et Jean-Claude Lhote
   */
  this.symetrieAxialePoint = function (p, d, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = '//' } = {}) {
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    if (nom === undefined || nom === '') {
      nom = p.nom + "'"
    }
    const image = symetrieAxiale(p, d, nom) // on dfinit le point image (pour le viser avec la rgle on ajoute une apostrophe au nom)
    if (longueur(p, image) !== 0) {
      const M = milieu(p, image) // on cre le point milieu
      const N = rotation(p, M, 90)
      const D = rotation(N, M, 180)
      this.regleMasquerGraduations()
      this.perpendiculaireRegleEquerre2points3epoint(N, D, p)
      this.compasEcarter2Points(M, p)
      this.compasTracerArcCentrePoint(M, image)
      this.regleSegment(p, image)
      this.regleMasquer()
      this.equerreMasquer()
      this.segmentCodage(p, M, { codage: codage, couleur: couleurCodage })
      this.segmentCodage(image, M, { codage: codage, couleur: couleurCodage })
      this.crayonMasquer()
      this.compasMasquer()
    }
    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image
  }

  /**
   *
   * @param {objet} p  le point dont on veut construire l'image
   * @param {objet} le point de dpart de la translation
   * @param {objet} le point d'arrive de la translation
   * @param {string} nom le nom de l'image (si pas prcis ce sera le nom de l'antcdent avec un ')
   * @param {objet} param4 options couleur et couleurCodage
   * @author Jean-Claude Lhote
   */
  this.translationPoint = function (p, A, B, nom, { couleur = 'black', couleurCodage = this.couleurCodage } = {}) {
    const v = vecteur(A, B)
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    if (nom === undefined || nom === '') {
      nom = p.nom + "'"
    }
    const image = translation(p, v, nom) // on dfinit le point image (pour le viser avec la rgle on ajoute une apostrophe au nom)
    if (longueur(A, p) !== 0) { // si le point de dpart A est l'antcdent, alors le point d'arrive B est l'image... pas besoin de construction
      this.compasEcarter2Points(A, p)
      this.compasTracerArcCentrePoint(B, image)
      this.compasEcarter2Points(A, B)
      this.compasTracerArcCentrePoint(p, image)
    }
    this.compasMasquer()
    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur })
    const choix1 = randint(0, 4)
    const choix2 = randint(0, 4, choix1)
    const marques = ['/', '//', '///', 'O', '\\\\']
    const marque1 = marques[choix1]
    const marque2 = marques[choix2]
    this.couleur = 'green'
    this.traitRapide(p, image)
    this.traitRapide(A, B)
    this.segmentCodage(p, image, { codage: marque1, couleur: couleurCodage })
    this.segmentCodage(A, B, { codage: marque1, couleur: couleurCodage })
    this.couleur = 'red'
    this.traitRapide(B, image)
    this.traitRapide(A, p)
    this.segmentCodage(B, image, { codage: marque2, couleur: couleurCodage })
    this.segmentCodage(A, p, { codage: marque2, couleur: couleurCodage })
  }

  /**
   *
   * @param {objet} p  le point dont on veut construire l'image
   * @param {objet} centre le centre de symtrie
   * @param {string} nom le nom de l'image (si pas prcis ce sera le nom de l'antcdent avec un ')
   * @param {objet} param3 options couleur, couleurCodage et codage
   * @author Jean-Claude Lhote
   */
  this.demiTourPoint = function (p, centre, nom, { couleur = 'black', couleurCodage = this.couleurCodage, codage = '//' } = {}) {
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    if (nom === undefined || nom === '') {
      nom = p.nom + "'"
    }
    const image = rotation(p, centre, 180, nom) // on dfinit le point image (pour le viser avec la rgle on ajoute une apostrophe au nom)
    this.compasEcarter2Points(centre, p)
    this.compasTracerArcCentrePoint(centre, image)
    this.compasMasquer()
    this.crayonDeplacer(p)
    this.regleSegment(p, image)
    this.couleur = couleur
    this.epaisseur = 2
    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image
    this.regleMasquer()
    this.crayonMasquer()
    this.segmentCodage(p, centre, { codage: codage, couleur: couleurCodage })
    this.segmentCodage(centre, image, { codage: codage, couleur: couleurCodage })
  }

  /**
   *
   * @param {objet} p polygone dont on doit construire l'image
   * @param {objet} centre de l'homothtie
   * @param {number} k rapport de l'homothtie
   * @param {array} noms tableau contenant les diffrents noms des sommets dans le mme ordre que ceux de p. Si vide, alors on ajoute '  ceux de p
   * @param {objet} param4 options (couleur)
   */
  this.homothetiePoint = function (p, centre, k, nom, { couleur = this.couleur, positionTexte = { x: 0, y: 0 } } = {}) {
    this.epaisseur = 1 // paisseur et couleur de crayon de papier bien taill pour la construction
    const couleurSave = this.couleur
    this.couleur = 'grey'
    let t
    if (nom === undefined || nom === '') {
      nom = p.nom + "'"
    }
    const image = homothetie(p, centre, k, nom) // on dfinit le point image (pour le viser avec la rgle on ajoute une apostrophe au nom)
    if (k > 0) {
      t = this.textePosition(`Comme le rapport est positif alors les points ${p.nom} et ${image.nom} sont du mme ct de ${centre.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })
    } else {
      t = this.textePosition(`Comme le rapport est ngatif alors ${centre.nom} est entre les points ${p.nom} et ${image.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })
    }
    this.regleSegment(p, centre)
    const l = arrondi(longueur(p, centre), 1)
    const lprime = arrondi(calcul(l * Math.abs(k)))
    const t1 = this.textePosition(`La mesure de ${centre.nom}${p.nom} est ${texNombre(arrondi(l, 1))} cm et le rapport de l'homothetie est ${texNombre(k)}`, positionTexte.x, positionTexte.y - 1, { taille: 15 })
    const t2 = this.textePosition(`donc ${centre.nom}${image.nom} mesure ${texNombre(l)} cm  ${texNombre(Math.abs(k))} = ${texNombre(lprime)} cm`, positionTexte.x, positionTexte.y - 2, { taille: 15 })
    this.regleSegment(centre, image)
    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image
    this.regleMasquer()
    this.crayonMasquer()
    this.pause()
    this.texteMasquer(t1)
    this.texteMasquer(t2)
    this.texteMasquer(t)
    this.couleur = couleurSave
  }
  /**
   *
   * @param {objet} p le polygone qui est dj trac
   * @param {objet} centre le centre de la rotation
   * @param {number} angle l'angle de rotation
   * @author Jean-Claude Lhote
   * @param {objet} param4 options couleur et couleurCodage
  */
  this.rotationPolygone = function (p, centre, angle, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {
    let nom
    const p2 = rotation(p, centre, angle) // Pour tracer la figure image  la fin de l'animation avec polygoneRapide
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    let i = 0; let codage
    for (const sommet of p.listePoints) { // On rpte la construction pour chaque sommet du polygone
      if (noms[i] !== undefined) {
        nom = noms[i]
      } else {
        nom = sommet.nom + "'"
      }
      if (i &lt; 1) {
        codage = true
      } else {
        codage = false
      }
      if (longueur(centre, sommet) !== 0) {
        this.rotationPoint(sommet, centre, angle, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })
      }
      i++
    }
    this.epaisseur = 2
    this.couleur = couleur
    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu paisseur 2
  }

  /**
   *
   * @param {objet} p polygone dont on construit l'image et qui doit tre trac avec ses points nomms.
   * @param {objet} d axe de symtrie.
   * @param {string} noms tableau contenant les noms des sommets dans le mme ordre que p
   * @param {objet} param3 options couleur et couleurCodage
   * @author Liouba Leroux et Jean-Claude Lhote
   */
  this.symetrieAxialePolygone = function (p, d, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {
    let nom
    const p2 = symetrieAxiale(p, d) // Pour tracer la figure image  la fin de l'animation avec polygoneRapide
    // const N = homothetie(milieu(p.listePoints[0], p2.listePoints[0]), milieu(p.listePoints[1], p2.listePoints[1]), 1.23456) // crer unh point de l'axe de symtrie pour les alignements et les mesure d'angles
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    let i = 0
    const marques = ['/', '//', '///', 'O', '\\\\']
    for (const sommet of p.listePoints) { // On rpte la construction pour chaque sommet du polygone
      if (noms[i] !== undefined) {
        nom = noms[i]
      } else {
        nom = sommet.nom + "'"
      }
      this.symetrieAxialePoint(sommet, d, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })
      i++
    }
    this.compasMasquer()
    this.crayonMasquer()
    this.epaisseur = 2
    this.couleur = couleur
    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu paisseur 2
    this.polygoneRapide(p2)
  }

  /**
   *
   * @param {objet} p polygone dont on construit l'image
   * @param {objet} A point de dpart de la translation
   * @param {objet} B point d'arrive de la translation
   * @param {string} noms tableau contenant les noms des sommets dans le mme ordre que p
 * @param {objet} param3 options couleur et couleurCodage
 * @author Jean-Claude Lhote
*/
  this.translationPolygone = function (p, A, B, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = 'O' } = {}) {
    let nom
    const v = vecteur(A, B)
    const p2 = translation(p, v) // Pour tracer la figure image  la fin de l'animation avec polygoneRapide
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    let i = 0
    for (const sommet of p.listePoints) { // On rpte la construction pour chaque sommet du polygone
      if (noms[i] !== undefined) {
        nom = noms[i]
      } else {
        nom = sommet.nom + "'"
      }
      this.translationPoint(sommet, A, B, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })
    }
    this.epaisseur = 2
    this.couleur = couleur
    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu paisseur 2
    this.polygoneRapide(p2)
    i++
  }
  /**
   *
   * @param {objet} p  le polygone dont on veut construire l'image qui doit tre trac
   * @param {objet} centre le centre de symtrie
   * @param {array} noms les noms des sommets images (si pas prcis ce sera le nom de l'antcdent avec un ')
   * @param {objet} param3 options couleur et couleurCodage
   * @author Jean-Claude Lhote
   */
  this.demiTourPolygone = function (p, centre, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {
    const p2 = rotation(p, centre, 180) // Pour tracer la figure image  la fin de l'animation avec polygoneRapide
    this.epaisseur = 0.5 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    let nom
    let i = 0
    const marques = ['/', '//', '///', 'O', '\\\\']
    for (const sommet of p.listePoints) { // On rpte la construction pour chaque sommet du polygone
      if (noms[i] !== undefined) {
        nom = noms[i]
      } else {
        nom = sommet.nom + "'"
      }
      this.demiTourPoint(sommet, centre, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })
      i++
    }
    this.epaisseur = 2
    this.couleur = couleur
    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu paisseur 2
    this.polygoneRapide(p2)// figure svg de l'exercice
  }

  /**
   *
   * @param {objet} p polygone dont on doit construire l'image
   * @param {objet} centre de l'homothtie
   * @param {number} k rapport de l'homothtie
   * @param {array} noms tableau contenant les diffrents noms des sommets dans le mme ordre que ceux de p. Si vide, alors on ajoute '  ceux de p
   * @param {objet} param4 options (couleur)
   */
  this.homothetiePolygone = function (p, centre, k, noms = [], { couleur = this.couleur } = {}) {
    let nom
    const p2 = homothetie(p, centre, k) // Pour tracer la figure image  la fin de l'animation avec polygoneRapide
    this.epaisseur = 1 // paisseur et couleur de crayon de papier bien taill pour la construction
    this.couleur = 'grey'
    const t = this.textePosition('Comme k est ' + (k >= 0 ? 'positif' : 'ngatif') + ' alors ' + (k >= 0 ? 'les figures sont du mme ct de ' + centre.nom : centre.nom + ' est entre les figures'), 0, 0, { taille: 15 })
    let i = 0
    for (const sommet of p.listePoints) { // On rpte la construction pour chaque sommet du polygone
      if (noms[i] !== undefined) {
        nom = noms[i]
      } else {
        nom = sommet.nom + "'"
      }
      this.homothetiePoint(sommet, centre, k, nom, { couleur: couleur })
      i++
    }
    this.epaisseur = 2
    this.couleur = couleur
    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu paisseur 2
    this.texteMasquer(t)
  }
  /** **** Fin de la classe Alea2iep */
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Jul 05 2021 10:08:48 GMT+0200 (heure dt dEurope centrale) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
