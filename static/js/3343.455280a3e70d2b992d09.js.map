{"version":3,"sources":["webpack://mathalea/./src/js/exercices/Exercice.js","webpack://mathalea/./src/js/modules/3d.js"],"names":["Exercice","this","titre","consigne","consigneCorrection","listeQuestions","listeCorrections","introduction","contenu","contenuCorrection","nbQuestions","nbCols","nbColsCorr","spacing","spacingCorr","beamer","besoinFormulaireNumerique","besoinFormulaireTexte","besoinFormulaireCaseACocher","consigneModifiable","nbQuestionsModifiable","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","correctionDetailleeDisponible","correctionDetaillee","video","boutonAide","tailleDiaporama","pasDeVersionLatex","interactif","interactifObligatoire","qcm","qcmDisponible","modeQcm","autoCorrection","tableauSolutionsDuQcm","mg32Editable","nouvelleVersion","numeroExercice","listePackages","math","matrix","multiply","norm","cross","dot","numId","ObjetMathalea2D","positionLabel","isVisible","color","style","styleTikz","epaisseur","opacite","pointilles","id","context","Point3d","constructor","x","y","z","visible","label","alpha","Math","PI","rapport","MT","cos","sin","typeObjet","V","W","p2d","point","_data","point3d","Vecteur3d","args","length","matrice","norme","sqrt","vecteur","representant","A","B","translation3d","vecteur3d","Arete3d","point1","point2","extremite1","extremite2","segment","arete3d","p1","p2","Droite3d","point3D","vecteur3D","directeur","origine","M","droite","droite3d","demicercle3d","centre","normal","rayon","cote","angledepart","signe","listepoints","d","push","rotation3d","i","demiCercle","polyline","cercle3d","C","polygone","Polygone3d","Array","isArray","listePoints","segments3d","segments","aretes","polygone3d","Sphere3d","nbParalleles","nbMeridiens","call","objets","c1","c2","c3","c4","D","prodvec","rayon2","R","cote1","cote2","rayon3","k","rotationV3d","svg","coeff","code","objet","tikz","sphere3d","Cone3d","centrebase","sommet","generatrices","s","color1","color2","cone3d","Cylindre3d","centrebase1","centrebase2","rayon1","cylindre3d","Cube","beta","colorD","colorT","colorG","proj","cosa","sina","cosb","sinb","p","lstPoints","lstPolygone","opaciteDeRemplissage","couleurDeRemplissage","svgml","amp","tikzml","cube","angle","unitaire","u","v","w","c","droite3D","SensDeRotation3d","axe","N","sensDeRotation3d"],"mappings":"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","file":"js/3343.455280a3e70d2b992d09.js","sourcesContent":["/**\n *\n *  Classe parente de tous les exercices\n *\n * @author Rémi Angot\n */\nexport default function Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = ''\n  this.consigne = ''\n  this.consigneCorrection = ''\n  this.listeQuestions = []\n  this.listeCorrections = []\n  this.introduction = ''\n  this.contenu = ''\n  this.contenuCorrection = ''\n  this.nbQuestions = 10\n  this.nbCols = 2\n  this.nbColsCorr = 2\n  this.spacing = 1\n  this.spacingCorr = 1\n  this.beamer = false\n\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte];\n  this.consigneModifiable = true\n  this.nbQuestionsModifiable = true\n  this.nbColsModifiable = true\n  this.nbColsCorrModifiable = true\n  this.spacingModifiable = true\n  this.spacingCorrModifiable = true\n  this.correctionDetailleeDisponible = false\n  this.correctionDetaillee = true\n  this.video = ''\n  this.boutonAide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,labelBouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,labelBouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,idYoutube,texte,labelBouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,urlPdf,texte=\"Aide\",labelBouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pasDeVersionLatex = false\n  this.interactif = false // Exercice sans saisie utilisateur par défaut\n  this.interactifObligatoire = false // Certains exercices sont uniquement des QCM et n'ont pas de version non interactiveout\n  this.qcm = false // Pour les exercices de type QCM : contient un tableau.\n  this.qcmDisponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n  this.modeQcm = false // Pour choisir la version QCM ou la version classique (false = version classique)\n  this.autoCorrection = [] // Liste des objets par question pour correction interactive || export AMC\n  this.tableauSolutionsDuQcm = [] // Pour sauvegarder les solutions des QCM\n  this.mg32Editable = false // pas d'interface par défaut pour les figures MG32\n  this.nouvelleVersion = function (numeroExercice) {}\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n","import { point, vecteur, droite, segment, polyline, polygone } from './2d.js'\nimport { matrix, multiply, norm, cross, dot } from 'mathjs'\nimport { context } from './context.js'\nconst math = { matrix: matrix, multiply: multiply, norm: norm, cross: cross, dot: dot }\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @author Rémi Angot\n */\nlet numId = 0\nfunction ObjetMathalea2D () {\n  this.positionLabel = 'above'\n  this.isVisible = true\n  this.color = 'black'\n  this.style = '' // stroke-dasharray=\"4 3\" pour des hachures //stroke-width=\"2\" pour un trait plus épais\n  this.styleTikz = ''\n  this.epaisseur = 1\n  this.opacite = 1\n  this.pointilles = false\n  this.id = numId\n  numId++\n  //   mesObjets.push(this);\n  context.objets2D.push(this)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * LE POINT\n *\n* @author Jean-Claude Lhote\n* Point de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n* le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n*/\nclass Point3d {\n  constructor (x, y, z, visible, label, positionLabel) {\n    const alpha = context.anglePerspective * Math.PI / 180\n    const rapport = context.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    this.x = x\n    this.y = y\n    this.z = z\n    this.visible = visible\n    this.label = label\n    this.typeObjet = 'point3d'\n    const V = math.matrix([this.x, this.y, this.z])\n    const W = math.multiply(MT, V)\n    this.p2d = point(W._data[0], W._data[1], this.label, positionLabel)\n  }\n}\nexport function point3d (x, y, z = 0, visible = true, label = '', positionLabel) {\n  return new Point3d(x, y, z, visible, label, positionLabel)\n}\n\n/**\n   * LE VECTEUR\n   *\n   * @author Jean-Claude Lhote\n   * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n   * On les utilise dans tous les objets complexeimport Additionner_soustraires_decimaux from '../exercices/6e/6C20';\ns et dans toutes les transformations.import Nature_polygone from './../exercices/2e/2G12';\nimport Exercice_fractions_decomposer from './../exercices/6e/6N20';\n\n   * Ils servent notament à définir la direction des plans.\n   *\n   * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n   * A et B sont deux objets de type Point3d\n   * x,y et z sont trois nombres\n   * la commande math.matrix([x,y,z]) crée une matrice colonne.\n   *\n   * L'objet créé est de type Vecteur3d\n   * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n   * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n   */\nclass Vecteur3d {\n  constructor (...args) {\n    const alpha = context.anglePerspective * Math.PI / 180\n    const rapport = context.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    if (args.length === 2) {\n      this.x = args[1].x - args[0].x\n      this.y = args[1].y - args[0].y\n      this.z = args[1].z - args[0].z\n    } else {\n      if (typeof (args[0]) === 'number') {\n        this.x = args[0]\n        this.y = args[1]\n        this.z = args[2]\n      } else if (args.length === 1) {\n        this.x = args[0]._data[0]\n        this.y = args[0]._data[1]\n        this.z = args[0]._data[2]\n      }\n    }\n    this.matrice = math.matrix([this.x, this.y, this.z])\n    this.norme = Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2)\n    const W = math.multiply(MT, this.matrice)\n    this.p2d = vecteur(W._data[0], W._data[1])\n    this.representant = function (A) {\n      const B = translation3d(A, this)\n      return vecteur(A.p2d, B.p2d).representant(A.p2d)\n    }\n  }\n}\n\nexport function vecteur3d (...args) { // A,B deux Point3d ou x,y,z les composantes du vecteur\n  return new Vecteur3d(...args)\n}\n\n/**\n   * L'ARETE\n   * @author Jean-Claude lhote\n   *\n   *\n   *\n   */\nclass Arete3d {\n  constructor (point1, point2, color, visible) {\n    this.extremite1 = point1\n    this.extremite2 = point2\n    this.color = color\n    if (!point1.visible || !point2.visible || !visible) {\n      this.visible = false\n    } else {\n      this.visible = true\n    }\n    this.p2d = segment(point1.p2d, point2.p2d, color)\n    if (!this.visible) {\n      this.p2d.pointilles = 2\n    } else {\n      this.p2d.pointilles = false\n    }\n  }\n}\nexport function arete3d (p1, p2, color = 'black', visible = true) {\n  return new Arete3d(p1, p2, color, visible)\n}\n\n/**\n   * LA DROITE\n   *\n   * @author Jean-claude Lhote\n   * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n   * Droite de l'espace définie par 2 points droite3d(A,B)\n   * Les droites servent principalement à définir des axes de rotation dans l'espace\n   */\nclass Droite3d {\n  constructor (point3D, vecteur3D) {\n    if (vecteur3D.constructor === Vecteur3d) {\n      this.directeur = vecteur3D\n    } else if (vecteur3D.constructor === Point3d) {\n      this.directeur = vecteur3d(point3D, vecteur3D)\n    }\n    this.origine = point3D\n    const M = translation3d(this.origine, this.directeur)\n    this.point = M\n    this.p2d = droite(this.origine.p2d, M.p2d) // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n    this.p2d.isVisible = false\n  }\n}\n\nexport function droite3d (point3D, vecteur3D) {\n  return new Droite3d(point3D, vecteur3D)\n}\n\n/**\n * LE DEMI-CERCLE\n *\n *@author Jean-Claude Lhote\n * Le nom est trompeur, il s'agit le plus souvent d'une demi-ellipse représentant un cercle projeté\n * Utilisé pour représenter un cercle dont une moitié est visible mais pas l'autre.\n *\n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible' et déterminera dans quel sens on crée le demi-cercle.\n * Si cote='caché' alors on tourne dans le sens direct et le tracé est en pointillés\n * Si cote='visible' alors on tourne dans le sens indirect et le tracé est plein.\n *\n */\nexport function demicercle3d (centre, normal, rayon, cote, color, angledepart = context.anglePerspective) {\n  let signe; const M = []; const listepoints = []\n  if (cote === 'caché') {\n    signe = 1\n  } else {\n    signe = -1\n  }\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart))\n  listepoints.push(M[0].p2d)\n\n  for (let i = 1; i < 19; i++) {\n    M.push(rotation3d(M[i - 1], d, 10 * signe))\n    listepoints.push(M[i].p2d)\n  }\n  const demiCercle = polyline(listepoints, color)\n  if (cote === 'caché') {\n    demiCercle.pointilles = 2\n    demiCercle.opacite = 0.3\n  }\n  return demiCercle\n}\n\n/**\n    * LE CERCLE\n    *\n    * @author Jean-Claude Lhote\n    *\n    * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n    * visible est un booléen\n    *\n    */\nexport function cercle3d (centre, normal, rayon, visible = true, color = 'black') {\n  const M = []; const listepoints = []\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, context.anglePerspective))\n  listepoints.push(M[0].p2d)\n  for (let i = 1; i < 37; i++) {\n    M.push(rotation3d(M[i - 1], d, 10))\n    listepoints.push(M[i].p2d)\n  }\n  const C = polygone(listepoints, color)\n  if (!visible) {\n    C.pointilles = 2\n  }\n  return C\n}\n\n/**\n   * LE POLYGONE\n   *\n   * @author Jean-Claude Lhote\n   * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n   */\nclass Polygone3d {\n  constructor (...args) {\n    if (Array.isArray(args[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = args[0]\n      if (args[1]) {\n        this.color = args[1]\n      }\n    } else {\n      this.listePoints = args\n      this.color = 'black'\n    }\n    const segments3d = []; let A; const segments = []\n    A = this.listePoints[0]\n    for (let i = 1; i < this.listePoints.length; i++) {\n      segments3d.push(arete3d(A, this.listePoints[i], this.color))\n      segments.push(segments3d[i - 1].p2d)\n      A = this.listePoints[i]\n    }\n    segments3d.push(arete3d(A, this.listePoints[0], this.color))\n    segments.push(segments3d[this.listePoints.length - 1].p2d)\n    this.aretes = segments3d\n    this.p2d = segments\n  }\n}\n\nexport function polygone3d (...args) {\n  return new Polygone3d(...args)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE COMPLEXES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA SPHERE\n   *\n   * @author Jean-Claude Lhote\n   * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n   * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n   * @param {Point3d} centre\n   * @param {Number} rayon\n   * @param {Number} nbParalleles\n   * @param {Number} nbMeridiens\n   * @param {string} color\n   */\nfunction Sphere3d (centre, rayon, nbParalleles, nbMeridiens, color) {\n  ObjetMathalea2D.call(this)\n  this.centre = centre\n  this.rayon = vecteur3d(rayon, 0, 0)\n  this.normal = vecteur3d(0, 0, 1)\n  this.color = color\n  this.nbMeridiens = nbMeridiens\n  this.nbParalleles = nbParalleles\n  const objets = []; let c1; let c2; let c3; let c4; let C; let D\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon.matrice))\n  const rayon2 = vecteur3d(math.cross(this.rayon.matrice, math.multiply(prodvec.matrice, 1 / math.norm(prodvec.matrice))))\n  const R = rayon\n  const cote1 = 'caché'\n  const cote2 = 'visible'\n  // objets.push(cercle3d(this.centre,rotationV3d(prodvec,this.normal,context.anglePerspective),rotationV3d(this.rayon,this.normal,context.anglePerspective),true,this.color))\n  for (let k = 0, rayon3; k < 1; k += 1 / (this.nbParalleles + 1)) {\n    C = point3d(centre.x, centre.y, centre.z + R * Math.sin(k * Math.PI / 2))\n    D = point3d(centre.x, centre.y, centre.z + R * Math.sin(-k * Math.PI / 2))\n    rayon3 = vecteur3d(R * Math.cos(k * Math.PI / 2), 0, 0)\n    c1 = demicercle3d(C, this.normal, rayon3, cote1, this.color, context.anglePerspective)\n    c2 = demicercle3d(C, this.normal, rayon3, cote2, this.color, context.anglePerspective)\n    c3 = demicercle3d(D, this.normal, rayon3, cote1, this.color, context.anglePerspective)\n    c4 = demicercle3d(D, this.normal, rayon3, cote2, this.color, context.anglePerspective)\n    objets.push(c1, c2, c3, c4)\n  }\n  for (let k = 0, V, W; k < 1; k += 1 / this.nbMeridiens) {\n    V = rotationV3d(prodvec, this.normal, 90 + context.anglePerspective + k * 90)\n    W = rotationV3d(prodvec, this.normal, 90 + context.anglePerspective - (k + 1 / this.nbMeridiens) * 90)\n    c1 = demicercle3d(this.centre, V, rayon2, cote2, this.color, 0)\n    c2 = demicercle3d(this.centre, V, rayon2, cote1, this.color, 0)\n    c3 = demicercle3d(this.centre, W, rayon2, cote2, this.color, 0)\n    c4 = demicercle3d(this.centre, W, rayon2, cote1, this.color, 0)\n    objets.push(c1, c2, c3, c4)\n  }\n\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sphere3d (centre, rayon, nbParalleles, nbMeridiens, color = 'black') {\n  return new Sphere3d(centre, rayon, nbParalleles, nbMeridiens, color)\n}\n\n/**\n    * LE CONE\n    *\n    * @author Jean-Claude Lhote\n    *\n    * centrebase est le centre du disque de base\n    * sommet est le sommet du cône\n    * normal est un vecteur 3d normal au plan du disque (il détermine avec rayon de quel côté se trouve la partie visible)\n    *\n    */\nfunction Cone3d (centrebase, sommet, normal, rayon, generatrices = 18) {\n  ObjetMathalea2D.call(this)\n  this.sommet = sommet\n  this.centrebase = centrebase\n  this.normal = normal\n  this.rayon = vecteur3d(rayon, 0, 0)\n  const objets = []; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(normal.matrice, this.rayon.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = 'gray'\n    cote2 = 'visible'\n    color2 = 'black'\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = 'black'\n    color2 = 'gray'\n  }\n  const c1 = demicercle3d(this.centrebase, this.normal, this.rayon, cote1, color1)\n  const c2 = demicercle3d(this.centrebase, this.normal, this.rayon, cote2, color2)\n\n  for (let i = 0; i < c1.listePoints.length; i++) {\n    if (i % generatrices === 0) {\n      s = segment(this.sommet.p2d, c1.listePoints[i])\n      if (cote1 === 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  for (let i = 0; i < c2.listePoints.length; i++) {\n    if (i % generatrices === 0) {\n      s = segment(this.sommet.p2d, c2.listePoints[i])\n      if (cote2 === 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  objets.push(c1, c2)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cone3d (centre, sommet, normal, rayon, generatrices = 18) {\n  return new Cone3d(centre, sommet, normal, rayon, generatrices)\n}\n\n/**\n   * LE CYLINDRE\n   *\n   * @author Jean-Claude Lhote\n   * Crée un cylindre de révolution définit par les centres de ses 2 bases\n   * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes\n   * @param {Point3d} centrebase1\n   * @param {Point3d} centrebase2\n   * @param {Vecteur3d} normal\n   * @param {Vecteur3d} rayon1\n   * @param {Vecteur3d} rayon2\n   */\nfunction Cylindre3d (centrebase1, centrebase2, normal, rayon1, rayon2, color) {\n  ObjetMathalea2D.call(this)\n  this.centrebase1 = centrebase1\n  this.centrebase2 = centrebase2\n  this.normal = normal\n  this.rayon1 = rayon1\n  this.rayon2 = rayon2\n  this.color = color\n  const objets = []; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon1.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = this.color\n    cote2 = 'visible'\n    color2 = this.color\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = this.color\n    color2 = this.color\n  }\n  const c1 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote1, color1)\n  const c3 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote1, color1)\n  const c2 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote2, color2)\n  const c4 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote2, color2)\n  c3.pointilles = false\n  c3.color = this.color\n  for (let i = 0; i < c1.listePoints.length; i += 2) {\n    s = segment(c3.listePoints[i], c1.listePoints[i])\n    if (cote1 === 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  for (let i = 0; i < c2.listePoints.length; i += 2) {\n    s = segment(c4.listePoints[i], c2.listePoints[i])\n    if (cote2 === 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  objets.push(c1, c2, c3, c4)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cylindre3d (centrebase1, centrebase2, normal, rayon, rayon2, color = 'black') {\n  return new Cylindre3d(centrebase1, centrebase2, normal, rayon, rayon2, color)\n}\n\n/**\n   * LE PRISME\n   *\n   * @author Jean-Claude Lhote\n   * Crée un prisme à partir du base Polygone3d et d'un vecteur3d d'extrusion (on peut faire des prismes droits ou non droits)\n   */\nclass Prisme3d {\n  constructor (base, vecteur, color) {\n    ObjetMathalea2D.call(this)\n\n    this.color = color\n    base.color = color\n    this.base1 = base\n    this.base2 = translation3d(base, vecteur)\n    this.base2.color = this.base1.color\n    this.aretes = []\n    const objets = []; let s\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      objets.push(this.base1.p2d[i])\n    }\n    for (let i = 0; i < this.base2.listePoints.length; i++) {\n      objets.push(this.base2.p2d[i])\n    }\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      s = arete3d(this.base1.listePoints[i], this.base2.listePoints[i], this.color)\n      objets.push(s.p2d)\n    }\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.tikz()\n      }\n      return code\n    }\n  }\n}\n\nexport function prisme3d (base, vecteur, color = 'black') {\n  return new Prisme3d(base, vecteur, color)\n}\n\n/**\n   * LE cube\n   * @author Jean-Claude Lhote\n   * usage : cube(x,y,z,c,color) construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z.\n   * le face avant est dans le plan xz\n   *\n*/\nclass Cube3d {\n  constructor (x, y, z, c, color = 'black') {\n    const A = point3d(x, y, z)\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n    const B = translation3d(A, vx)\n    const C = translation3d(B, vz)\n    const D = translation3d(A, vz)\n    const E = translation3d(A, vy)\n    const F = translation3d(E, vx)\n    const G = translation3d(F, vz)\n    const H = translation3d(D, vy)\n    const faceAV = polygone([A.p2d, B.p2d, C.p2d, D.p2d], color)\n    const faceDr = polygone([B.p2d, F.p2d, G.p2d, C.p2d], color)\n    const faceTOP = polygone([D.p2d, C.p2d, G.p2d, H.p2d], color)\n    faceAV.couleurDeRemplissage = '#A9A9A9'\n    faceTOP.couleurDeRemplissage = 'white'\n    faceDr.couleurDeRemplissage = '#A5C400'\n    this.svg = function (coeff) {\n      return faceAV.svg(coeff) + '\\n' + faceTOP.svg(coeff) + '\\n' + faceDr.svg(coeff)\n    }\n    this.tikz = function () {\n      return faceAV.tikz() + '\\n' + faceTOP.tikz() + '\\n' + faceDr.tikz()\n    }\n  }\n}\nexport function cube3d (x, y, z, c) {\n  return new Cube3d(x, y, z, c)\n}\n\nclass Cube {\n  constructor (x, y, z, alpha, beta, colorD, colorT, colorG) {\n    ObjetMathalea2D.call(this)\n    this.x = x\n    this.y = y\n    this.z = z\n    this.alpha = alpha\n    this.beta = beta\n    this.colorD = colorD\n    this.colorG = colorG\n    this.colorT = colorT\n\n    this.lstPoints = []\n    this.lstPolygone = []\n    function proj (x, y, z, alpha, beta) {\n      const cosa = Math.cos(alpha * Math.PI / 180)\n      const sina = Math.sin(alpha * Math.PI / 180)\n      const cosb = Math.cos(beta * Math.PI / 180)\n      const sinb = Math.sin(beta * Math.PI / 180)\n      return point(cosa * x - sina * y, -sina * sinb * x - cosa * sinb * y + cosb * z)\n    }\n\n    this.lstPoints.push(proj(this.x, this.y, this.z, this.alpha, this.beta)) // point 0 en bas\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z, this.alpha, this.beta)) // point 1\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z + 1, this.alpha, this.beta)) // point 2\n    this.lstPoints.push(proj(this.x, this.y, this.z + 1, this.alpha, this.beta)) // point 3\n    this.lstPoints.push(proj(this.x + 1, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 4\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 5\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z, this.alpha, this.beta)) // point 6\n    let p\n    p = polygone([this.lstPoints[0], this.lstPoints[1], this.lstPoints[2], this.lstPoints[3]], 'black')\n    p.opaciteDeRemplissage = 1\n    p.couleurDeRemplissage = this.colorD\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[2], this.lstPoints[4], this.lstPoints[5], this.lstPoints[3]], 'black')\n    p.couleurDeRemplissage = this.colorG\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[3], this.lstPoints[5], this.lstPoints[6], this.lstPoints[0]], 'black')\n    p.couleurDeRemplissage = this.colorT\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svg(coeff)\n      }\n      code = `<g id=\"${this.id}\">${code}</g>`\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikz()\n      }\n      return code\n    }\n    this.svgml = function (coeff, amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svgml(coeff, amp)\n      }\n      return code\n    }\n    this.tikzml = function (amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikzml(amp)\n      }\n      return code\n    }\n  }\n}\nexport function cube (x = 0, y = 0, z = 0, alpha = 45, beta = -35, { colorD = 'green', colorT = 'white', colorG = 'gray' } = {}) {\n  return new Cube(x, y, z, alpha, beta, colorD, colorG, colorT)\n}\n\n/**\n   * LE PAVE\n   * @author Jean-Claude Lhote\n   * usage : pave(A,B,D,E) construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] sont délimitent 3 faces adjacentes.\n   *\n*/\nclass Pave3d {\n  constructor (A, B, D, E, color) {\n    ObjetMathalea2D.call(this)\n    const v1 = vecteur3d(A, B)\n    const v2 = vecteur3d(A, E)\n    const v3 = vecteur3d(A, D)\n    const C = translation3d(D, v1)\n    const H = translation3d(D, v2)\n    const G = translation3d(C, v2)\n    const F = translation3d(B, v2)\n    E.visible = false\n    this.color = color\n    this.base = polygone3d([A, B, F, E])\n    this.hauteur = v3\n    this.aretes = [arete3d(A, B, color), arete3d(A, D, color), arete3d(A, E, color), arete3d(C, B, color), arete3d(F, B, color), arete3d(C, D, color), arete3d(C, G, color), arete3d(F, G, color), arete3d(F, E, color), arete3d(H, G, color), arete3d(H, E, color), arete3d(H, D, color)]\n    this.svg = function (coeff) {\n      let code = ''\n      for (const arete of this.aretes) {\n        code += '\\n\\t' + arete.p2d.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const arete of this.aretes) {\n        code += '\\n\\t' + arete.p2d.tikz()\n      }\n      return code\n    }\n  }\n}\nexport function pave3d (A, B, C, E, color = 'black') {\n  return new Pave3d(A, B, C, E, color)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA ROTATION VECTORIELLE\n   *\n   * @author Jean-Claude Lhote\n   * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n   * Elle sert à faire tourner des vecteurs essentiellement.\n   * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n   *\n   * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n   * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n   * @param {*} angle Angle de rotation\n   */\nexport function rotationV3d (point3D, vecteur3D, angle) { // point = ce qu'on fait tourner (Point3d) ; vecteur = directeur de l'axe de rotation [x,y,z] et angle de rotation en degrés\n  let V, p2\n  const norme = math.norm(vecteur3D.matrice)\n  const unitaire = math.multiply(vecteur3D.matrice, 1 / norme)\n  const u = unitaire._data[0]; const v = unitaire._data[1]; const w = unitaire._data[2]\n  const c = Math.cos(angle * Math.PI / 180); const s = Math.sin(angle * Math.PI / 180)\n  const k = 1 - c\n  const matrice = math.matrix([[u * u * k + c, u * v * k - w * s, u * w * k + v * s], [u * v * k + w * s, v * v * k + c, v * w * k - u * s], [u * w * k - v * s, v * w * k + u * s, w * w * k + c]])\n  if (point3D.constructor === Point3d) {\n    V = math.matrix([point3D.x, point3D.y, point3D.z])\n    p2 = math.multiply(matrice, V)\n    return point3d(p2._data[0], p2._data[1], p2._data[2])\n  } else if (point3D.constructor === Vecteur3d) {\n    V = point3D\n    p2 = math.multiply(matrice, V.matrice)\n    return vecteur3d(p2._data[0], p2._data[1], p2._data[2])\n  }\n}\n\n/**\n   * LA ROTATION D'AXE UNE DROITE\n   *\n   * @author Jean-Claude Lhote\n   *\n   * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n   * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n   * @param {Droite3d} droite3D Axe de rotation\n   * @param {Number} angle Angle de rotation\n   * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n   */\nexport function rotation3d (point3D, droite3D, angle, color) {\n  const directeur = droite3D.directeur\n  const origine = droite3D.origine\n  const p = []\n  if (point3D.constructor === Point3d) {\n    const V = vecteur3d(origine, point3d(0, 0, 0))\n    const W = vecteur3d(point3d(0, 0, 0), origine)\n    const M = translation3d(point3D, V)\n    const N = rotationV3d(M, directeur, angle)\n    return translation3d(N, W)\n  } else if (point3D.constructor === Vecteur3d) {\n    return rotationV3d(point3D, directeur, angle)\n  } else if (point3D.constructor === Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(rotation3d(point3D.listePoints[i], droite3D, angle))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n\nfunction SensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  ObjetMathalea2D.call(this)\n  this.epaisseur = epaisseur\n  this.color = color\n  let M; let N; let s; const objets = []\n  M = translation3d(axe.origine, rayon)\n  for (let i = 0; i < angle; i += 5) {\n    N = rotation3d(M, axe, 5)\n    s = segment(M.p2d, N.p2d)\n    s.color = this.color\n    s.epaisseur = this.epaisseur\n    objets.push(s)\n    M = N\n  }\n  N = rotation3d(M, axe, 5)\n  s = segment(M.p2d, N.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  const d = droite3d(N, axe.directeur)\n  const A = rotation3d(M, d, 30)\n  const B = rotation3d(M, d, -30)\n  s = segment(N.p2d, A.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  s = segment(N.p2d, B.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  return new SensDeRotation3d(axe, rayon, angle, epaisseur, color)\n}\n\n/**\n   * LA TRANSLATION\n   *\n   * @author Jean-Claude Lhote\n   * @param {Point3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n   * @param {Vecteur3d} vecteur3D\n   */\nexport function translation3d (point3D, vecteur3D) {\n  if (point3D.constructor === Point3d) {\n    const x = point3D.x + vecteur3D.x\n    const y = point3D.y + vecteur3D.y\n    const z = point3D.z + vecteur3D.z\n    return point3d(x, y, z)\n  } else if (point3D.constructor === Polygone3d) {\n    const p = []\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(translation3d(point3D.listePoints[i], vecteur3D))\n    }\n    return polygone3d(p, point3D.color)\n  }\n}\nexport function homothetie3d (point3D, centre, rapport, color) {\n  let V\n  const p = []\n  if (point3D.constructor === Point3d) {\n    V = vecteur3d(centre, point3D)\n    V.x *= rapport\n    V.y *= rapport\n    V.y *= rapport\n    return translation3d(centre, V)\n  } else if (point3D.constructor === Vecteur3d) {\n    V = point3D\n    V.x *= rapport\n    V.y *= rapport\n    V.y *= rapport\n    return V\n  } else if (point3D.constructor === Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(homothetie3d(point3D.listePoints[i], centre, rapport, color))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n"],"sourceRoot":""}