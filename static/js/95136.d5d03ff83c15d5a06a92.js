"use strict";(self.webpackChunkmathalea=self.webpackChunkmathalea||[]).push([[95136,25523],{95136:(i,e,t)=>{t.r(e),t.d(e,{interactifReady:()=>r,interactifType:()=>$,amcReady:()=>u,amcType:()=>a,titre:()=>l,default:()=>g});var s=t(25523),n=t(25482),o=t(11945);const r=!0,$="qcm",u=!0,a="qcmMono",l="Multiplications et quotients de relatifs : signe avec une lettre";function g(){s.default.call(this),this.sup=3,this.consigne="",this.correctionDetailleeDisponible=!0,this.correctionDetaillee=!1,this.spacing=2,this.nbQuestions=3,this.nbQuestionsModifiable=!0,this.nouvelleVersion=function(){let i;switch(this.autoCorrection=[],this.sup=parseInt(this.sup),this.listeQuestions=[],this.listeCorrections=[],this.sup){case 1:i=[1];break;case 2:i=[2];break;case 3:i=[1,2];break;case 4:i=[3,4];break;case 5:i=[1,2,3,4]}const e=(0,n.SRM)(i,this.nbQuestions);for(let t,s,r,$,u,a,l=0,g=0;l<this.nbQuestions&&g<50;){this.autoCorrection[l]={};const i=20,b=new n.Mjk((0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,i),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,i),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,i),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,i),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,i)),c=["n","x","y","a","m"],f=c[(0,n.nSR)(0,c.length-1)],h=(0,n.Gag)(l+1),p=(0,n.nSR)(-1,1,[0]),d=1===e[l]?(0,n.nSR)(3,5):(0,n.nSR)(4,6);let S=(0,n.nSR)(0,d-1);const P=b.relatifs.slice(0,d-1),m=[];for(let e=0;e<P.length;e++)m.push((0,n.aIp)(P[e]));m.splice(S,0,f);let q,R,C="";switch(t=`Donne le signe de $ ${f} $ pour que ${h} soit ${-1===p?"negatif":"positif"}. <br>`,s=`${(0,n.PH8)("Supposons que "+f+" soit positif : ")}`,e[l]){case 1:C+=`${m[0]} `;for(let i=1;i<d;i++)C+=`\\times ${m[i]}`;t+=` ${h} = $ ${C} $ <br>`,this.correctionDetaillee?(P.push(1),s+=`<br> ${b.setRegleSigneProduit(...P)}`,s+=`<br><br> Donc si ${(0,n.PH8)(f+" est positif","black")} $ ${C} $ est ${(0,n.PH8)(b.getSigneProduitString(...P),"black")}.`,s+=`<br><br> ${(0,n.PH8)("Supposons maintenant que "+f+" soit négatif : ")}`,P.push(-1),s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,s+=`<br><br> Donc si ${(0,n.PH8)(f+" est négatif","black")} $ ${C} $ est ${(0,n.PH8)(b.getSigneProduitString(...P),"black")}.`,s+=`<br><br> ${(0,n.PH8)("Conclusion :")} <br>`+(0,n.PH8)(`Il faut donc que $ ${f} $ soit ${p===b.getSigneProduitNumber(...P)?"négatif":"positif"} pour que ${h} soit ${-1===p?"négatif":"positif"}`,"black")):(s=`<br> Il faut que $ ${f} $ soit ${p===b.getSigneProduitNumber(...P)?"positif":"négatif"} pour que ${h} soit ${-1===p?"négatif":"positif"}.`,a=p===b.getSigneProduitNumber(...P)?"positif":"négatif");break;case 2:C+="\\dfrac {"+m[0],$=(0,n.nSR)(2,d-2);for(let i=1;i<$+1;i++)C+=`\\times ${m[i]}`;C+="}{"+m[$+1];for(let i=$+2;i<d;i++)C+=`\\times ${m[i]}`;C+="}",t+=` ${h} = $ ${C} $ <br>`,this.correctionDetaillee?(s+=`<br> ${b.setRegleSigneQuotient(...P)}`,s+=`<br><br> Donc si ${(0,n.PH8)(f+" est positif","black")} $ ${C} $ est ${(0,n.PH8)(b.getSigneProduitString(...P),"black")}.`,s+=`<br><br> ${(0,n.PH8)("Supposons maintenant que "+f+" soit négatif : ")}`,P.push(-1),s+=`<br> ${b.setRegleSigneQuotient(...P)}`,s+=`<br><br> Donc si ${(0,n.PH8)(f+" est négatif","black")} $ ${C} $ est ${(0,n.PH8)(b.getSigneProduitString(...P),"black")}.`,s+=`<br><br> ${(0,n.PH8)("Conclusion :")} <br>`+(0,n.PH8)(`Il faut donc que $ ${f} $ soit ${p===b.getSigneProduitNumber(...P)?"négatif":"positif"} pour que ${h} soit ${-1===p?"négatif":"positif"}`,"black")):s=`<br> Il faut que $ ${f} $ soit ${p===b.getSigneProduitNumber(...P)?"positif":"négatif"} pour que ${h} soit ${-1===p?"négatif":"positif"}.`,a=p===b.getSigneProduitNumber(...P)?"positif":"négatif";break;case 3:q=(0,n.nSR)(-1,1,[0]),t=`Donne le signe de ${h} si $ ${f} $ est ${-1===q?"négatif":"positif"}. <br>`,s="",r=(0,n.nSR)(1,3),S=(0,n.nSR)(0,d-1);for(let i=0;i<r;i++)m.splice(S,0,f);C+=`${m[0]} `;for(let i=1;i<d+r;i++)C+=`\\times ${m[i]}`;R=`${P[0]} `;for(let i=1;i<d-1;i++)R+=`\\times ${P[i]}`;t+=` ${h} = $ ${C} $ <br>`,this.correctionDetaillee?(1===r||3===r?(s+=`On trouve ${r+1} fois le facteur $ ${f} $.<br> Or ${r+1} est pair donc leur produit sera positif.`,s+=`<br>Le signe de l'expression a donc le signe de : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quelque soit le signe de $ ${f} $.`,"black")):(s+=`On trouve ${r+1} fois le facteur $ ${f} $. <br> Or ${r+1} est impair donc leur produit est du signe de $ ${f} $ soit ${-1===q?"négatif":"positif"}.`,-1===q?(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,P.push(-1),s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quand $ ${f} $ est ${-1===q?"négatif":"positif"}.`,"black")):(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quand $ ${f} $ est ${-1===q?"négatif":"positif"}.`,"black"))),a=b.getSigneProduitString(...P)):(1===r||3===r?s=`${h} est ${b.getSigneProduitString(...P)} quelque soit le signe de $ ${f} $.<br>`:-1===q?(P.push(-1),s=`${h} est ${b.getSigneProduitString(...P)} si $ ${f} $ est négatif.<br>`):s=`${h} est ${b.getSigneProduitString(...P)} si $ ${f} $ est positif.<br>`,a=b.getSigneProduitString(...P));break;case 4:q=(0,n.nSR)(-1,1,[0]),t=`Donne le signe de ${h} si $ ${f} $ est ${-1===q?"négatif":"positif"}. <br>`,s="",u=(0,n.nSR)(2,7),C+=0===S?m[0]+"^{"+u+"}":m[0];for(let i=1;i<d;i++)C+=i===S?"\\times "+m[i]+"^{"+u+"}":"\\times "+m[i];R=`${P[0]} `;for(let i=1;i<d-1;i++)R+=`\\times ${P[i]}`;t+=` ${h} = $ ${C} $ <br>`,this.correctionDetaillee?u%2==0?(s+=`On trouve ${u} fois le facteur $ ${f} $.<br> Or ${u} est pair donc leur produit sera positif.`,s+=`<br>Le signe de l'expression a donc le signe de : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quelque soit le signe de $ ${f} $.`,"black"),a=b.getSigneProduitString(...P)):(s+=`On trouve ${u} fois le facteur $ ${f} $. <br> Or ${u} est impair donc leur produit est du signe de $ ${f} $ soit ${-1===q?"négatif":"positif"}.`,-1===q?(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,P.push(-1),s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quand $ ${f} $ est ${-1===q?"négatif":"positif"}.`,"black")):(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${R} $`,s+=`<br><br> ${b.setRegleSigneProduit(...P)}`,s+="<br><br>"+(0,n.PH8)(`Donc ${h} est ${b.getSigneProduitString(...P)} quand $ ${f} $ est ${-1===q?"négatif":"positif"}.`,"black")),a=b.getSigneProduitString(...P)):(u%2==0?s=`${h} est ${b.getSigneProduitString(...P)} quelque soit le signe de $ ${f} $.<br>`:-1===q?(P.push(-1),s=`${h} est ${b.getSigneProduitString(...P)} si $ ${f} $ est négatif.<br>`):s=`${h} est ${b.getSigneProduitString(...P)} si $ ${f} $ est positif.<br>`,a=b.getSigneProduitString(...P))}this.autoCorrection[l]={enonce:t,options:{ordered:!0},propositions:[{texte:"négatif",statut:"négatif"===a},{texte:"nul",statut:!1},{texte:"positif",statut:"positif"===a}]},t+=(0,o.l3)(this,l).texte,this.questionJamaisPosee(l,e[l],...P)&&(this.listeQuestions.push(t),this.listeCorrections.push(s),l++),g++}(0,n.K1R)(this)},this.besoinFormulaireNumerique=["Niveau de difficulté",5,"1 : Multiplications\n2 : Quotients \n3 : Multiplications et quotients \n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \n5 : Mélange "]}},25523:(i,e,t)=>{function s(){this.titre="",this.boutonAide=!1,this.consigne="",this.consigneCorrection="",this.introduction="",this.listeQuestions=[],this.listeCorrections=[],this.contenu="",this.contenuCorrection="",this.autoCorrection=[],this.tableauSolutionsDuQcm=[],this.spacing=1,this.spacingCorr=1,this.pasDeVersionLatex=!1,this.listePackages=[],this.consigneModifiable=!0,this.nbQuestionsModifiable=!0,this.nbCols=1,this.nbColsCorr=1,this.nbColsModifiable=!0,this.nbColsCorrModifiable=!0,this.spacingModifiable=!0,this.spacingCorrModifiable=!0,this.beamer=!1,this.tailleDiaporama=1,this.nbQuestions=10,this.pointsParQuestions=1,this.correctionDetailleeDisponible=!1,this.correctionDetaillee=!0,this.correctionIsCachee=!1,this.video="",this.interactif=!1,this.interactifObligatoire=!1,this.besoinFormulaireNumerique=!1,this.besoinFormulaireTexte=!1,this.besoinFormulaireCaseACocher=!1,this.besoinFormulaire2Numerique=!1,this.besoinFormulaire2Texte=!1,this.besoinFormulaire2CaseACocher=!1,this.besoinFormulaire3Numerique=!1,this.besoinFormulaire3Texte=!1,this.besoinFormulaire3CaseACocher=!1,this.besoinFormulaire4Numerique=!1,this.besoinFormulaire4Texte=!1,this.besoinFormulaire4CaseACocher=!1,this.mg32Editable=!1,this.listeArguments=[],this.nouvelleVersion=function(i){},this.questionJamaisPosee=function(i,...e){0===i&&(this.listeArguments=[]);let t="";for(const s of e)void 0!==s&&(t+=s.toString());return!(this.listeArguments.indexOf(t)>-1)&&(this.listeArguments.push(t),!0)}}t.r(e),t.d(e,{default:()=>s})}}]);
//# sourceMappingURL=95136.d5d03ff83c15d5a06a92.js.map