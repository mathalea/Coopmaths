/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmathalea"] = self["webpackChunkmathalea"] || []).push([["src_js_modules_Alea2iep_js"],{

/***/ "./src/js/modules/Alea2iep.js":
/*!************************************!*\
  !*** ./src/js/modules/Alea2iep.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Alea2iep)\n/* harmony export */ });\n/* harmony import */ var _2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./2d.js */ \"./src/js/modules/2d.js\");\n/* harmony import */ var _outils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./outils.js */ \"./src/js/modules/outils.js\");\n/* harmony import */ var instrumenpoche__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! instrumenpoche */ \"./node_modules/.pnpm/framagit.org+Sesamath+instrumenpoche@9897363c7a2f27f8e703dfbef5d5ac29546cd85e/node_modules/Instrumenpoche/src/iepLoadPromise.js\");\n/* eslint-disable camelcase */\n\n\n\n\n/*\n * Classe parente de tous les objets Alea2iep\n *\n * @Auteur Rémi Angot\n */\nfunction Alea2iep () {\n  this.idIEP = 0 // Identifiant pour les tracés\n  this.idHTML = 0 // Identifiant pour les div et le svg\n  this.tempo = 5 // Pause par défaut après une instruction\n  this.vitesse = 10 // Vitesse par défaut pour les déplacements d'instruments\n  this.couleur = 'blue' // Couleur par défaut\n  this.couleurCompas = 'forestgreen'\n  this.couleurTexte = 'black'\n  this.couleurPoint = 'black' // Couleur du nom des points\n  this.couleurCodage = '#f15929'\n  this.couleurTraitsDeConstruction = 'gray'\n  this.epaisseur = 2\n  this.epaisseurTraitsDeConstruction = 1\n  this.pointilles = false\n  this.liste_script = [] // Liste des instructions xml mise à jour par les méthodes\n\n  this.translationX = 0\n  this.translationY = 10 // Par défaut l'angle en haut à gauche est le point de coordonnées (0,10)\n\n  this.recadre = function (xmin, ymax) {\n    this.translationX = 1 - xmin\n    this.translationY = ymax + 3\n  }\n\n  // Garde en mémoire les coordonnées extrêmes des objets créés\n  this.xMin = 0\n  this.yMin = 0\n  this.xMax = 0\n  this.yMax = 0\n\n  this.taille = function (width, height) {\n    this.liste_script.push(`<viewBox width=\"${width}\" height=\"${height}\" />`)\n  }\n  // Transforme les coordonnées MathALEA2D en coordonnées pour le XML d'IEP\n  this.x = function (A) {\n    const x = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((A.x + this.translationX) * 30, 0)\n    if (A.x > this.xMax) {\n      this.xMax = A.x\n    }\n    if (A.x < this.xMin) {\n      this.xMin = A.x\n    }\n    return x\n  }\n  this.y = function (A) {\n    const y = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-A.y + this.translationY) * 30, 0)\n    if (A.y < this.yMin) {\n      this.yMin = A.y\n    }\n    if (A.y > this.yMax) {\n      this.yMax = A.y\n    }\n    return y\n  }\n\n  // Sauvegarde de l'état des instruments\n  this.regle = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    longueur: 15,\n    zoom: 100\n  }\n\n  this.crayon = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.equerre = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.requerre = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.rapporteur = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.compas = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    orientation: 'droite',\n    ecartement: 0,\n    leve: false,\n    zoom: 100\n  }\n\n  this.xml = ''\n\n  /**\n   * Renvoie le script xml\n   *\n   */\n  this.script = function () {\n    if (this.xml.length > 1) {\n      return this.xml\n    } else {\n      let codeXML = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n      codeXML += '<INSTRUMENPOCHE version=\"2\">\\n'\n      codeXML += this.liste_script.join('\\n')\n      codeXML += '\\n</INSTRUMENPOCHE>'\n      return codeXML\n    }\n  }\n\n  /**\n   * Renvoie le code HTML de l'animation\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   */\n  this.html = function (id1, id2) {\n    if (window.sortie_html) {\n      const id = `IEP_${id1}_${id2}`\n      window.listeScriptsIep[id] = this.script() // On ajoute le script\n      const codeHTML = `<div id=\"IEPContainer${id}\" ></div>`\n      window.listeAnimationsIepACharger.push(id)\n      return codeHTML\n    }\n  }\n\n  /**\n   *\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   * @return Code HTML avec le bouton qui affiche ou masque un div avec l'animation\n   */\n  this.htmlBouton = function (id1, id2 = '') {\n    if (window.sortie_html) {\n      const id = `IEP_${id1}_${id2}`\n      window.listeScriptsIep[id] = this.script() // On ajoute le script\n      const codeHTML = `<br><button class=\"ui mini compact button\" id=\"btnAnimation${id}\" onclick=\"toggleVisibilityIEP('${id}')\" style=\"margin-top:20px\"><i class=\"large play circle outline icon\"></i>Voir animation</button>\n            <div id=\"IEPContainer${id}\" style=\"display: none;\" ></div>`\n      if (!window.toggleVisibilityIEP) {\n        window.toggleVisibilityIEP = function (id) {\n          const element = document.getElementById(`IEPContainer${id}`)\n          const elementBtn = document.getElementById(`btnAnimation${id}`)\n          const xml = window.listeScriptsIep[id]\n          if (element.style.display === 'none') {\n            element.style.display = 'block'\n            element.style.marginTop = '30px'\n            elementBtn.innerHTML = '<i class=\"large stop circle outline icon\"></i>Masquer animation'\n            ;(0,instrumenpoche__WEBPACK_IMPORTED_MODULE_2__.default)(element, xml, { zoom: true, autostart: true }).then(iepApp => {\n              // la figure est chargée\n            }).catch(error => { console.log(error) })\n          } else {\n            element.style.display = 'none'\n            elementBtn.innerHTML = '<i class=\"large play circle outline icon\"></i>Voir animation'\n          }\n        }\n      }\n      return codeHTML\n    } else {\n      return ''\n    }\n  }\n\n  /**\n **************************\n *** FONCTIONS COMMUNES ***\n **************************\n */\n\n  /**\n   *\n   * @param {string} objet - 'regle', 'equerre', 'requerre, 'compas', 'rapporteur' ou 'crayon'\n   * @param {point} A - Point (0, 0) par défaut\n   * @param {objet} options - { tempo : 10 }\n   */\n  this.montrer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    if (!this[objet].visibilite || this[objet].position !== A) { // On ajoute une ligne xml que si l'objet est caché ou doit apparaitre à un autre endroit\n      let codeXML = ''\n      let A1\n      if (typeof A === 'undefined') { // A1 est une copie de A ou (0,0) si A n'est pas défini\n        A1 = this[objet].position\n      } else {\n        A1 = A\n      }\n      if (this[objet].visibilite) { // S'il est déjà visible, montrer devient un déplcer\n        this.deplacer(objet, A1, { tempo: tempo, vitesse: vitesse })\n      } else {\n        codeXML = `<action objet=\"${objet}\" mouvement=\"montrer\" abscisse=\"${this.x(A1)}\" ordonnee=\"${this.y(A1)}\" tempo=\"${tempo}\" />`\n        this[objet].visibilite = true\n      }\n      this[objet].position = A1\n      this.liste_script.push(codeXML)\n    }\n  }\n\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.regleMontrer = function (A, options) {\n    this.montrer('regle', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.crayonMontrer = function (A, options) {\n    this.montrer('crayon', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.equerreMontrer = function (A, options) {\n    this.montrer('equerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.requerreMontrer = function (A, options) {\n    this.montrer('requerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.compasMontrer = function (A, options) {\n    this.montrer('compas', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.rapporteurMontrer = function (A, options) {\n    this.montrer('rapporteur', A, options)\n  }\n\n  /**\n   *\n   * @param {string} objet\n   * @param {objet} param1\n   */\n  this.masquer = function (objet, { tempo = this.tempo } = {}) {\n    if (this[objet].visibilite) { // On ajoute une ligne xml que si l'objet est visible\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"masquer\" tempo=\"${tempo}\" />`\n      this[objet].visibilite = false\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.regleMasquer = function (options) {\n    this.masquer('regle', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.crayonMasquer = function (options) {\n    this.masquer('crayon', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.equerreMasquer = function (options) {\n    this.masquer('equerre', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.requerreMasquer = function (options) {\n    this.masquer('requerre', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.compasMasquer = function (options) {\n    this.masquer('compas', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.rapporteurMasquer = function (options) {\n    this.masquer('rapporteur', options)\n  }\n\n  /**\n *\n * @param {string} objet\n * @param {point} A\n * @param {objet} options\n */\n  this.deplacer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    if (this[objet].position !== A) { // On n'ajoute une commande xml que s'il y a vraiment un déplacement\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n      this[objet].position = A\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.regleDeplacer = function (A, options) {\n    this.deplacer('regle', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.texteDeplacer = function (id, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const codeXML = `<action objet=\"texte\" id=\"${id}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n    this.liste_script.push(codeXML)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.crayonDeplacer = function (A, options) {\n    this.deplacer('crayon', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.equerreDeplacer = function (A, options) {\n    this.deplacer('equerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.requerreDeplacer = function (A, options) {\n    this.deplacer('requerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.compasDeplacer = function (A, options) {\n    this.deplacer('compas', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.rapporteurDeplacer = function (A, options) {\n    this.deplacer('rapporteur', A, options)\n  }\n\n  /**\n *\n * @param {string} objet\n * @param {int} angle\n * @param {objet} options\n */\n  this.rotation = function (objet, a, { tempo = this.tempo, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0) } = {}) {\n    let angle\n    if (a.typeObjet === 'point') {\n      const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(this[objet].position, a)\n      angle = d.angleAvecHorizontale\n    } else {\n      angle = a\n    }\n    if (this[objet].angle !== a) { // Si la rotation est inutile, on ne la fait pas\n      // Les angles de MathALEA2D et de IEP sont opposés !!!!!\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"rotation\" angle=\"${-1 * angle}\" tempo=\"${tempo}\" sens=\"${sens}\" />`\n      this[objet].angle = angle\n      if (typeof angle === 'number' && isFinite(angle)) {\n        this.liste_script.push(codeXML)\n      } else {\n        console.log('Angle de rotation non défini pour l\\'objet .', objet)\n      }\n    }\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.regleRotation = function (angle, options) {\n    this.rotation('regle', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.crayonRotation = function (angle, options) {\n    this.rotation('crayon', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.equerreRotation = function (angle, options) {\n    this.rotation('equerre', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.requerreRotation = function (angle, options) {\n    this.rotation('requerre', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.compasRotation = function (angle, options) {\n    this.rotation('compas', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.rapporteurRotation = function (angle, options) {\n    this.rotation('rapporteur', angle, options)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.regleZoom = function (k, { tempo = 0 } = {}) {\n    this.regle.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"regle\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.equerreZoom = function (k, { tempo = 0 } = {}) {\n    this.equerre.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"equerre\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.requerreZoom = function (k, { tempo = 0 } = {}) {\n    this.requerre.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"requerre\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.rapporteurZoom = function (k, { tempo = 0 } = {}) {\n    this.rapporteur.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"rapporteur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.compasZoom = function (k, { tempo = 0 } = {}) {\n    this.compas.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"compas\" />`)\n  }\n\n  /**\n **************************\n ********* POINT **********\n **************************\n */\n\n  /**\n * Crééer un point avec la croix pour le situer et son nom en bas à droite par défaut. L'id sera sauvegardé dans l'objet point. S'il n'est pas défini alors on prend le premier entier disponible.\n * @param {point} A\n * @param {objet} options { label: A.nom, tempo: this.tempo, couleur: this.couleurPoint, couleurLabel: this.couleurTexte, id }\n *\n */\n  this.pointCreer = function (A, { dx = 0.1, dy, label = A.nom, tempo = this.tempo, couleur = this.couleurPoint, couleurLabel = this.couleurTexte, id } = {}) {\n    if (typeof id !== 'undefined') {\n      A.id = id\n    } else {\n      this.idIEP++\n      A.id = this.idIEP\n    }\n    let codeXML\n    if (label) {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" />`\n      // codeXML += `\\n<action couleur=\"${couleurLabel}\" nom=\"${label}\" id=\"${this.idIEP}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\"  />`\n      const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(A.x, A.y)\n      if (typeof dx !== 'undefined') {\n        M.x += dx\n      }\n      if (typeof dy !== 'undefined') {\n        M.y += dy\n      }\n      this.textePoint(`$${label}$`, M, { tempo: 0, couleur: couleurLabel })\n    } else {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" tempo=\"${tempo}\" />`\n    }\n    this.liste_script.push(codeXML)\n  }\n  /**\n * Création de plusieurs points\n * Le dernier argument peut être une option qui sera appliquée à tous les points\n *\n * @param  {...points} points Points séparés par des virgules\n */\n  this.pointsCreer = function (...args) {\n    if (args[args.length - 1].typeObjet === 'point') {\n      for (const point of args) {\n        this.pointCreer(point, { tempo: 0 })\n      }\n    } else {\n      const options = args[args.length - 1]\n      console.log(options)\n      const enleveDernier = arr => arr.slice(0, -1)\n      for (const point of enleveDernier(args)) {\n        this.pointCreer(point, options)\n      }\n    }\n  }\n  /**\n * Masquer un point\n * @param {point} A\n * @param {objet} options Défaut : { tempo: 0 }\n */\n  this.pointMasquer = function (A, { tempo = 0 } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"masquer\" objet=\"point\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Montrer un point qui aurait été caché\n   * @param {point} A\n   * @param {objet} options Défaut ; { tempo : this.tempo }\n   */\n  this.pointMontrer = function (A, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"montrer\" objet=\"point\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Anime la translation d'un point\n   * @param {point} A\n   * @param {int} x Abscisse du point d'arrivée\n   * @param {int} y Ordonnée du point d'arrivée\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.pointDeplacer = function (A, x, y, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(x, y)\n    this.liste_script.push(`<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" id=\"${A.id}\" mouvement=\"translation\" objet=\"point\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`)\n  }\n  /**\n   * Ajoute un label au point\n   * @param {point} A\n   * @param {string} nom\n   * @param {objet} options dx pour le déplacement vertical du nom du point, dy pour le déplacemetn horizontal, couleur: this.couleurPoint, tempo: this.tempo\n   */\n  this.pointNommer = function (A, nom, { dx, dy, couleur = this.couleurPoint, tempo = this.tempo } = {}) {\n    // const coordonneesTexte = ''\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(A.x, A.y)\n    if (typeof dx !== 'undefined') {\n      M.x += dx\n    }\n    if (typeof dy !== 'undefined') {\n      M.y += dy\n    }\n    this.textePoint(`$${nom}$`, M, { tempo: tempo, couleur: couleur })\n    // this.liste_script.push(`<action couleur=\"${couleur}\" nom=\"${nom}\" id=\"${A.id}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\" ${coordonneesTexte} />`)\n  }\n\n  /**\n **************************\n ********* COMPAS *********\n **************************\n */\n\n  /**\n* Change l'orientation du compas. Par défaut, elle est vers la droite. L'orientation courante du compas est sauvegardée dans this.compas.orientation\n* @param {objet} options Défaut : { tempo: this.tempo}\n*/\n  this.compasRetourner = function ({ tempo = this.tempo } = {}) {\n    const codeXML = `<action mouvement=\"retourner\" objet=\"compas\" tempo=\"${tempo}\" />`\n    if (this.compas.orientation === 'droite') {\n      this.compas.orientation = 'gauche'\n    } else {\n      this.compas.orientation = 'droite'\n    }\n    this.liste_script.push(codeXML)\n  }\n  /**\n   *\n   * @param {int} longueur écartement en cm\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.compasEcarter = function (l, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const codeXML = `<action ecart=\"${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(l * 30, 1)}\" mouvement=\"ecarter\" objet=\"compas\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n    this.compas.ecartement = l\n    this.liste_script.push(codeXML)\n  }\n  /**\n   * Fais apparaitre la règle à l'horizontale, met le compas vertical et écarte le compas le long de la règle pour lire son écartement\n   * @param {int} longueur\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n   */\n  this.compasEcarterAvecRegle = function (l, { tempo = this.tempo, vitesse = this.vitesse, sens = this.vitesse / 2 } = {}) {\n    this.regleRotation(0, { tempo: 0, sens: sens })\n    this.regleMontrer(this.compas.position, { tempo: 0 })\n    this.regleDeplacer(this.compas.position, { tempo: 0, vitesse: vitesse })\n    this.compasMontrer()\n    this.compasRotation(0, { tempo: 0, sens: sens })\n    this.compasEcarter(l, { tempo: tempo, vitesse: vitesse, sens: sens })\n  }\n  /**\n *\n * @param {point} A Pointe du compas\n * @param {point} B Mine du compas\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n */\n  this.compasEcarter2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2) } = {}) {\n    this.compasMontrer(A)\n    this.compasDeplacer(A, { tempo: tempo, vitesse: vitesse })\n    const s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(A, B)\n    s.isVisible = false\n    const angle = s.angleAvecHorizontale\n    this.compasRotation(angle, { tempo: tempo, sens: sens })\n    this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B), { tempo: tempo, vitesse: vitesse })\n  }\n  /**\n * Remettre le compas en position standard. Son état est sauvegardé dans le booléen this.compas.leve.\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.compasLever = function ({ tempo = this.tempo } = {}) {\n    if (!this.compas.leve) { // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"lever\" objet=\"compas\" tempo=\"${tempo} />`\n      this.compas.leve = true\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n * Voir le compas en vue de dessus avant qu'il trace un arc de cercle\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.compasCoucher = function ({ tempo = this.tempo } = {}) {\n    if (this.compas.leve) { // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\" />`\n      this.compas.leve = false\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n * Trace un arc de cercle en gardant l'écartement et le centre actuel. L'angle de départ sera choisi pour être le plus proche de l'angle actuel\n * @param {int} angle1\n * @param {int} angle2\n * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n * @return {id}\n */\n  this.compasTracerArc2Angles = function (angle1, angle2, { tempo = this.tempo, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : ''\n    this.idIEP += 1\n    if (Math.abs(this.compas.angle - angle1) > Math.abs(this.compas.angle - angle2)) { // On cherche à commencer par le point le plus proche de la position courante du compas\n      [angle1, angle2] = [angle2, angle1]\n    }\n    let codeXML = `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" tempo=\"${tempo}\" />\\n`\n    codeXML += '<action mouvement=\"lever\" objet=\"compas\" />\\n'\n    codeXML += `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" />\\n`\n    let sensTexte\n    if (angle2 > angle1) {\n      sensTexte = sens\n    } else {\n      sensTexte = -1 * sens\n    }\n    codeXML += `<action couleur=\"${couleur}\" epaisseur=\"${epaisseur}\" sens=\"${sensTexte}\" debut=\"${-angle1}\" fin=\"${-angle2}\" mouvement=\"tracer\" objet=\"compas\"  ${pointillesTexte} id=\"${this.idIEP}\" />\\n`\n    codeXML += `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\"/>`\n    this.compas.angle = angle2\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Trace un arc de cercle autour d'un point. La longueur de l'arc est déterminée par l'option delta en degré qui est ajoutée de part et d'autre du point\n   * @param {point} centre\n   * @param {point} point\n   * @param {objet} options Défaut : { delta: 10, tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n   * @return {id}\n   */\n  this.compasTracerArcCentrePoint = function (centre, point, { delta = 10, tempo = this.tempo, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {\n    this.compasMontrer()\n    this.compasDeplacer(centre, { tempo: tempo, vitesse: vitesse })\n    const s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(centre, point)\n    s.visibility = false\n    const angle1 = s.angleAvecHorizontale - delta\n    const angle2 = s.angleAvecHorizontale + delta\n    if ((Math.abs(this.compas.ecartement - (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.compas.position, point))) > 0.1) {\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, point), { tempo: tempo, vitesse: vitesse })\n    }\n    return this.compasTracerArc2Angles(angle1, angle2, { tempo: tempo, vitesse: vitesse, epaisseur: epaisseur, sens: sens, couleur: couleur, pointilles: pointilles })\n  }\n  /**\n *\n * @param {point} centre\n * @param {point} point Point de départ du tracé du cercle\n * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n */\n  this.compasCercleCentrePoint = function (centre, point, { tempo = this.tempo, couleur = this.couleur, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {\n    this.compasEcarter2Points(centre, point, { vitesse: vitesse, tempo: tempo })\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(centre, point)\n    const angle1 = d.angleAvecHorizontale\n    this.compasTracerArc2Angles(angle1, angle1 + 360, { tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, couleur: couleur, pointilles: pointilles })\n  }\n\n  /**\n **************************\n ******** REQUERRE ********\n **************************\n */\n\n  /**\n   *\n   * @param {int} déplacement en nombre de cm (le déplacement peut être positif ou négatif)\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.requerreGlisserEquerre = function (a, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    this.liste_script.push(`<action abscisse=\"${a * 30}\" mouvement=\"glisser\" objet=\"requerre\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`)\n  }\n\n  /**\n **************************\n ******* RAPPORTEUR *******\n **************************\n */\n\n  // Non pris en charge par le lecteur JS\n  // this.rapporteurCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"circulaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n  // this.rapporteurSemiCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"semicirculaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n\n  /**\n   * Masque la graduation externe du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMasquerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Montre la graduation extérieure si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMontrerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"montrer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Masque la graduation interne du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMasquerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Montre la graduation interne si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMontrerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Met le rapporteur en position avec le centre en A et le 0 de droite alogné avec le point B\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n */\n  this.rapporteurDeplacerRotation2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2) } = {}) {\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    d.isVisible = false\n    this.rapporteurMontrer()\n    this.rapporteurDeplacer(A, { tempo: tempo, vitesse: vitesse })\n    this.rapporteurRotation(d.angleAvecHorizontale, { tempo: tempo, vitesse: vitesse, sens: sens })\n  }\n  /**\n * Fais une petite marque (couleur et épaisseur d'un trait de construction) sur une graduation du rapporteur\n * @param {int} angle\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, couleur: this.couleurTraitsDeConstruction, epaisseur: this.epaisseurTraitsDeConstruction }\n */\n  this.rapporteurCrayonMarqueAngle = function (angle, { tempo = this.tempo, vitesse = this.vitesse, couleur = this.couleurTraitsDeConstruction, epaisseur = this.epaisseurTraitsDeConstruction } = {}) {\n    const O = this.rapporteur.position\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(O, 5.2, angle + this.rapporteur.angle)\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(O, 5.5, angle + this.rapporteur.angle)\n    this.crayonMontrer()\n    this.crayonDeplacer(M, { tempo: tempo, vitesse: vitesse })\n    this.tracer(N, { tempo: tempo, vitesse: vitesse, couleur: couleur, epaisseur: epaisseur })\n  }\n  /**\n * Le crayon va faire une marque sur la graduation du rapporteur, le rapporteur va se cacher et on trace une demi-droite dont on peut choisir la \"longueur\" (par défaut 90% de celle de la règle)\n * @param {point} A Centre du rapporteur\n * @param {point} B Point avec lequel le 0 de droite sera aligné\n * @param {int} angle\n * @param {objet} options { longueur: 0.9 * this.regle.longueur, couleur: this.couleur, tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2, epaisseur: this.epaisseur, pointilles: this.pointilles }\n */\n  this.rapporteurTracerDemiDroiteAngle = function (A, B, angle, { longueur = 0.9 * this.regle.longueur, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {\n    if (angle > 0) {\n      this.rapporteurDeplacerRotation2Points(A, B, { tempo: tempo, vitesse: vitesse, sens: sens })\n      this.rapporteurCrayonMarqueAngle(angle, { tempo: tempo, vitesse: vitesse, sens: sens })\n    } else {\n      const B2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 180)\n      this.rapporteurDeplacerRotation2Points(A, B2, { tempo: tempo, vitesse: vitesse, sens: sens })\n      this.rapporteurCrayonMarqueAngle(180 - Math.abs(angle), { tempo: tempo, vitesse: vitesse, sens: sens })\n    }\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    d.isVisible = false\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(5.2 * this.rapporteur.zoom / 100, 1), d.angleAvecHorizontale + angle)\n    this.rapporteurMasquer({ tempo: tempo })\n    this.regleDemiDroiteOriginePoint(A, M, { longueur: longueur, couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })\n  }\n\n  /**\n **************************\n ********* REGLE **********\n **************************\n */\n\n  /**\n * Masquer les graduations sur la règle\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.regleMasquerGraduations = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"regle\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Montrer les graduations sur la règle si elles avaient été masquées\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.regleMontrerGraduations = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"regle\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Modifie la taille de la règle\n   * @param {int} longueur\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.regleModifierLongueur = function (longueur = 20, { tempo = this.tempo } = {}) {\n    this.regle.longueur = longueur\n    this.liste_script.push(`<action mouvement=\"modifier_longueur\" objet=\"regle\" longueur=\"${longueur}\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Trace une demi-droite d'origine O passant par A (ou en direction de A si les points sont trop éloignés)\n * @param {point} O Origine\n * @param {point} A Direction\n * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n */\n  this.regleDemiDroiteOriginePoint = function (O, A, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur\n    }\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, A, options.longueur)\n    this.regleSegment(O, M, options)\n  }\n\n  /**\n   * Trace une droite passanrt par les points A et B\n   * @param {point} A\n   * @param {point} B\n   * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n   */\n  this.regleDroite = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur\n    }\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(B, A, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-options.longueur * 0.5 + (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) * 0.5) / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B)))\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(A, B, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-options.longueur * 0.5 + (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) * 0.5) / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B)))\n    if (this.x(A) <= this.x(B)) {\n      this.regleMontrer(M)\n      this.regleRotation(N, options)\n      this.regleSegment(M, N, options)\n    } else {\n      this.regleMontrer(N)\n      this.regleRotation(M, options)\n      this.regleSegment(N, M, options)\n    }\n  }\n  /**\n * Avec la règle, on prolonge le segment de l cm du coté de la 2e extrémité si l est positif sinon du côté de la première extrémité\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut {longueur: 3, tempo: this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n */\n  this.regleProlongerSegment = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur - 3\n    }\n    if (options.longueur > 0) {\n      const B1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, 3)\n      const B2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, -options.longueur)\n      this.regleSegment(B1, B2, options)\n    } else {\n      const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, 3)\n      const A2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, options.longueur)\n      this.regleSegment(A1, A2, options)\n    }\n  }\n\n  /**\n **************************\n ********* TRAITS *********\n **************************\n */\n\n  /**\n * Le crayon trace un trait de sa position courante jusqu'au point B\n * @param {point} B\n * @param {objet} options Défaut { tempo: this.tempo, vitesse: this.vitesse, epaisseur: this.epaisseur, couleur: this.couleur, pointilles: this.pointilles, vecteur: false }\n * @return {id} id utilisée pour le tracé\n */\n  this.tracer = function (B, { tempo = this.tempo, vitesse = this.vitesse, epaisseur = this.epaisseur, couleur = this.couleur, pointilles = this.pointilles, vecteur = false } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : ''\n    const vecteurTexte = vecteur ? 'style=\"vecteur\"' : ''\n    this.idIEP += 1\n    const codeXML = `<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" epaisseur=\"${epaisseur}\" couleur=\"${couleur}\" mouvement=\"tracer\" objet=\"crayon\" tempo=\"${tempo}\" vitesse=\"${vitesse}\"  ${pointillesTexte} ${vecteurTexte} id=\"${this.idIEP}\" />`\n    this.crayon.position = B\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Trace au crayon le segment [AB]\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n  this.trait = function (A, B, options = {}) {\n    this.crayonDeplacer(A, options)\n    return this.tracer(B, options)\n  }\n  /**\n   * Trace au crayon le segment [AB] sans tempo et avec une vitesse multipliée par 1 000\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n  this.traitRapide = function (A, B, options = {}) {\n    options.tempo = 0\n    options.vitesse = 10000\n    this.crayonDeplacer(A, options)\n    return this.tracer(B, options)\n  }\n  /**\n * Masque le trait d'id fourni\n * @param {int} id\n * @param {objet} options Défaut : { tempo: 0, vitesse: 200 }\n */\n  this.traitMasquer = function (id, { tempo = 0, vitesse = 200 } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"trait\" id=\"${id}\" vitesse=\"${vitesse}\" />`)\n  }\n  /**\n   *\n   * @param {segment/point} Segment à tracer ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points\n   * @returns {id} identifiant utilisé pour le trait\n   */\n  this.regleSegment = function (arg1, arg2, arg3) {\n    let A, B, options, id\n    if (arg1.typeObjet === 'segment') {\n      A = arg1.extremite1\n      B = arg1.extremite2\n      options = arg2\n    } else {\n      A = arg1\n      B = arg2\n      options = arg3\n    }\n    if (A.x <= B.x) { // Toujours avoir la règle de gauche à droite\n      this.regleMontrer(A, options)\n      this.regleRotation(B, options)\n    } else {\n      this.regleMontrer(B, options)\n      this.regleRotation(A, options)\n    }\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.crayon.position, A) < (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.crayon.position, B)) { // Le crayon ira au point le plus proche\n      this.crayonMontrer(A, options)\n      id = this.tracer(B, options)\n    } else {\n      this.crayonMontrer(B, options)\n      id = this.tracer(A, options)\n    }\n    return id\n  }\n  /**\n   * Trace un polygone avec les options par défaut que l'on ne peut pas changer ici\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n  this.polygoneTracer = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.regleSegment(sommets[i], sommets[i + 1])\n    }\n    this.regleSegment(sommets[sommets.length - 1], sommets[0])\n  }\n\n  /**\n   * Trace un polygone avec traitRapide()\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n  this.polygoneRapide = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.traitRapide(sommets[i], sommets[i + 1])\n    }\n    this.traitRapide(sommets[sommets.length - 1], sommets[0])\n  }\n\n  /**\n **************************\n ********* TEXTE **********\n **************************\n */\n\n  /**\n   * Ecris un texte collé au point. On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {point} A\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   * @return {id}\n   */\n  this.textePoint = function (texte, A, { tempo = this.tempo, police = false, couleur = this.couleurTexte, taille, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas } = {}) {\n    this.idIEP++\n    const policeTexte = police ? `police=\"${police}\"` : ''\n    let options = ''\n    if (typeof couleurFond !== 'undefined') {\n      options += ` couleur_fond=\"${couleurFond}\"`\n    }\n    if (typeof opaciteFond !== 'undefined') {\n      options += ` opacite_fond=\"${opaciteFond}\"`\n    }\n    if (typeof couleurCadre !== 'undefined') {\n      options += ` couleur_cadre=\"${couleurCadre}\"`\n    }\n    if (typeof epaisseurCadre !== 'undefined') {\n      options += ` epaisseur_cadre=\"${epaisseurCadre}\"`\n    }\n    if (typeof marge !== 'undefined') {\n      options += ` marge=\"${marge}\"`\n    }\n    if (typeof margeGauche !== 'undefined') {\n      options += ` marge_gauche=\"${margeGauche}\"`\n    }\n    if (typeof margeDroite !== 'undefined') {\n      options += ` marge_droite=\"${margeDroite}\"`\n    }\n    if (typeof margeBas !== 'undefined') {\n      options += ` marge_bas=\"${margeBas}\"`\n    }\n    if (typeof margeHaut !== 'undefined') {\n      options += ` marge_haut=\"${margeHaut}\"`\n    }\n    if (typeof taille !== 'undefined') {\n      options += ` taille=\"${taille}\"`\n    }\n    let codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"creer\" objet=\"texte\" />`\n    codeXML += `\\n<action ${policeTexte} couleur=\"${couleur}\" texte=\"${texte}\" id=\"${this.idIEP}\" mouvement=\"ecrire\" objet=\"texte\" ${options} tempo=\"${tempo}\" />`\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Ecris un texte collé au point de coordonnées (x,y). On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {int} x Abscisse du coin en haut à gauche\n   * @param {int} y Ordonnée du coin en haut à gauche\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   */\n  this.textePosition = function (texte, x, y, options) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(x, y)\n    return this.textePoint(texte, A, options)\n  }\n\n  this.longueurSegment = function (A, B, dy, options) {\n    const l = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B, 1))\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B)\n    const w = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-v.y * dy / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.norme)(v), v.x * dy / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.norme)(v))\n    const ancrage = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, l / 2 - 0.7), w), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(0, 1))\n    return this.textePoint(`${l} cm`, ancrage, options)\n  }\n\n  this.mesureAngle = function (A, O, B) {\n    const a = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)(A, O, B)\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, a / 2), O, 1.3 / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(O, A)), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-0.2, 0.5))\n    return this.textePoint(Math.abs(a) + '°', C)\n  }\n  /**\n * Masque le trait d'id fourni\n * @param {int} id\n * @param {objet} options Défaut : { tempo: 0 }\n */\n  this.texteMasquer = function (id, { tempo = 0 } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"texte\" id=\"${id}\"  />`)\n  }\n\n  /**\n   * Met l'animation en pause forçant l'utilisateur à appuyer sur lecture pour voir la suite\n   */\n  this.pause = function () {\n    this.liste_script.push('<action mouvement=\"pause\" />')\n  }\n\n  /**\n **************************\n ******* CODAGES **********\n **************************\n */\n\n  /**\n   *\n   * @param {segment/point} Segment à coder ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points. Défaut : { tempo: this.tempo, couleur: this.couleurCodage, codage: '//', }\n   * @return {id}\n  */\n  this.segmentCodage = function (arg1, arg2 = {}, arg3 = {}) {\n    let s\n    let options = {}\n    if (arg1.typeObjet === 'segment') {\n      s = arg1\n      options = arg2\n    } else {\n      s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(arg1, arg2)\n      options = { ...arg3 }\n    }\n    if (options.tempo === undefined) {\n      options.tempo = this.tempo\n    }\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage\n    }\n    if (options.codage === undefined) {\n      options.codage = '\\\\'\n    }\n    this.idIEP++\n    const id = this.idIEP\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(s.extremite1, s.extremite2)\n    const codeXML = `<action abscisse=\"${this.x(M)}\" ordonnee=\"${this.y(M)}\" forme=\"${options.codage}\"  couleur=\"${options.couleur}\" id=\"${id}\" tempo=\"${options.tempo}\" mouvement=\"creer\" objet=\"longueur\" />`\n    this.liste_script.push(codeXML)\n    return id\n  }\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.segmentCodageMasquer = function (id, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"longueur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.segmentCodageMontrer = function (id, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"longueur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Trace le petit carré au crayon\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : {longueur : 0.3, couleur: this.couleurCodage}\n   * @return {array} [idTrait1, idTrait2]\n   */\n  this.codageAngleDroit = function (A, B, C, options = {}) {\n    this.crayonMontrer()\n    if (options.longueur === undefined) {\n      options.longueur = 0.3\n    }\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage\n    }\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, C, options.longueur)\n    const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, options.longueur)\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(A1, B, C1)\n    const options1 = { ...options } // On recopie options pour ouvoir en changer le tempo du premier tracé\n    options1.tempo = 0\n    const trait1 = this.trait(C1, M, options1)\n    const trait2 = this.trait(M, A1, options)\n    return [trait1, trait2]\n  }\n  /**\n   * Masque le codage d'un angle droit\n   * @param {int} id Identifiant du codage d'un angle droit\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.codageAngleDroitMasquer = function (id, { tempo = 0 } = {}) {\n    this.traitMasquer(id[0], { tempo: tempo })\n    this.traitMasquer(id[1], { tempo: tempo })\n  }\n\n  /**\n   * Code un angle. L'option codage peut être \"simple\", \"/\", \"//\", \"///\", \"O\"\n   * \"double\", \"double/\", \"double//\", \"double///\", \"doubleO\"\n   * \"triple\", \"triple/\", \"triple//\", \"triple///\", \"tripleO\"\n   * \"plein\", \"plein/\", \"plein//\", \"plein///\", \"pleinO\"\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : { rayon : 1, couleur: this.couleurCodage, codage: 'plein'}\n   * @return {id} L'identifiant correspond à l'identifiant des 3 points de l'angle séparés par _\n   */\n  this.angleCodage = function (B, A, C, { couleur = this.couleurCodage, codage = 'plein', rayon = 1, tempo = this.tempo } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    const d1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    const d2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, C)\n    d1.isVisible = false\n    d2.isVisible = false\n    const angle1 = -d1.angleAvecHorizontale\n    const angle2 = -d2.angleAvecHorizontale\n    const codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" rayon=\"${rayon * 30}\" angle1=\"${angle1}\" angle2=\"${angle2}\" forme=\"${codage}\"  couleur=\"${couleur}\" id=\"${id}\" tempo=\"${tempo}\" mouvement=\"creer\" objet=\"angle\" />`\n    this.liste_script.push(codeXML)\n    return id\n  }\n\n  /**\n   * Masque un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.angleCodageMasquer = function (B, A, C, { tempo = 0 } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"angle\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Montre un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.angleCodageMontrer = function (B, A, C, { tempo = 0 } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"angle\" tempo=\"${tempo}\" />`)\n  }\n\n  /**\n   * Affiche une image (donnée par son URL) au point A\n   * @param {string} url\n   * @returns {id}\n   */\n  this.image = function (url, A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0)) {\n    this.idIEP++\n    let codeXML\n    codeXML = `<action id=\"${this.idIEP}\" url=\"${url}\" mouvement=\"chargement\" objet=\"image\" />`\n    codeXML += `\\n<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"translation\" objet=\"image\" vitesse=\"100000\" />`\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n\n  /**\n *****************************************\n ********* MACROS-CONSTRUCTIONS **********\n *****************************************\n */\n\n  /**\n   * Trace la parallèle à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {*} options\n   */\n  this.paralleleRegleEquerre2points3epoint = function (A, B, C, options) {\n    let G, D, H1\n    // G est le point le plus à gauche, D le plus à droite et H le projeté de C sur (AB)\n    // H1 est un point de (AB) à gauche de H, c'est là où seront la règle et l'équerre avant de glisser\n    if (A.x < B.x) {\n      G = A\n      D = B\n    } else {\n      G = B\n      D = A\n    }\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d)\n    if (H.x < D.x) {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, D, -2) // H1 sera plus à gauche que H\n    } else if (H.x > D.x) {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, D, 2)\n    } else {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, G, 2)\n    }\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(H1, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtParallele)(C, d))\n    // C1 est le point d'arrivée de l'équerre après avoir glissé\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(C1, C, 6)\n    // Le tracé de la parallèle ne fera que 6 cm pour ne pas dépassr de l'équerre. M est la fin de ce tracé\n\n    if (H.x < G.x && (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, G) > 3) { // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G)\n      this.regleMasquer()\n    }\n    if (H.x > D.x && (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, D) > 3) { // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(G, D)\n    }\n\n    this.equerreMontrer(H1)\n    if (M.x > C1.x) {\n      this.equerreRotation(d.angleAvecHorizontale - 90)\n    } else {\n      this.equerreRotation(d.angleAvecHorizontale + 90)\n    }\n    if (H1.y > C1.y) {\n      if (this.regle.visibilite) {\n        this.regleDeplacer(H1, { vitesse: this.vitesse, tempo: 0 })\n        this.regleRotation(C1, { sens: this.vitesse / 2, tempo: 0 })\n      } else {\n        this.regleDeplacer(H1, { vitesse: 1000, tempo: 0 })\n        this.regleRotation(C1, { sens: 1000, tempo: 0 })\n      }\n    } else {\n      const C12 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(C1, H1, -2) // On monte un peu plus la règle pour que ça soit plus crédible\n      if (this.regle.visibilite) {\n        this.regleDeplacer(C12, { vitesse: this.vitesse, tempo: 0 })\n        this.regleRotation(H1, { sens: this.vitesse / 2, tempo: 0 })\n      } else {\n        this.regleDeplacer(C12, { vitesse: 1000, tempo: 0 })\n        this.regleRotation(H1, { sens: 1000, tempo: 0 })\n      }\n    }\n    this.regleMontrer()\n    this.equerreDeplacer(C1, options)\n    this.crayonMontrer()\n    this.crayonDeplacer(C1, options)\n    this.tracer(M, options)\n  }\n  /**\n     * Trace la perpendiculaire à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n     * @param {point} A\n     * @param {point} B\n     * @param {point} C\n     * @param {*} options\n     */\n  this.perpendiculaireRegleEquerre2points3epoint = function (A, B, C, options) {\n    const longueurRegle = this.regle.longueur\n    const zoomEquerre = this.equerre.zoom\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    let dist\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.appartientDroite)(C, A, B)) {\n      dist = 7.5\n    } else {\n      const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d)\n      dist = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, C) + 2\n    }\n    this.equerreZoom((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(dist * 100 / 7.5))\n    this.regleModifierLongueur(Math.max(dist * 2, 15))\n\n    this.perpendiculaireRegleEquerreDroitePoint(d, C)\n    this.equerreZoom(zoomEquerre)\n    this.regleModifierLongueur(longueurRegle)\n  }\n\n  this.perpendiculaireRegleEquerreDroitePoint = function (d, P) {\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(P, d)\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(P, H, 90)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, H, 180)\n    const alpha = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(10000, H.y), H, B)\n    this.equerreRotation(alpha)\n    this.equerreMontrer(H)\n    this.regleSegment(H, P)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, H, P)\n    this.regleProlongerSegment(P, H, { longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(P, H) * 2 })\n  }\n\n  /**\n *****************************************\n ********* DROITES REMARQUABLES **********\n *****************************************\n */\n\n  /**\n * Trace la médiatrice de [AB] au compas. Le paramétrage des longueurs correspond à la distance entre le milieu du segment et le point d'intersection des arcs de cercles\n *\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut : {longueur1: 3, longueur2: 3, codage: 'X', couleurCodage : this.couleurCodage, couleurCompas: this.couleurCompas}\n * @return {array} [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]\n  */\n  this.mediatriceAuCompas = function (A, B, options = {}) {\n    if (options.longueur1 === undefined) {\n      options.longueur1 = 3\n    }\n    if (options.longueur2 === undefined) {\n      options.longueur2 = -3\n    }\n    if (options.codage === undefined) {\n      options.codage = 'X'\n    }\n    if (options.couleurCodage === undefined) {\n      options.couleurCodage = this.couleurCodage\n    }\n    if (options.couleurCompas === undefined) {\n      options.couleurCompas = this.couleurCompas\n    }\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B)\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90)\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, options.longueur1)\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, options.longueur2)\n    this.compasMontrer()\n    this.compasDeplacer(A, options)\n    let arc1, arc2, arc3, arc4\n    if (options.longueur1 === -1 * options.longueur2) { // Si la distance est la même des deux côtés, on peut faire les arcs de part et d'autre\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, M), { vitesse: options.vitesse, sens: options.vitesse })\n      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc2 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc3 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc4 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n    } else {\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, M), options)\n      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc2 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc3 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc4 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n    }\n    this.compasMasquer()\n    if (M.x <= N.x) {\n      this.regleDroite(M, N, options)\n    } else {\n      this.regleDroite(N, M, options)\n    }\n    this.regleMasquer()\n    const codage1 = this.segmentCodage(A, O, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })\n    const codage2 = this.segmentCodage(O, B, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })\n    const codageCarre = this.codageAngleDroit(A, O, O2, { couleur: options.couleurCodage, tempo: options.tempo, vitesse: options.vitesse })\n    return [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]\n  }\n  /**\n   * Trace la médiatrice du segment [AB] avec la méthode Règle + équerre.\n   * @param {point} A\n   * @param {point} B\n   * @param {booléen} codage\n   */\n  this.mediatriceRegleEquerre = function (A, B, codage = 'X') {\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B)\n    this.regleMontrer()\n    this.regleDeplacer(A)\n    this.regleRotation(B)\n    this.crayonMontrer()\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90)\n    const O3 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, 90)\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, 0.2)\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O3, 0.2)\n    if (this.y(M) > this.y(N)) {\n      this.trait(O, M)\n    } else {\n      this.trait(O, N)\n    }\n    this.regleMasquer()\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A)\n      this.equerreMontrer()\n      this.equerreRotation(B)\n    } else {\n      this.equerreDeplacer(B)\n      this.equerreMontrer()\n      this.equerreRotation(A)\n    }\n    this.equerreDeplacer(O)\n    this.crayonDeplacer(O)\n    this.trait(O, O2)\n    this.equerreMasquer()\n    this.regleDroite(O2, O3)\n    this.regleMasquer()\n    this.segmentCodage(A, O, codage)\n    this.segmentCodage(O, B, codage)\n    this.codageAngleDroit(A, O, O2)\n  }\n  /**\n   * Trace la hauteur issue de C dans un triangle ABC. Prolonge si besoin le segment [AB] pour avoir le pied de la hauteur et le codage de l'angle droit.\n   * @param {point} A 1er point de la base\n   * @param {point} B 2e point de la base\n   * @param {point} C Sommet dont est issue la hauteur\n   * @param {booléen} codage angle droit ajouté si true\n   */\n  this.hauteur = function (A, B, C, codage = true) {\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    d.isVisible = false\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d)\n    let G, D\n    if (this.x(A) < this.x(B)) {\n      G = A\n      D = B\n    } else {\n      G = B\n      D = A\n    }\n    if (this.x(H) < this.x(G)) { // si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(G, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)\n    }\n    if (this.x(H) > this.x(D)) { // si le pied de la hauteur est trop à droite\n      this.regleProlongerSegment(G, D, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(D, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)\n    }\n    if (this.x(H) < this.x(G) || this.x(H) > this.x(D)) {\n      this.regleMasquer()\n    }\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A)\n      this.equerreMontrer()\n      this.equerreRotation(B)\n    } else {\n      this.equerreDeplacer(B)\n      this.equerreMontrer()\n      this.equerreRotation(A)\n    }\n    this.equerreDeplacer(H)\n    this.crayonMontrer()\n    this.crayonDeplacer(H)\n    this.trait(H, C)\n    this.equerreMasquer()\n    if (codage) {\n      this.codageAngleDroit(A, H, C)\n    }\n    this.crayonMasquer()\n  }\n  /**\n * Trace la médiane issue de C passant par le milieu de [AB]\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} options\n */\n  this.mediane = function (A, B, C, options = {}) {\n    if (options.codage === undefined) {\n      options.codage = 'X'\n    }\n    if (options.couleurTraitsDeConstruction === undefined) {\n      options.couleurTraitsDeConstruction = this.couleurTraitsDeConstruction\n    }\n    if (options.epaisseurTraitsDeConstruction === undefined) {\n      options.epaisseurTraitsDeConstruction = this.epaisseurTraitsDeConstruction\n    }\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B)\n    this.regleMontrer(A, options)\n    this.regleRotation(B, options)\n    this.crayonMontrer()\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90)\n    const O3 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, 90)\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, 0.2)\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O3, 0.2)\n    if (M.y > N.y) {\n      this.trait(O, M, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })\n    } else {\n      this.trait(O, N, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })\n    }\n    this.regleSegment(O, C, options)\n    if (options.codage) {\n      this.segmentCodage(A, O, options)\n      this.segmentCodage(O, B, options)\n    }\n  }\n  /**\n * Trace la bissectrice de l'angle ABC au compas.\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} param3\n * @returns {objet} {arc1, arc2, arc3, arc4}\n */\n  this.bissectriceAuCompas = function (A, B, C, { codage = '/', l = 2, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0), epaisseur = this.epaisseur, pointilles = this.pointilles, couleurCodage = this.couleurCodage, masquerTraitsDeConstructions = true } = {}) {\n    const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, l)\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, C, l)\n    // const demiangle = calcul(angleOriente(A, B, C) / 2);\n    const angle = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)(A, B, C)\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A1, -(180 - angle))\n    const options = { couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, pointilles: false }\n    const arc1 = this.compasTracerArcCentrePoint(B, A1, options)\n    const arc2 = this.compasTracerArcCentrePoint(B, C1, options)\n    const arc3 = this.compasTracerArcCentrePoint(A1, M, options)\n    const arc4 = this.compasTracerArcCentrePoint(C1, M, options)\n    this.compasMasquer()\n    this.regleDemiDroiteOriginePoint(B, M, { longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, A), couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })\n    this.regleMasquer()\n    this.crayonMasquer()\n    if (codage) {\n      this.angleCodage(A, B, M, { couleur: couleurCodage, codage: codage, tempo: tempo })\n      this.angleCodage(M, B, C, { couleur: couleurCodage, codage: codage, tempo: tempo })\n    }\n    if (masquerTraitsDeConstructions) {\n      this.traitMasquer(arc1)\n      this.traitMasquer(arc2)\n      this.traitMasquer(arc3)\n      this.traitMasquer(arc4)\n    }\n    return { arc1: arc1, arc2: arc2, arc3: arc3, arc4: arc4 }\n  }\n  /**\n * Construit les 3 médiatrices des côtés du triangle ABC puis le cercle circonscrit au triangle\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} options\n */\n  this.cercleCirconscrit = function (A, B, C, options = {}) {\n    if (options.couleur === undefined) {\n      options.couleur = this.couleur\n    }\n    if (options.couleurMediatrice === undefined) {\n      options.couleurMediatrice = options.couleur\n    }\n    if (options.couleurCercle === undefined) {\n      options.couleurCercle = options.couleur\n    }\n    options.codage = 'X'\n    options.couleur = options.couleurMediatrice\n    const m1 = this.mediatriceAuCompas(A, B, options)\n    this.traitMasquer(m1[0]) // On cache les arcs de cercle une fois la médiatrice tracée\n    this.traitMasquer(m1[1])\n    this.traitMasquer(m1[2])\n    this.traitMasquer(m1[3])\n    options.codage = '||'\n    const m2 = this.mediatriceAuCompas(B, C, options)\n    this.traitMasquer(m2[0])\n    this.traitMasquer(m2[1])\n    this.traitMasquer(m2[2])\n    this.traitMasquer(m2[3])\n    options.codage = '///'\n    const m3 = this.mediatriceAuCompas(A, C, options)\n    this.traitMasquer(m3[0])\n    this.traitMasquer(m3[1])\n    this.traitMasquer(m3[2])\n    this.traitMasquer(m3[3])\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.centreCercleCirconscrit)(A, B, C)\n    options.couleur = options.couleurCercle\n    this.compasCercleCentrePoint(O, A, options)\n  }\n\n  /**\n *****************************************\n ************** TRIANGLES ****************\n *****************************************\n */\n\n  /**\n   * Macro de construction d'un triangle à partir de ses 3 dimensions. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BC Distance entre le 2e et le 3e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle3longueurs = function (ABC, AB, AC, BC, description = true) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20))\n    const p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.triangle2points2longueurs)(A, B, AC, BC)\n    const C = p.listePoints[2]\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2)\n    this.pointCreer(A)\n    // this.regleRotation(droite(A,B).angleAvecHorizontale)\n    // this.regleMontrer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.crayonMasquer()\n    if (description) this.textePosition(`${A.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm.`, 0, -3)\n    this.couleur = 'forestgreen'\n    this.epaisseur = 2\n    this.compasMontrer(A)\n    this.compasEcarterAvecRegle(AC)\n    this.compasTracerArcCentrePoint(A, C, 40)\n    if (description) this.textePosition(`${B.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm donc ${C.nom} appartient au cercle de centre ${B.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm.`, 0, -4)\n    this.compasDeplacer(B)\n    this.compasEcarterAvecRegle(BC)\n    this.compasTracerArcCentrePoint(B, C)\n    this.compasMasquer()\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    if (description) this.textePosition(`Le point ${C.nom} est à une intersection des deux cercles.`, 0, -5)\n    this.pointCreer(C)\n    this.regleSegment(B, C)\n    this.regleSegment(C, A)\n    this.crayonMasquer()\n    this.regleMasquer()\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur d'un côté et de la longueur de l'hypoténuse.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangleRectangleCoteHypotenuse = function (ABC, AB, AC, description = true) { // Triangle rectangle en B\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20))\n    const dAB = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    dAB.isVisible = false\n    const dBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtPerpendiculaire)(B, dAB)\n    dBC.isVisible = false\n    const cAC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.cercle)(A, AC)\n    cAC.isVisible = false\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionLC)(dBC, cAC)\n    const c = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(C, B, 1.2)\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 8) this.equerreZoom(150)\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2)\n    this.equerreRotation(dAB.angleAvecHorizontale)\n    this.pointCreer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)\n    this.equerreMontrer(A)\n    this.equerreDeplacer(B)\n    this.tracer(c)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, B, C)\n    this.crayonMasquer()\n    if (description) this.textePosition(`${A.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm.`, 0, -4)\n    this.compasMontrer(A)\n    this.compasEcarterAvecRegle(AC)\n    this.couleur = 'forestgreen'\n    this.epaisseur = 2\n    this.compasTracerArcCentrePoint(A, C)\n    this.couleur = 'blue'\n    this.epaisseur = 2\n    if (description) this.textePosition(`${C.nom} est à une intersection de la perpendiculaire et du cercle.`, 0, -5)\n    this.crayonMontrer(C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleMasquer()\n    this.crayonMasquer()\n    return [A, B, C]\n  }\n\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur des deux côtés de l'angle droit.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangleRectangle2Cotes = function (ABC, AB, BC, description = true) { // Triangle rectangle en B\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20))\n    const dAB = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B)\n    dAB.isVisible = false\n    const dBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtPerpendiculaire)(B, dAB)\n    dBC.isVisible = false\n    const cBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.cercle)(B, BC)\n    cBC.isVisible = false\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionLC)(dBC, cBC)\n    const c = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(C, B, 1.2)\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 8) this.equerreZoom(150)\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2)\n    this.equerreRotation(dAB.angleAvecHorizontale)\n    this.pointCreer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)\n    this.equerreMontrer(A)\n    this.equerreDeplacer(B)\n    this.tracer(c)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, B, C)\n    if (description) this.textePosition(`${B.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm donc ${C.nom} est à ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm de ${B.nom} sur la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -4)\n    this.regleMontrer(B)\n    this.regleRotation(C)\n    this.crayonDeplacer(C)\n    this.pointCreer(C)\n    this.couleur = 'blue'\n    this.epaisseur = 2\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleMasquer()\n    this.crayonMasquer()\n\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle à partir d'une longueur et des 2 angles adajcents au côté connu. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {*} CBA Angle au 2e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle1longueur2angles = function (NOM, AB, BAC, CBA, description = true, mesure = false) {\n    const angle = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20)\n    const a1 = BAC\n    const a2 = CBA\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, angle)\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, 5.2, a1 + angle)\n    const D2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, 10)\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, D2, 0.4)\n    const E = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(B, 3, 180 - a2 + angle)\n    const E2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, E, 10)\n    const E1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(E, E2, -0.4)\n    const F = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(B, 5.2, 180 - a2 + angle)\n    const F1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(F, E2, 0.4)\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B), A, a1)\n    D.isVisible = false\n    const d2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(B, A), B, -a2)\n    d2.isVisible = false\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionDD)(d, d2)\n    if (NOM.length !== 3) {\n      description = false\n    } else {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(A)\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm.`, 0, -4)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.couleur = 'grey'\n    this.epaisseur = 1\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(A)\n    this.rapporteurRotation(angle)\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)\n    this.epaisseur = 3\n    this.trait(D, D1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleSegment(A, D2)\n    this.regleMasquer()\n    this.angleCodage(B, A, C)\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(B)\n    if (description) this.textePosition(`On place un repère à ${a2} degrés pour tracer la demi-droite [${B.nom + C.nom}).`, 0, -6)\n    this.epaisseur = 3\n    this.trait(E, E1, 10)\n    this.trait(F, F1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleMontrer(B)\n    this.regleSegment(B, E2)\n    this.angleCodage(C, B, A)\n    this.pointCreer(C, '', 0)\n    this.pointNommer(C, C.nom, -0.5, 1)\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.regleSegment(B, C)\n    this.regleSegment(C, A)\n    this.regleMasquer()\n    this.crayonMasquer()\n    if (description && mesure) this.textePosition(`On peut mesurer ${A.nom + C.nom} ≈ ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C, 1))} cm et ${B.nom + C.nom} ≈ ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, C, 1))} cm.`, 0, -7)\n\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle à partir des longueurs des deux côtés d'un angle Le premier point a pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle2longueurs1angle = function (NOM, AB, AC, BAC, description = true, mesure = false) {\n    const angle = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20)\n    const a1 = BAC\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, angle)\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, 5.2, a1 + angle)\n    const D2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, 10)\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, D2, 0.4)\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D2, AC)\n    if (NOM.length !== 3) {\n      description = false\n    } else {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(A)\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm.`, 0, -4)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.couleur = 'grey'\n    this.epaisseur = 1\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(A)\n    this.rapporteurRotation(angle)\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)\n    this.epaisseur = 3\n    this.trait(D, D1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleSegment(A, D2)\n    this.angleCodage(B, A, C)\n    this.rapporteurMasquer()\n    if (description) this.textePosition(`On place le point ${C.nom} sur la demi-droite [${A.nom + C.nom}) à ${AC} cm de ${A.nom}.`, 0, -6)\n    this.epaisseur = 3\n    this.couleur = 'blue'\n    this.crayonDeplacer(C)\n    this.pointCreer(C)\n    this.regleSegment(A, C)\n    this.crayonMasquer()\n    if (description) this.textePosition(`On trace le côté [${B.nom + C.nom}].`, 0, -7)\n    this.regleMontrer(C)\n    this.crayonMontrer(C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    return [A, B, C]\n  }\n\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de 2 points\n   * @param {point} A\n   * @param {point} B\n   * @param {string} nomC\n   * @return {array} [A, B, C]\n   */\n  this.triangleEquilateral2Sommets = function (A, B, nomC = '') {\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 60)\n    C.nom = nomC\n    this.traitRapide(A, B)\n    this.pointCreer(A, A.nom, 0)\n    this.pointCreer(B, B.nom, 0)\n    this.compasEcarter2Points(A, B)\n    this.compasTracerArcCentrePoint(A, C)\n    this.compasTracerArcCentrePoint(B, C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, C)\n    this.segmentCodage(B, C)\n    return [A, B, C]\n  }\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de la longueur du côté. Le premier point a pour coordonnées (6;0)\n   * @param {string} NOM\n   * @param {number} AB\n   * @return {array} [A, B, C]\n   */\n\n  this.triangleEquilateral = function (NOM, AB) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0)\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20))\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 60)\n    if (NOM.length === 3) {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.regleSegment(A, B)\n    this.pointCreer(A)\n    this.pointCreer(B)\n    this.compasEcarter2Points(A, B)\n    this.compasTracerArcCentrePoint(A, C)\n    this.compasTracerArcCentrePoint(B, C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, C)\n    this.segmentCodage(B, C)\n    return [A, B, C]\n  }\n\n  /**\n ************************************************\n ************** PARALLELOGRAMMES ****************\n ************************************************\n */\n\n  /**\n   * Trace un parallélogramme à partir de la donnée de 3 sommets consécutifs\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {string} nomD\n   * @param {boolean} description\n   * @param {boolean} csDejaTraces À true (par défaut), les 2 côtés seront faits immédiatement, sinon, on les tracera à la règle.\n   */\n  this.parallelogramme3sommetsConsecutifs = function (A, B, C, nomD = '', description = true, csDejaTraces = true) {\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(C, B, A)\n    D.nom = nomD\n    const xMin = Math.min(A.x, B.x, C.x, D.x)\n    const yMin = Math.min(A.y, B.y, C.y, D.y)\n    // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n    this.traitRapide(A, B)\n    this.traitRapide(B, C)\n    this.pointCreer(A, A.nom, 0)\n    this.pointCreer(B, B.nom, 0)\n    this.pointCreer(C, C.nom, 0)\n    this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses côtés opposés sont de même longueur.`, xMin - 1, yMin - 1)\n    this.compasEcarter2Points(B, A)\n    this.textePosition(`${B.nom + A.nom} = ${C.nom + D.nom}`, xMin - 1, yMin - 2)\n    this.compasTracerArcCentrePoint(C, D)\n    this.compasEcarter2Points(B, C)\n    this.textePosition(`${B.nom + C.nom} = ${A.nom + D.nom}`, xMin - 1, yMin - 3)\n    this.compasTracerArcCentrePoint(A, D, 10)\n    this.pointCreer(D)\n    this.compasMasquer()\n    this.regleSegment(C, D)\n    this.regleSegment(D, A)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B, { codage: '///', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(D, C, { codage: '///', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(B, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(A, D, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n  }\n  /**\n   * Trace le parallélogramme ABCD de centre O à partir de [AB] et O.\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   * @param {string} nomC\n   * @param {string} nomD\n   * @param {boolean} description\n   */\n  this.parallelogramme2sommetsConsecutifsCentre = function (A, B, O, nomC = '', nomD = '', description = true) {\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(O, A, O)\n    C.nom = nomC\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(O, B, O)\n    D.nom = nomD\n    const nom = A.nom + B.nom + C.nom + D.nom\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 12 || (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, D) > 12) {\n      this.regleModifierLongueur(30)\n    }\n    const xMin = Math.min(A.x, B.x, C.x, D.x)\n    const yMin = Math.min(A.y, B.y, C.y, D.y)\n    // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n    this.traitRapide(A, B)\n    this.pointCreer(A, { tempo: 0 })\n    this.pointCreer(B, { tempo: 0 })\n    this.pointCreer(O, { tempo: 0 })\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses diagonales se coupent en leur milieu.`, xMin - 1, yMin - 1)\n    }\n    this.pointilles = true\n    this.epaisseur = 1\n    this.couleur = this.couleurTraitsDeConstruction\n    this.regleDemiDroiteOriginePoint(A, O, { longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) + 3 })\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.compasEcarter2Points(A, O)\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + O.nom} = ${O.nom + C.nom}`, xMin - 1, yMin - 2)\n    }\n    this.pointilles = false\n    this.compasTracerArcCentrePoint(O, C)\n    this.compasMasquer()\n    this.pointilles = true\n    this.regleDemiDroiteOriginePoint(B, O, { longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, D) + 3 })\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.pointilles = false\n    this.compasEcarter2Points(B, O)\n    if (description && nom.length === 4) {\n      this.textePosition(`${B.nom + O.nom} = ${O.nom + D.nom}`, xMin - 1, yMin - 3)\n    }\n    this.compasTracerArcCentrePoint(O, D)\n    this.compasMasquer()\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(D)\n    this.regleSegment(A, D)\n    this.regleSegment(D, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.compasMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, O, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(O, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(B, O, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(O, D, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })\n  }\n  /**\n   * Trace la parallélogramme ABCD de centre O en partant de [AD), [AB) et O (mais sans voir la position de B et D au départ)\n   * @param {point} D\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   */\n  this.parallelogrammeAngleCentre = function (D, A, B, O) {\n    const B1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) + 2)\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, D) + 2)\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(B, A, D)\n    this.traitRapide(A, B1)\n    this.traitRapide(A, D1)\n    this.pointCreer(O, { tempo: 0 })\n    this.pointCreer(A, { tempo: 0 })\n    this.regleDemiDroiteOriginePoint(A, O, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1, pointilles: true })\n    this.pointilles = false\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.compasEcarter2Points(A, O)\n    this.compasTracerArcCentrePoint(O, C, { couleur: this.couleurTraitsDeConstruction })\n    this.compasMasquer()\n    this.paralleleRegleEquerre2points3epoint(B1, A, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.equerreMasquer()\n    this.regleDroite(C, D, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.paralleleRegleEquerre2points3epoint(A, D1, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.equerreMasquer()\n    this.regleDroite(C, B, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.pointCreer(D, { tempo: 0 })\n    this.pointCreer(B, { tempo: 0 })\n    this.pointCreer(C, { tempo: 0 })\n    this.regleSegment(B, C)\n    this.regleSegment(C, D)\n    this.regleMasquer()\n    this.crayonMasquer()\n  }\n\n  /**\n   ************************************************\n   ************** Carrés ****************\n   ************************************************\n   */\n\n  /**\n   * Macro crée par Sophie Desruelle\n   * @param {objet} A\n   * @param {number} c\n   * @returns polygoneAvecNom\n   */\n  this.carre1point1longueur = function (nom, A, c) {\n    const interligne = 1\n    A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(5, 0, nom[0])\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, c, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20), nom[1])\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, B, -90, nom[2])\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 90, nom[3])\n    const E = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, c + 2, 'E')\n    const F = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, C, c + 2, 'F')\n    this.equerreZoom((c + 3) * 100 / 7.5)\n    this.tempo = 20\n\n    this.textePosition(`1) On veut construire un carré dont les côtés mesurent ${c} cm, donc on commence par tracer un segment, ici [${nom[0] + nom[1]}], de cette longueur.`, 0, -2)\n\n    this.pointCreer(A, { tempo: 0 }) // On coupe la pause pour ne pas voir le déplacement du point\n    this.pointNommer(A, A.nom, { dx: -0.5, dy: 0 }) // On déplace le label du point A vers la gauche\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.regleMasquer()\n    this.longueurSegment(A, B, -1)\n\n    this.textePosition(`2) Un carré possède 4 angles droits, donc on trace la perpendiculaire à (${nom[0] + nom[1]}) passant par ${nom[0]}.`, 0, -2 - 1 * interligne)\n\n    this.equerreMontrer()\n    this.equerreDeplacer(A)\n    this.equerreRotation(B)\n    this.trait(A, E)\n    this.equerreMasquer()\n    this.codageAngleDroit(B, A, D)\n\n    this.textePosition(`3) Les 4 côtés d'un carré sont de la même longueur, donc on place le point ${nom[3]} sur cette perpendiculaire, à ${c} cm de ${nom[0]}.`, 0, -2 - 2 * interligne)\n\n    this.regleSegment(A, D)\n    this.pointCreer(D, { tempo: 0 })\n    this.pointNommer(D, D.nom, { dx: -0.7, dy: 0.5 })\n    this.regleMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, D)\n\n    this.textePosition(`4) De même, on trace la perpendiculaire à (${nom[0] + nom[3]}) passant par ${nom[3]}, puis on place le point ${nom[2]} sur cette perpendiculaire, à ${c} cm de ${nom[3]}.`, 0, -2 - 3 * interligne)\n\n    this.equerreMontrer()\n    this.equerreDeplacer(D)\n    this.equerreRotation(A)\n    this.trait(D, F)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, D, C)\n\n    this.regleSegment(D, C)\n    this.pointCreer(C, { tempo: 0 })\n    this.pointNommer(C, C.nom, { dx: 0, dy: 0.9 })\n    this.regleMasquer()\n    this.segmentCodage(D, C)\n\n    this.textePosition(`5) On trace le segment [${nom[1] + nom[2]}].`, 0, -2 - 4 * interligne)\n\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.segmentCodage(B, C)\n\n    this.textePosition(`6) On vérifie que ${nom[1] + nom[2]} = ${c} cm et que les deux derniers angles tracés sont droits.`, 0, -2 - 5 * interligne)\n\n    this.equerreMontrer(C, { tempo: 0 })\n    this.equerreRotation(D)\n    this.equerreMasquer()\n    this.codageAngleDroit(D, C, B)\n\n    this.equerreMontrer(B, { tempo: 0 })\n    this.equerreRotation(C)\n    this.equerreMasquer()\n    this.codageAngleDroit(C, B, A)\n    return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygoneAvecNom)(A, B, C, D)\n  }\n\n  /********************************************/\n  /** *********** Transformations **************/\n  /********************************************/\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de la rotation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n  this.rotationPoint = function (p, centre, angle, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = true } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    this.regleSegment(centre, p) // On trace le support du rapporteur\n    this.rapporteurMontrer(centre)\n    this.rapporteurTracerDemiDroiteAngle(centre, p, angle) // On trace le deuxième côté\n    this.regleMasquer()\n    this.rapporteurMasquer()\n    this.compasEcarter2Points(centre, p) // on prend l'écartement du compas\n    this.compasTracerArcCentrePoint(centre, image) // On fait l'arc qui coupe la demi-droite\n    this.compasMasquer()\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // On marque le point image (qui est nommé)\n    if (codage) {\n      if (Math.abs(angle) === 90) {\n        this.codageAngleDroit(p, centre, image, { couleur: couleurCodage })\n      } else {\n        this.angleCodage(p, centre, image, { couleur: couleurCodage })\n        this.textePoint(Math.abs(angle) + '°', (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle / 2), centre, 1.3 / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, p)), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-0.2, 0.5)))\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {objet} p point dont on construit l'image et qui doit être tracé.\n   * @param {objet} d axe de symétrie.\n   * @param {string} nom nom de l'image\n   * @param {objet} options couleur et couleurCodage\n   * @auteur Liouba Leroux et Jean-Claude Lhote\n   */\n  this.symetrieAxialePoint = function (p, d, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = '//' } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.symetrieAxiale)(p, d, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(p, image) !== 0) {\n      const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(p, image) // on crée le point milieu\n      const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, M, 90)\n      const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(N, M, 180)\n      this.regleMasquerGraduations()\n      this.perpendiculaireRegleEquerre2points3epoint(N, D, p)\n      this.compasEcarter2Points(M, p)\n      this.compasTracerArcCentrePoint(M, image)\n      this.regleSegment(p, image)\n      this.regleMasquer()\n      this.equerreMasquer()\n      this.segmentCodage(p, M, { codage: codage, couleur: couleurCodage })\n      this.segmentCodage(image, M, { codage: codage, couleur: couleurCodage })\n      this.crayonMasquer()\n      this.compasMasquer()\n    }\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n  }\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} le point de départ de la translation\n   * @param {objet} le point d'arrivée de la translation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n  this.translationPoint = function (p, A, B, nom, { couleur = 'black', couleurCodage = this.couleurCodage } = {}) {\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B)\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)(p, v, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, p) !== 0) { // si le point de départ A est l'antécédent, alors le point d'arrivée B est l'image... pas besoin de construction\n      this.compasEcarter2Points(A, p)\n      this.compasTracerArcCentrePoint(B, image)\n      this.compasEcarter2Points(A, B)\n      this.compasTracerArcCentrePoint(p, image)\n    }\n    this.compasMasquer()\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur })\n    const choix1 = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(0, 4)\n    const choix2 = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(0, 4, choix1)\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    const marque1 = marques[choix1]\n    const marque2 = marques[choix2]\n    this.couleur = 'green'\n    this.traitRapide(p, image)\n    this.traitRapide(A, B)\n    this.segmentCodage(p, image, { codage: marque1, couleur: couleurCodage })\n    this.segmentCodage(A, B, { codage: marque1, couleur: couleurCodage })\n    this.couleur = 'red'\n    this.traitRapide(B, image)\n    this.traitRapide(A, p)\n    this.segmentCodage(B, image, { codage: marque2, couleur: couleurCodage })\n    this.segmentCodage(A, p, { codage: marque2, couleur: couleurCodage })\n  }\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de symétrie\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur, couleurCodage et codage\n   * @Auteur Jean-Claude Lhote\n   */\n  this.demiTourPoint = function (p, centre, nom, { couleur = 'black', couleurCodage = this.couleurCodage, codage = '//' } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, 180, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    this.compasEcarter2Points(centre, p)\n    this.compasTracerArcCentrePoint(centre, image)\n    this.compasMasquer()\n    this.crayonDeplacer(p)\n    this.regleSegment(p, image)\n    this.couleur = couleur\n    this.epaisseur = 2\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(p, centre, { codage: codage, couleur: couleurCodage })\n    this.segmentCodage(centre, image, { codage: codage, couleur: couleurCodage })\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n  this.homothetiePoint = function (p, centre, k, nom, { couleur = this.couleur, positionTexte = { x: 0, y: 0 } } = {}) {\n    this.epaisseur = 1 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    const couleurSave = this.couleur\n    this.couleur = 'grey'\n    let t\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(p, centre, k, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if (k > 0) {\n      t = this.textePosition(`Comme le rapport est positif alors les points ${p.nom} et ${image.nom} sont du même côté de ${centre.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })\n    } else {\n      t = this.textePosition(`Comme le rapport est négatif alors ${centre.nom} est entre les points ${p.nom} et ${image.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })\n    }\n    this.regleSegment(p, centre)\n    const l = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(p, centre), 1)\n    const lprime = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(l * Math.abs(k)))\n    const t1 = this.textePosition(`La mesure de ${centre.nom}${p.nom} est ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.tex_nombre)((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)(l, 1))} cm et le rapport de l'homothetie est ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.tex_nombre)(k)}`, positionTexte.x, positionTexte.y - 1, { taille: 15 })\n    const t2 = this.textePosition(`donc ${centre.nom}${image.nom} mesure ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.tex_nombre)(l)} cm × ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.tex_nombre)(Math.abs(k))} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.tex_nombre)(lprime)} cm`, positionTexte.x, positionTexte.y - 2, { taille: 15 })\n    this.regleSegment(centre, image)\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.pause()\n    this.texteMasquer(t1)\n    this.texteMasquer(t2)\n    this.texteMasquer(t)\n    this.couleur = couleurSave\n  }\n  /**\n   *\n   * @param {objet} p le polygone qui est déjà tracé\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de rotation\n   * @Auteur Jean-Claude Lhote\n   * @param {objet} param4 options couleur et couleurCodage\n  */\n  this.rotationPolygone = function (p, centre, angle, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    let nom\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let i = 0; let codage\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      if (i < 1) {\n        codage = true\n      } else {\n        codage = false\n      }\n      if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, sommet) !== 0) {\n        this.rotationPoint(sommet, centre, angle, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })\n      }\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image et qui doit être tracé avec ses points nommés.\n   * @param {objet} d axe de symétrie.\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n   * @param {objet} param3 options couleur et couleurCodage\n   * @auteur Liouba Leroux et Jean-Claude Lhote\n   */\n  this.symetrieAxialePolygone = function (p, d, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    let nom\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.symetrieAxiale)(p, d) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    // const N = homothetie(milieu(p.listePoints[0], p2.listePoints[0]), milieu(p.listePoints[1], p2.listePoints[1]), 1.23456) // créer unh point de l'axe de symétrie pour les alignements et les mesure d'angles\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let i = 0\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.symetrieAxialePoint(sommet, d, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })\n      i++\n    }\n    this.compasMasquer()\n    this.crayonMasquer()\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image\n   * @param {objet} A point de départ de la translation\n   * @param {objet} B point d'arrivée de la translation\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n * @param {objet} param3 options couleur et couleurCodage\n * @Auteur Jean-Claude Lhote\n*/\n  this.translationPolygone = function (p, A, B, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = 'O' } = {}) {\n    let nom\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B)\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)(p, v) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    const i = 0\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.translationPoint(sommet, A, B, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)\n  }\n  /**\n   *\n   * @param {objet} p  le polygone dont on veut construire l'image qui doit être tracé\n   * @param {objet} centre le centre de symétrie\n   * @param {array} noms les noms des sommets images (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n  this.demiTourPolygone = function (p, centre, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, 180) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let nom\n    let i = 0\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.demiTourPoint(sommet, centre, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)// figure svg de l'exercice\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n  this.homothetiePolygone = function (p, centre, k, noms = [], { couleur = this.couleur } = {}) {\n    let nom\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(p, centre, k) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 1 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    const t = this.textePosition('Comme k est ' + (k >= 0 ? 'positif' : 'négatif') + ' alors ' + (k >= 0 ? 'les figures sont du même côté de ' + centre.nom : centre.nom + ' est entre les figures'), 0, 0, { taille: 15 })\n    let i = 0\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.homothetiePoint(sommet, centre, k, nom, { couleur: couleur })\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.texteMasquer(t)\n  }\n  /** **** Fin de la classe Alea2iep */\n}\n\n\n//# sourceURL=webpack://mathalea/./src/js/modules/Alea2iep.js?");

/***/ })

}]);