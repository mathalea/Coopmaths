(self.webpackChunkmathalea=self.webpackChunkmathalea||[]).push([[9845,6969],{66969:(e,i,t)=>{"use strict";function s(){this.titre="",this.consigne="",this.consigneCorrection="",this.listeQuestions=[],this.listeCorrections=[],this.introduction="",this.contenu="",this.contenuCorrection="",this.nbQuestions=10,this.nbCols=2,this.nbColsCorr=2,this.spacing=1,this.spacingCorr=1,this.beamer=!1,this.besoinFormulaireNumerique=!1,this.besoinFormulaireTexte=!1,this.besoinFormulaireCaseACocher=!1,this.consigneModifiable=!0,this.nbQuestionsModifiable=!0,this.nbColsModifiable=!0,this.nbColsCorrModifiable=!0,this.spacingModifiable=!0,this.spacingCorrModifiable=!0,this.correctionDetailleeDisponible=!1,this.correctionDetaillee=!0,this.video="",this.boutonAide=!1,this.tailleDiaporama=50,this.pasDeVersionLatex=!1,this.qcm=!1,this.qcmDisponible=!1,this.modeQcm=!1,this.mg32Editable=!1,this.nouvelleVersion=function(e){},this.listePackages=[]}t.r(i),t.d(i,{default:()=>s})},39845:(e,i,t)=>{"use strict";t.r(i),t.d(i,{titre:()=>o,default:()=>r});var s=t(66969),n=t(55339);const o="Multiplications et quotients de relatifs : signe avec une lettre";function r(){s.default.call(this),this.sup=3,this.titre=o,this.consigne="",this.correctionDetailleeDisponible=!0,this.correctionDetaillee=!1,this.spacing=2,this.nbQuestions=3,this.nbQuestionsModifiable=!0,this.nouvelleVersion=function(){let e;switch(this.sup=parseInt(this.sup),this.listeQuestions=[],this.listeCorrections=[],this.sup){case 1:e=[1];break;case 2:e=[2];break;case 3:e=[1,2];break;case 4:e=[3,4];break;case 5:e=[1,2,3,4]}let i=(0,n.SRM)(e,this.nbQuestions);for(let t,s,o=0,r=0;o<this.nbQuestions&&r<50;){let e=20,$=new n.Mjk((0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,e),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,e),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,e),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,e),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,e)),l=["n","x","y","a","m"],u=l[(0,n.nSR)(0,l.length-1)],a=(0,n.Gag)(o+1),g=(0,n.nSR)(-1,1,[0]),b=1==i[o]?(0,n.nSR)(3,5):(0,n.nSR)(4,6),c=(0,n.nSR)(0,b-1),p=$.relatifs.slice(0,b-1),f=[];for(let i=0;i<p.length;i++)f.push((0,n.aIp)(p[i]));f.splice(c,0,u);let d,h,S="";switch(t=`Donne le signe de $ ${u} $ pour que ${a} soit ${-1==g?"negatif":"positif"}. <br>`,s=`${(0,n.MZ9)("Supposons que "+u+" soit positif : ")}`,i[o]){case 1:S+=`${f[0]} `;for(let t=1;t<b;t++)S+=`\\times ${f[t]}`;t+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?(p.push(1),s+=`<br> ${$.setRegleSigneProduit(...p)}`,s+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,s+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,p.push(-1),s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,s+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,s+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):s=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 2:S+="\\dfrac {"+f[0];let e=(0,n.nSR)(2,b-2);for(let t=1;t<e+1;t++)S+=`\\times ${f[t]}`;S+="}{"+f[e+1];for(let t=e+2;t<b;t++)S+=`\\times ${f[t]}`;S+="}",t+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?(s+=`<br> ${$.setRegleSigneQuotient(...p)}`,s+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,s+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,p.push(-1),s+=`<br> ${$.setRegleSigneQuotient(...p)}`,s+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,s+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):s=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 3:d=(0,n.nSR)(-1,1,[0]),t=`Donne le signe de ${a} si $ ${u} $ est ${-1==d?"négatif":"positif"}. <br>`,s="";let i=(0,n.nSR)(1,3);c=(0,n.nSR)(0,b-1);for(let t=0;t<i;t++)f.splice(c,0,u);S+=`${f[0]} `;for(let t=1;t<b+i;t++)S+=`\\times ${f[t]}`;h=`${p[0]} `;for(let t=1;t<b-1;t++)h+=`\\times ${p[t]}`;t+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?1==i||3==i?(s+=`On trouve ${i+1} fois le facteur $ ${u} $.<br> Or ${i+1} est pair donc leur produit sera positif.`,s+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.`,"black")):(s+=`On trouve ${i+1} fois le facteur $ ${u} $. <br> Or ${i+1} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==d?"négatif":"positif"}.`,-1==d?(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,p.push(-1),s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black")):(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black"))):1==i||3==i?s=`${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.<br>`:-1==d?(p.push(-1),s=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est négatif.<br>`):s=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est positif.<br>`;break;case 4:d=(0,n.nSR)(-1,1,[0]),t=`Donne le signe de ${a} si $ ${u} $ est ${-1==d?"négatif":"positif"}. <br>`,s="";let o=(0,n.nSR)(2,7);S+=0==c?f[0]+"^{"+o+"}":f[0];for(let t=1;t<b;t++)S+=t==c?"\\times "+f[t]+"^{"+o+"}":"\\times "+f[t];h=`${p[0]} `;for(let t=1;t<b-1;t++)h+=`\\times ${p[t]}`;t+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?o%2==0?(s+=`On trouve ${o} fois le facteur $ ${u} $.<br> Or ${o} est pair donc leur produit sera positif.`,s+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.`,"black")):(s+=`On trouve ${o} fois le facteur $ ${u} $. <br> Or ${o} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==d?"négatif":"positif"}.`,-1==d?(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,p.push(-1),s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black")):(s+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,s+=`<br><br> ${$.setRegleSigneProduit(...p)}`,s+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black"))):o%2==0?s=`${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.<br>`:-1==d?(p.push(-1),s=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est négatif.<br>`):s=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est positif.<br>`}-1==this.listeQuestions.indexOf(t)&&(this.listeQuestions.push(t),this.listeCorrections.push(s),o++),r++}(0,n.K1R)(this)},this.besoinFormulaireNumerique=["Niveau de difficulté",3,"1 : Multiplications\n2 : Quotients \n3 : Multiplications et quotients \n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \n5 : Mélange "]}}}]);
//# sourceMappingURL=9845.0fca1ca8b5b0169ed7fd.js.map