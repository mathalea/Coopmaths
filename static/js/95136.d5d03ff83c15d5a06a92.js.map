{"version":3,"file":"js/95136.d5d03ff83c15d5a06a92.js","mappings":"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","sources":["webpack://mathalea/./src/js/exercices/4e/4C10-6.js","webpack://mathalea/./src/js/exercices/Exercice.js"],"sourcesContent":["import Exercice from '../Exercice.js'\nimport {\n  listeQuestionsToContenu, randint, combinaisonListes,\n  Relatif, lettreDepuisChiffre, ecritureNombreRelatif,\n  texteEnCouleurEtGras\n} from '../../modules/outils.js'\nimport { propositionsQcm } from '../../modules/gestionInteractif.js'\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = true\nexport const amcType = 'qcmMono'\nexport const titre = 'Multiplications et quotients de relatifs : signe avec une lettre'\n\n/**\n* Effectuer des multiplications de relatifs dans un tableau à double entrée\n*\n* @author Cédric GROLLEAU\n* 4C10-6\n*/\nexport default function ExerciceTableauMultiplicationsRelatifs () {\n  Exercice.call(this) // Héritage de la classe Exercice()\n  this.sup = 3\n  this.consigne = ''\n  this.correctionDetailleeDisponible = true\n  this.correctionDetaillee = false\n  this.spacing = 2\n  this.nbQuestions = 3\n  this.nbQuestionsModifiable = true\n\n  this.nouvelleVersion = function () {\n    this.autoCorrection = []\n    this.sup = parseInt(this.sup)\n    this.listeQuestions = [] // Liste de questions\n    this.listeCorrections = [] // Liste de questions corrigées\n    let typesDeQuestionsDisponibles\n    switch (this.sup) {\n      case 1: // multiplications\n        typesDeQuestionsDisponibles = [1]\n        break\n      case 2: // Quotient\n        typesDeQuestionsDisponibles = [2]\n        break\n      case 3: // multiplications et quotients\n        typesDeQuestionsDisponibles = [1, 2]\n        break\n      case 4: // avec puissances\n        typesDeQuestionsDisponibles = [3, 4]\n        break\n      case 5: // mélange\n        typesDeQuestionsDisponibles = [1, 2, 3, 4]\n        break\n    }\n    const listeTypeDeQuestions = combinaisonListes(typesDeQuestionsDisponibles, this.nbQuestions)\n    for (let i = 0, texte, texteCorr, nbLettres, nbNum, expLettre, reponse, cpt = 0; i < this.nbQuestions && cpt < 50;) {\n      this.autoCorrection[i] = {}\n      // on ne choisit que des nombres compris entre 1 et 20\n      const nbMax = 20\n      // Le tableau des relatifs necessaires, il m'en faut max 5 !\n      const num = new Relatif(\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax)\n      )\n      const lettreTab = ['n', 'x', 'y', 'a', 'm']\n      const lettre = lettreTab[randint(0, lettreTab.length - 1)]\n      const nomExpression = lettreDepuisChiffre(i + 1)\n      const signeExpression = randint(-1, 1, [0])\n      const nbTermes = listeTypeDeQuestions[i] === 1 ? randint(3, 5) : randint(4, 6)\n      let placeLettre = randint(0, nbTermes - 1)\n      const listeNombres = num.relatifs.slice(0, nbTermes - 1)\n      const listeTermes = []\n      for (let indice = 0; indice < listeNombres.length; indice++) {\n        listeTermes.push(ecritureNombreRelatif(listeNombres[indice]))\n      }\n      listeTermes.splice(placeLettre, 0, lettre)\n      let calcul = ''\n      let signeLettre, calculNombres\n      texte = `Donne le signe de $ ${lettre} $ pour que ${nomExpression} soit ${signeExpression === -1 ? 'negatif' : 'positif'}. <br>`\n      texteCorr = `${texteEnCouleurEtGras('Supposons que ' + lettre + ' soit positif : ')}`\n      switch (listeTypeDeQuestions[i]) {\n        case 1: // multiplications\n          calcul += `${listeTermes[0]} `\n          for (let k = 1; k < nbTermes; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          texte += ` ${nomExpression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            // texteCorr += `<br> $ ${ecritureNombreRelatif(listeNombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nbTermes-2 ; k++) {\n            // texteCorr += `  , $ ${ecritureNombreRelatif(listeNombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            // texteCorr += `  et $ ${ecritureNombreRelatif(listeNombres[parseInt(nbTermes-2)])} $ est ${num.getSigneString()[parseInt(nbTermes-2)]}`;\n            listeNombres.push(1)\n            texteCorr += `<br> ${num.setRegleSigneProduit(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ')}`\n            // texteCorr += ` $ ${ecritureNombreRelatif(listeNombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nbTermes-1 ; k++) {\n            // texteCorr += `  , $ ${ecritureNombreRelatif(listeNombres[k])} $ est ${num.getSigneString()[k]} `\n            // }\n            // texteCorr += ` et ${lettre} est négatif.`;\n            listeNombres.push(-1)\n            texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Conclusion :')} <br>` + texteEnCouleurEtGras(`Il faut donc que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'négatif' : 'positif'} pour que ${nomExpression} soit ${signeExpression === -1 ? 'négatif' : 'positif'}`, 'black')\n          } else {\n            texteCorr = `<br> Il faut que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'} pour que ${nomExpression} soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n            reponse = signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'\n          }\n          break\n        case 2: // quotient de 2 produits\n          calcul += '\\\\dfrac {' + listeTermes[0]\n          nbNum = randint(2, nbTermes - 2)\n          for (let k = 1; k < nbNum + 1; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          calcul += '}{' + listeTermes[nbNum + 1]\n          for (let denom = nbNum + 2; denom < nbTermes; denom++) {\n            calcul += `\\\\times ${listeTermes[denom]}`\n          }\n          calcul += '}'\n          texte += ` ${nomExpression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            // texteCorr += `$ ${ecritureNombreRelatif(listeNombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nbTermes-1 ; k++) {\n            // texteCorr += `  et $ ${ecritureNombreRelatif(listeNombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ')}`\n            // $ ${ecritureNombreRelatif(listeNombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nbTermes-1 ; k++) {\n            // texteCorr += `  et $ ${ecritureNombreRelatif(listeNombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            listeNombres.push(-1)\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...listeNombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...listeNombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Conclusion :')} <br>` + texteEnCouleurEtGras(`Il faut donc que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'négatif' : 'positif'} pour que ${nomExpression} soit ${signeExpression === -1 ? 'négatif' : 'positif'}`, 'black')\n          } else {\n            texteCorr = `<br> Il faut que $ ${lettre} $ soit ${signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'} pour que ${nomExpression} soit ${signeExpression === -1 ? 'négatif' : 'positif'}.`\n          }\n          reponse = signeExpression === num.getSigneProduitNumber(...listeNombres) ? 'positif' : 'négatif'\n\n          break\n        case 3: // produit avec plusieurs fois la lettre\n          signeLettre = randint(-1, 1, [0])\n          texte = `Donne le signe de ${nomExpression} si $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          nbLettres = randint(1, 3)\n          placeLettre = randint(0, nbTermes - 1)\n          for (let k = 0; k < nbLettres; k++) {\n            listeTermes.splice(placeLettre, 0, lettre)\n          }\n          calcul += `${listeTermes[0]} `\n          for (let k = 1; k < nbTermes + nbLettres; k++) {\n            calcul += `\\\\times ${listeTermes[k]}`\n          }\n          calculNombres = `${listeNombres[0]} `\n          for (let k = 1; k < nbTermes - 1; k++) {\n            calculNombres += `\\\\times ${listeNombres[k]}`\n          }\n          texte += ` ${nomExpression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (nbLettres === 1 || nbLettres === 3) {\n              texteCorr += `On trouve ${nbLettres + 1} fois le facteur $ ${lettre} $.<br> Or ${nbLettres + 1} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calculNombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n              texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quelque soit le signe de $ ${lettre} $.`, 'black')\n            } else {\n              texteCorr += `On trouve ${nbLettres + 1} fois le facteur $ ${lettre} $. <br> Or ${nbLettres + 1} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              if (signeLettre === -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                listeNombres.push(-1)\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`, 'black')\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`, 'black')\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          } else {\n            if (nbLettres === 1 || nbLettres === 3) {\n              texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quelque soit le signe de $ ${lettre} $.<br>`\n            } else {\n              if (signeLettre === -1) {\n                listeNombres.push(-1)\n                texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} si $ ${lettre} $ est négatif.<br>`\n              } else {\n                texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} si $ ${lettre} $ est positif.<br>`\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          }\n          break\n        case 4: // produit avec plusieurs fois la lettre\n          signeLettre = randint(-1, 1, [0])\n          texte = `Donne le signe de ${nomExpression} si $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          expLettre = randint(2, 7)\n          if (placeLettre === 0) {\n            calcul += listeTermes[0] + '^{' + expLettre + '}'\n          } else {\n            calcul += listeTermes[0]\n          }\n          for (let k = 1; k < nbTermes; k++) {\n            if (k === placeLettre) {\n              calcul += '\\\\times ' + listeTermes[k] + '^{' + expLettre + '}'\n            } else {\n              calcul += '\\\\times ' + listeTermes[k]\n            }\n          }\n          calculNombres = `${listeNombres[0]} `\n          for (let k = 1; k < nbTermes - 1; k++) {\n            calculNombres += `\\\\times ${listeNombres[k]}`\n          }\n          texte += ` ${nomExpression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (expLettre % 2 === 0) {\n              texteCorr += `On trouve ${expLettre} fois le facteur $ ${lettre} $.<br> Or ${expLettre} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calculNombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n              texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quelque soit le signe de $ ${lettre} $.`, 'black')\n              reponse = num.getSigneProduitString(...listeNombres)\n            } else {\n              texteCorr += `On trouve ${expLettre} fois le facteur $ ${lettre} $. <br> Or ${expLettre} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signeLettre === -1 ? 'négatif' : 'positif'}.`\n              if (signeLettre === -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                listeNombres.push(-1)\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`, 'black')\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calculNombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...listeNombres)}`\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quand $ ${lettre} $ est ${signeLettre === -1 ? 'négatif' : 'positif'}.`, 'black')\n              }\n              reponse = num.getSigneProduitString(...listeNombres)\n            }\n          } else {\n            if (expLettre % 2 === 0) {\n              texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} quelque soit le signe de $ ${lettre} $.<br>`\n            } else {\n              if (signeLettre === -1) {\n                listeNombres.push(-1)\n                texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} si $ ${lettre} $ est négatif.<br>`\n              } else {\n                texteCorr = `${nomExpression} est ${num.getSigneProduitString(...listeNombres)} si $ ${lettre} $ est positif.<br>`\n              }\n            }\n            reponse = num.getSigneProduitString(...listeNombres)\n          }\n          break\n      }\n      this.autoCorrection[i] = {\n        enonce: texte,\n        options: { ordered: true },\n        propositions: [\n          {\n            texte: 'négatif',\n            statut: reponse === 'négatif'\n          },\n          {\n            texte: 'nul',\n            statut: false\n          },\n          {\n            texte: 'positif',\n            statut: reponse === 'positif'\n          }\n        ]\n      }\n\n      texte += propositionsQcm(this, i).texte\n      if (this.questionJamaisPosee(i, listeTypeDeQuestions[i], ...listeNombres)) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n  this.besoinFormulaireNumerique = [\n    'Niveau de difficulté',\n    5,\n    '1 : Multiplications\\n2 : Quotients \\n3 : Multiplications et quotients \\n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \\n5 : Mélange '\n  ]\n}\n","/**\n *\n *  Classe parente de tous les exercices.\n *\n * @author Rémi Angot\n */\nexport default function Exercice () {\n  // ///////////////////////////////////////////////\n  // Autour de l'exercice\n  // ///////////////////////////////////////////////\n  this.titre = '' // Chaîne de caractère sans point à la fin. C'est le titre de l'exercice qui sera affiché avec la référence dans le générateur d'exercices.\n  this.boutonAide = false // Bouton en haut à droite des questions permettant d'afficher un pdf, texte, image, vidéo, contenu d'un autre site en \"pop-up\" via les fonctions modalXXXXXXX de outils.js.\n  // Ci-dessous des exemples d'utilisation du this.boutonAide.\n  // Noter que pour récupérer le numeroExercice dont il est question, au lieu d'écrire \"this.nouvelleVersion = function () {\" comme d'habitude, on écrit \"this.nouvelleVersion = function (numeroExercice) {\".\n  // this.boutonAide = modalImage(numeroExercice, urlImage, titre, labelBouton = 'Illustration', icone = 'image')\n  // this.boutonAide = modalPdf(numeroExercice, urlPdf, titre='Aide', labelBouton = 'Aide - PDF', icone = 'file pdf')\n  // this.boutonAide = modalTexteCourt(numeroExercice, texte, labelBouton = 'Aide', icone = 'info circle')\n  // this.boutonAide = modalTexteLong(numeroExercice, titre, texte, labelBouton = 'Aide', icone = 'info circle')\n  // this.boutonAide = modalUrl(numeroExercice, url, labelBouton = 'Aide', icone) pour afficher le contenu de url dans un iframe\n  // this.boutonAide = modalVideo(numeroExercice, urlVideo, titre, labelBouton, icone)\n  // this.boutonAide = modalYoutube(numeroExercice, idYoutube, titre, labelBouton = 'Aide - Vidéo', icone = 'youtube')\n\n  // ///////////////////////////////////////////////\n  // Construction de l'exercice\n  // ///////////////////////////////////////////////\n  this.consigne = '' // Chaîne de caractère qui apparaît en gras au-dessus des questions de préférence à l'infinitif et sans point à la fin.\n  this.consigneCorrection = '' // Chaîne de caractère en général vide qui apparaît au-dessus des corrections.\n  this.introduction = '' // Texte qui n'est pas forcément en gras et qui apparaît entre la consigne et les questions.\n  this.listeQuestions = [] // Liste de chaînes de caractères avec chacune correspondant à une question. Chaque question est définie par la méthode this.nouvelleVersion puis `listeDeQuestionToContenu(this)` mettra en forme `this.contenu` et `this.contenuCorrection` suivant `context` (sortie HTML ? diaporama ?...)\n  this.listeCorrections = [] // Idem avec la correction.\n  this.contenu = '' // Chaîne de caractères avec tout l'énoncé de l'exercice construit à partir de `this.listeQuestions` suivant le `context`\n  this.contenuCorrection = '' // Idem avec la correction\n  this.autoCorrection = [] // Liste des objets par question pour correction interactive || export AMC.\n  this.tableauSolutionsDuQcm = [] // Pour sauvegarder les solutions des QCM.\n\n  // ///////////////////////////////////////////////\n  // Mise en forme de l'exercice\n  // ///////////////////////////////////////////////\n  this.spacing = 1 // Interligne des questions\n  this.spacingCorr = 1 // Interligne des réponses\n\n  // ////////////////////////////////////////////\n  // Gestion de la sortie LateX\n  // ////////////////////////////////////////////\n  this.pasDeVersionLatex = false // booléen qui indique qu'une sortie LateX est impossible.\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule.\n  this.consigneModifiable = true // booléen pour déterminer si la consigne est modifiable en ligne dans la sortie LaTeX.\n  this.nbQuestionsModifiable = true // booléen pour déterminer si le nombre de questions est modifiable en ligne.\n  this.nbCols = 1 // Nombre de colonnes pour la sortie LaTeX des questions (environnement multicols).\n  this.nbColsCorr = 1 // Nombre de colonnes pour la sortie LaTeX des réponses (environnement multicols).\n  this.nbColsModifiable = true // booléen pour déterminer si le nombre de colonnes est modifiable en ligne dans la sortie LaTeX.\n  this.nbColsCorrModifiable = true // booléen pour déterminer si le nombre de colonnes de la correction est modifiable en ligne dans la sortie LaTeX.\n  this.spacingModifiable = true // booléen pour déterminer si l'espacement est modifiable en ligne dans la sortie LaTeX.\n  this.spacingCorrModifiable = true // booléen pour déterminer si l'espacement est modifiable en ligne dans la sortie LaTeX.\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n\n  // ////////////////////////////////////////////\n  // Gestion de la sortie autre que LateX\n  // ////////////////////////////////////////////\n  this.beamer = false // booléen pour savoir si la sortie devra être un diaporama beamer\n  this.tailleDiaporama = 1 // Facteur par lequel multiplier la police pour la vue 'diap'\n\n  // ////////////////////////////////////////////\n  // Paramètres\n  // ////////////////////////////////////////////\n  this.nbQuestions = 10 // Nombre de questions par défaut (récupéré dans l'url avec le paramètre `,n=`)\n  this.pointsParQuestions = 1 // Pour définir la note par défaut d'un exercice dans sa sortie Moodle\n  this.correctionDetailleeDisponible = false // booléen qui indique si une correction détaillée est disponible.\n  this.correctionDetaillee = true // booléen indiquant si la correction détaillée doit être affiché par défaut (récupéré dans l'url avec le paramètre `,cd=`).\n  this.correctionIsCachee = false // pour cacher une correction\n  this.video = '' // Chaine de caractère pour un complément numérique (id Youtube, url, code iframe...).\n  // Interactivité\n  this.interactif = false // Exercice sans saisie utilisateur par défaut.\n  this.interactifObligatoire = false // Certains exercices sont uniquement des QCM et n'ont pas de version non interactive.\n  // Ajoute un formulaire de paramétrage par l'utilisateur récupéré via this.sup ou dans le paramètre d'url ',s='\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte, max, tooltip facultatif]\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte, tooltip]\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte]\n  // Ajoute un formulaire de paramétrage par l'utilisateur récupéré via this.sup2 ou dans le paramètre d'url ',s2='\n  this.besoinFormulaire2Numerique = false // Sinon this.besoinFormulaire2Numerique = [texte, max, tooltip facultatif]\n  this.besoinFormulaire2Texte = false // Sinon this.besoinFormulaire2Texte = [texte, tooltip]\n  this.besoinFormulaire2CaseACocher = false // Sinon this.besoinFormulaire2CaseACocher = [texte]\n  // Ajoute un formulaire de paramétrage par l'utilisateur récupéré via this.sup3 ou dans le paramètre d'url ',s3='\n  this.besoinFormulaire3Numerique = false // Sinon this.besoinFormulaire3Numerique = [texte, max, tooltip facultatif]\n  this.besoinFormulaire3Texte = false // Sinon this.besoinFormulaire3Texte = [texte, tooltip]\n  this.besoinFormulaire3CaseACocher = false // Sinon this.besoinFormulaire3CaseACocher = [texte]\n  // Ajoute un formulaire de paramétrage par l'utilisateur récupéré via this.sup4 ou dans le paramètre d'url ',s4='\n  this.besoinFormulaire4Numerique = false // Sinon this.besoinFormulaire4Numerique = [texte, max, tooltip facultatif]\n  this.besoinFormulaire4Texte = false // Sinon this.besoinFormulaire4Texte = [texte, tooltip]\n  this.besoinFormulaire4CaseACocher = false // Sinon this.besoinFormulaire4CaseACocher = [texte]\n\n  // ///////////////////////////////////////////////\n  // Exercice avec des dépendances particulières\n  // ///////////////////////////////////////////////\n  // this.typeExercice = 'MG32' // Pour charger MathGraph32.\n  this.mg32Editable = false // Les figures MG32 ne sont pas interactives par défaut.\n  // this.dimensionsDivMg32 = [500, 450] // Dimensions du SVG créé par MathGraph32.\n\n  // this.typeExercice = 'Scratch' // Pour charger Scratchblocks.\n  // this.typeExercice = 'IEP' // Pour charger InstrumEnPoche.\n  // this.typeExercice = 'dnb' // Ce n’est pas un exercice aléatoire il est traité différemment. Les exercices DNB sont des images pour la sortie Html et du code LaTeX statique pour la sortie latex.\n  // this.typeExercice = 'XCas' // Pour charger le JavaScript de XCas qui provient de https://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html\n  // this.typeExercice = 'simple' // Pour les exercices plus simples destinés aux courses aux nombres\n\n  this.listeArguments = [] // Variable servant à comparer les exercices pour ne pas avoir deux exercices identiques\n\n  /**\n   * Fonction qui est appellée pour chaque exercice\n   * @param {number} numeroExercice numéro de l'exercice utilisé pour avoir des identifiants uniques pour associer un champ avec le bon exercice (pour l'interactivité par exemple)\n   */\n  this.nouvelleVersion = function (numeroExercice) {}\n\n  /**\n   * Compare chaque nouvelle version d'un exercice aux précédentes pour s'assurer de ne pas avoir deux exercices identiques\n   * @param {int} i indice de la question\n   * @param  {...any} args toutes les variables pertinentes qui \"résumeraient\" la question\n   * @returns {boolean} true si la question n'a jamais été posée\n   */\n  this.questionJamaisPosee = function (i, ...args) {\n    if (i === 0) this.listeArguments = []\n    let argsConcatenes = ''\n    for (const arg of args) {\n      if (arg !== undefined) argsConcatenes += arg.toString()\n    }\n    if (this.listeArguments.indexOf(argsConcatenes) > -1) {\n      return false\n    } else {\n      this.listeArguments.push(argsConcatenes)\n      return true\n    }\n  }\n}\n"],"names":["interactifReady","interactifType","amcReady","amcType","titre","ExerciceTableauMultiplicationsRelatifs","Exercice","this","sup","consigne","correctionDetailleeDisponible","correctionDetaillee","spacing","nbQuestions","nbQuestionsModifiable","nouvelleVersion","typesDeQuestionsDisponibles","autoCorrection","parseInt","listeQuestions","listeCorrections","listeTypeDeQuestions","combinaisonListes","texte","texteCorr","nbLettres","nbNum","expLettre","reponse","i","cpt","nbMax","num","Relatif","randint","lettreTab","lettre","length","nomExpression","lettreDepuisChiffre","signeExpression","nbTermes","placeLettre","listeNombres","relatifs","slice","listeTermes","indice","push","ecritureNombreRelatif","splice","signeLettre","calculNombres","calcul","texteEnCouleurEtGras","k","setRegleSigneProduit","getSigneProduitString","getSigneProduitNumber","denom","setRegleSigneQuotient","enonce","options","ordered","propositions","statut","propositionsQcm","questionJamaisPosee","listeQuestionsToContenu","besoinFormulaireNumerique","boutonAide","consigneCorrection","introduction","contenu","contenuCorrection","tableauSolutionsDuQcm","spacingCorr","pasDeVersionLatex","listePackages","consigneModifiable","nbCols","nbColsCorr","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","beamer","tailleDiaporama","pointsParQuestions","correctionIsCachee","video","interactif","interactifObligatoire","besoinFormulaireTexte","besoinFormulaireCaseACocher","besoinFormulaire2Numerique","besoinFormulaire2Texte","besoinFormulaire2CaseACocher","besoinFormulaire3Numerique","besoinFormulaire3Texte","besoinFormulaire3CaseACocher","besoinFormulaire4Numerique","besoinFormulaire4Texte","besoinFormulaire4CaseACocher","mg32Editable","listeArguments","numeroExercice","args","argsConcatenes","arg","undefined","toString","indexOf"],"sourceRoot":""}