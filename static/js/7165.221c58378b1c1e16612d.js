(self.webpackChunkmathalea=self.webpackChunkmathalea||[]).push([[7165,7567],{67567:(e,i,t)=>{"use strict";function s(){this.titre="",this.consigne="",this.consigneCorrection="",this.listeQuestions=[],this.listeCorrections=[],this.introduction="",this.contenu="",this.contenuCorrection="",this.nbQuestions=10,this.nbCols=2,this.nbColsCorr=2,this.spacing=1,this.spacingCorr=1,this.beamer=!1,this.besoinFormulaireNumerique=!1,this.besoinFormulaireTexte=!1,this.besoinFormulaireCaseACocher=!1,this.consigneModifiable=!0,this.nbQuestionsModifiable=!0,this.nbColsModifiable=!0,this.nbColsCorrModifiable=!0,this.spacingModifiable=!0,this.spacingCorrModifiable=!0,this.correctionDetailleeDisponible=!1,this.correctionDetaillee=!0,this.video="",this.boutonAide=!1,this.tailleDiaporama=50,this.pasDeVersionLatex=!1,this.qcm=!1,this.qcmDisponible=!1,this.modeQcm=!1,this.mg32Editable=!1,this.nouvelleVersion=function(e){},this.listePackages=[]}t.r(i),t.d(i,{default:()=>s})},57165:(e,i,t)=>{"use strict";t.r(i),t.d(i,{titre:()=>o,default:()=>r});var s=t(67567),n=t(24477);const o="Multiplications et quotients de relatifs : signe avec une lettre";function r(){s.default.call(this),this.sup=3,this.titre=o,this.consigne="",this.correctionDetailleeDisponible=!0,this.correctionDetaillee=!1,this.spacing=2,this.nbQuestions=3,this.nbQuestionsModifiable=!0,this.nouvelleVersion=function(){let e;switch(this.sup=parseInt(this.sup),this.listeQuestions=[],this.listeCorrections=[],this.sup){case 1:e=[1];break;case 2:e=[2];break;case 3:e=[1,2];break;case 4:e=[3,4];break;case 5:e=[1,2,3,4]}let i=(0,n.SRM)(e,this.nbQuestions);for(let e,t,s=0,o=0;s<this.nbQuestions&&o<50;){let r=20,$=new n.Mjk((0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r)),l=["n","x","y","a","m"],u=l[(0,n.nSR)(0,l.length-1)],a=(0,n.Gag)(s+1),g=(0,n.nSR)(-1,1,[0]),b=1==i[s]?(0,n.nSR)(3,5):(0,n.nSR)(4,6),c=(0,n.nSR)(0,b-1),p=$.relatifs.slice(0,b-1),f=[];for(let e=0;e<p.length;e++)f.push((0,n.aIp)(p[e]));f.splice(c,0,u);let d,h,S="";switch(e=`Donne le signe de $ ${u} $ pour que ${a} soit ${-1==g?"negatif":"positif"}. <br>`,t=`${(0,n.MZ9)("Supposons que "+u+" soit positif : ")}`,i[s]){case 1:S+=`${f[0]} `;for(let e=1;e<b;e++)S+=`\\times ${f[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?(p.push(1),t+=`<br> ${$.setRegleSigneProduit(...p)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,p.push(-1),t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):t=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 2:S+="\\dfrac {"+f[0];let i=(0,n.nSR)(2,b-2);for(let e=1;e<i+1;e++)S+=`\\times ${f[e]}`;S+="}{"+f[i+1];for(let e=i+2;e<b;e++)S+=`\\times ${f[e]}`;S+="}",e+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?(t+=`<br> ${$.setRegleSigneQuotient(...p)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,p.push(-1),t+=`<br> ${$.setRegleSigneQuotient(...p)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...p),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):t=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...p)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 3:d=(0,n.nSR)(-1,1,[0]),e=`Donne le signe de ${a} si $ ${u} $ est ${-1==d?"négatif":"positif"}. <br>`,t="";let s=(0,n.nSR)(1,3);c=(0,n.nSR)(0,b-1);for(let e=0;e<s;e++)f.splice(c,0,u);S+=`${f[0]} `;for(let e=1;e<b+s;e++)S+=`\\times ${f[e]}`;h=`${p[0]} `;for(let e=1;e<b-1;e++)h+=`\\times ${p[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?1==s||3==s?(t+=`On trouve ${s+1} fois le facteur $ ${u} $.<br> Or ${s+1} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.`,"black")):(t+=`On trouve ${s+1} fois le facteur $ ${u} $. <br> Or ${s+1} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==d?"négatif":"positif"}.`,-1==d?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,p.push(-1),t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black")):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black"))):1==s||3==s?t=`${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.<br>`:-1==d?(p.push(-1),t=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est négatif.<br>`):t=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est positif.<br>`;break;case 4:d=(0,n.nSR)(-1,1,[0]),e=`Donne le signe de ${a} si $ ${u} $ est ${-1==d?"négatif":"positif"}. <br>`,t="";let o=(0,n.nSR)(2,7);S+=0==c?f[0]+"^{"+o+"}":f[0];for(let e=1;e<b;e++)S+=e==c?"\\times "+f[e]+"^{"+o+"}":"\\times "+f[e];h=`${p[0]} `;for(let e=1;e<b-1;e++)h+=`\\times ${p[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correctionDetaillee?o%2==0?(t+=`On trouve ${o} fois le facteur $ ${u} $.<br> Or ${o} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.`,"black")):(t+=`On trouve ${o} fois le facteur $ ${u} $. <br> Or ${o} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==d?"négatif":"positif"}.`,-1==d?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,p.push(-1),t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black")):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...p)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...p)} quand $ ${u} $ est ${-1==d?"négatif":"positif"}.`,"black"))):o%2==0?t=`${a} est ${$.getSigneProduitString(...p)} quelque soit le signe de $ ${u} $.<br>`:-1==d?(p.push(-1),t=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est négatif.<br>`):t=`${a} est ${$.getSigneProduitString(...p)} si $ ${u} $ est positif.<br>`}-1==this.listeQuestions.indexOf(e)&&(this.listeQuestions.push(e),this.listeCorrections.push(t),s++),o++}(0,n.K1R)(this)},this.besoinFormulaireNumerique=["Niveau de difficulté",3,"1 : Multiplications\n2 : Quotients \n3 : Multiplications et quotients \n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \n5 : Mélange "]}}}]);