(self.webpackChunkmathalea=self.webpackChunkmathalea||[]).push([[7165,7567],{67567:(e,i,t)=>{"use strict";function s(){this.titre="",this.consigne="",this.consigne_correction="",this.liste_questions=[],this.liste_corrections=[],this.introduction="",this.contenu="",this.contenu_correction="",this.nb_questions=10,this.nb_cols=2,this.nb_cols_corr=2,this.spacing=1,this.spacing_corr=1,this.beamer=!1,this.besoin_formulaire_numerique=!1,this.besoin_formulaire_texte=!1,this.besoin_formulaire_case_a_cocher=!1,this.consigne_modifiable=!0,this.nb_questions_modifiable=!0,this.nb_cols_modifiable=!0,this.nb_cols_corr_modifiable=!0,this.spacing_modifiable=!0,this.spacing_corr_modifiable=!0,this.correction_detaillee_disponible=!1,this.correction_detaillee=!0,this.video="",this.bouton_aide=!1,this.tailleDiaporama=50,this.pas_de_version_LaTeX=!1,this.QCM=!1,this.QCM_disponible=!1,this.ModeQCM=!1,this.MG32editable=!1,this.nouvelle_version=function(e){},this.liste_packages=[]}t.r(i),t.d(i,{default:()=>s})},57165:(e,i,t)=>{"use strict";t.r(i),t.d(i,{titre:()=>o,default:()=>r});var s=t(67567),n=t(24477);const o="Multiplications et quotients de relatifs : signe avec une lettre";function r(){s.default.call(this),this.sup=3,this.titre=o,this.consigne="",this.correction_detaillee_disponible=!0,this.correction_detaillee=!1,this.spacing=2,this.nb_questions=3,this.nb_questions_modifiable=!0,this.nouvelle_version=function(){let e;switch(this.sup=parseInt(this.sup),this.liste_questions=[],this.liste_corrections=[],this.sup){case 1:e=[1];break;case 2:e=[2];break;case 3:e=[1,2];break;case 4:e=[3,4];break;case 5:e=[1,2,3,4]}let i=(0,n._97)(e,this.nb_questions);for(let e,t,s=0,o=0;s<this.nb_questions&&o<50;){let r=20,$=new n.Mjk((0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r),(0,n.nSR)(-1,1,[0])*(0,n.nSR)(1,r)),l=["n","x","y","a","m"],u=l[(0,n.nSR)(0,l.length-1)],a=(0,n.NTq)(s+1),g=(0,n.nSR)(-1,1,[0]),b=1==i[s]?(0,n.nSR)(3,5):(0,n.nSR)(4,6),c=(0,n.nSR)(0,b-1),d=$.relatifs.slice(0,b-1),f=[];for(let e=0;e<d.length;e++)f.push((0,n.GCJ)(d[e]));f.splice(c,0,u);let p,h,S="";switch(e=`Donne le signe de $ ${u} $ pour que ${a} soit ${-1==g?"negatif":"positif"}. <br>`,t=`${(0,n.MZ9)("Supposons que "+u+" soit positif : ")}`,i[s]){case 1:S+=`${f[0]} `;for(let e=1;e<b;e++)S+=`\\times ${f[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correction_detaillee?(d.push(1),t+=`<br> ${$.setRegleSigneProduit(...d)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...d),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,d.push(-1),t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...d),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...d)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):t=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...d)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 2:S+="\\dfrac {"+f[0];let i=(0,n.nSR)(2,b-2);for(let e=1;e<i+1;e++)S+=`\\times ${f[e]}`;S+="}{"+f[i+1];for(let e=i+2;e<b;e++)S+=`\\times ${f[e]}`;S+="}",e+=` ${a} = $ ${S} $ <br>`,this.correction_detaillee?(t+=`<br> ${$.setRegleSigneQuotient(...d)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est positif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...d),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Supposons maintenant que "+u+" soit négatif : ")}`,d.push(-1),t+=`<br> ${$.setRegleSigneQuotient(...d)}`,t+=`<br><br> Donc si ${(0,n.MZ9)(u+" est négatif","black")} $ ${S} $ est ${(0,n.MZ9)($.getSigneProduitString(...d),"black")}.`,t+=`<br><br> ${(0,n.MZ9)("Conclusion :")} <br>`+(0,n.MZ9)(`Il faut donc que $ ${u} $ soit ${g==$.getSigneProduitNumber(...d)?"négatif":"positif"} pour que ${a} soit ${-1==g?"négatif":"positif"}`,"black")):t=`<br> Il faut que $ ${u} $ soit ${g==$.getSigneProduitNumber(...d)?"positif":"négatif"} pour que ${a} soit ${-1==g?"négatif":"positif"}.`;break;case 3:p=(0,n.nSR)(-1,1,[0]),e=`Donne le signe de ${a} si $ ${u} $ est ${-1==p?"négatif":"positif"}. <br>`,t="";let s=(0,n.nSR)(1,3);c=(0,n.nSR)(0,b-1);for(let e=0;e<s;e++)f.splice(c,0,u);S+=`${f[0]} `;for(let e=1;e<b+s;e++)S+=`\\times ${f[e]}`;h=`${d[0]} `;for(let e=1;e<b-1;e++)h+=`\\times ${d[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correction_detaillee?1==s||3==s?(t+=`On trouve ${s+1} fois le facteur $ ${u} $.<br> Or ${s+1} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quelque soit le signe de $ ${u} $.`,"black")):(t+=`On trouve ${s+1} fois le facteur $ ${u} $. <br> Or ${s+1} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==p?"négatif":"positif"}.`,-1==p?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,d.push(-1),t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quand $ ${u} $ est ${-1==p?"négatif":"positif"}.`,"black")):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quand $ ${u} $ est ${-1==p?"négatif":"positif"}.`,"black"))):1==s||3==s?t=`${a} est ${$.getSigneProduitString(...d)} quelque soit le signe de $ ${u} $.<br>`:-1==p?(d.push(-1),t=`${a} est ${$.getSigneProduitString(...d)} si $ ${u} $ est négatif.<br>`):t=`${a} est ${$.getSigneProduitString(...d)} si $ ${u} $ est positif.<br>`;break;case 4:p=(0,n.nSR)(-1,1,[0]),e=`Donne le signe de ${a} si $ ${u} $ est ${-1==p?"négatif":"positif"}. <br>`,t="";let o=(0,n.nSR)(2,7);S+=0==c?f[0]+"^{"+o+"}":f[0];for(let e=1;e<b;e++)S+=e==c?"\\times "+f[e]+"^{"+o+"}":"\\times "+f[e];h=`${d[0]} `;for(let e=1;e<b-1;e++)h+=`\\times ${d[e]}`;e+=` ${a} = $ ${S} $ <br>`,this.correction_detaillee?o%2==0?(t+=`On trouve ${o} fois le facteur $ ${u} $.<br> Or ${o} est pair donc leur produit sera positif.`,t+=`<br>Le signe de l'expression a donc le signe de : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quelque soit le signe de $ ${u} $.`,"black")):(t+=`On trouve ${o} fois le facteur $ ${u} $. <br> Or ${o} est impair donc leur produit est du signe de $ ${u} $ soit ${-1==p?"négatif":"positif"}.`,-1==p?(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,d.push(-1),t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quand $ ${u} $ est ${-1==p?"négatif":"positif"}.`,"black")):(t+=`<br>Le signe de l'expression a donc le signe opposé à : $ ${h} $`,t+=`<br><br> ${$.setRegleSigneProduit(...d)}`,t+="<br><br>"+(0,n.MZ9)(`Donc ${a} est ${$.getSigneProduitString(...d)} quand $ ${u} $ est ${-1==p?"négatif":"positif"}.`,"black"))):o%2==0?t=`${a} est ${$.getSigneProduitString(...d)} quelque soit le signe de $ ${u} $.<br>`:-1==p?(d.push(-1),t=`${a} est ${$.getSigneProduitString(...d)} si $ ${u} $ est négatif.<br>`):t=`${a} est ${$.getSigneProduitString(...d)} si $ ${u} $ est positif.<br>`}-1==this.liste_questions.indexOf(e)&&(this.liste_questions.push(e),this.liste_corrections.push(t),s++),o++}(0,n.KsX)(this)},this.besoin_formulaire_numerique=["Niveau de difficulté",3,"1 : Multiplications\n2 : Quotients \n3 : Multiplications et quotients \n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \n5 : Mélange "]}}}]);