{"version":3,"sources":["webpack://mathalea/./src/js/exercices/Exercice.js","webpack://mathalea/./src/js/modules/3d.js"],"names":["Exercice","this","titre","consigne","consigneCorrection","listeQuestions","listeCorrections","introduction","contenu","contenuCorrection","nbQuestions","nbCols","nbColsCorr","spacing","spacingCorr","beamer","besoinFormulaireNumerique","besoinFormulaireTexte","besoinFormulaireCaseACocher","consigneModifiable","nbQuestionsModifiable","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","correctionDetailleeDisponible","correctionDetaillee","video","boutonAide","tailleDiaporama","pasDeVersionLatex","interactif","interactifObligatoire","qcm","qcmDisponible","modeQcm","autoCorrection","tableauSolutionsDuQcm","mg32Editable","nouvelleVersion","numeroExercice","listePackages","math","matrix","multiply","norm","cross","dot","numId","ObjetMathalea2D","positionLabel","isVisible","color","style","styleTikz","epaisseur","opacite","pointilles","id","context","Point3d","constructor","x3d","y3d","z3d","visible","label","alpha","Math","PI","rapport","MT","cos","sin","V","W","p2d","point","_data","point3d","Vecteur3d","args","length","matrice","norme","sqrt","vecteur","representant","A","B","translation3d","vecteur3d","Arete3d","point1","point2","extremite1","extremite2","segment","arete3d","p1","p2","Droite3d","point3D","vecteur3D","directeur","origine","M","droite","droite3d","demicercle3d","centre","normal","rayon","cote","angledepart","demiCercle","signe","listepoints","d","push","rotation3d","i","polyline","cercle3d","C","polygone","Polygone3d","Array","isArray","listePoints","segments3d","segments","aretes","polygone3d","Sphere3d","nb_paralleles","nb_meridiens","call","objets","c1","c2","c3","c4","D","prodvec","rayon2","R","cote1","cote2","rayon3","k","rotationV3d","svg","coeff","code","objet","tikz","sphere3d","Cone3d","centrebase","sommet","generatrices","s","color1","color2","cone3d","Cylindre3d","centrebase1","centrebase2","rayon1","cylindre3d","Cube","x","y","z","beta","colorD","colorT","colorG","proj","cosa","sina","cosb","sinb","p","lstPoints","lstPolygone","opaciteDeRemplissage","couleurDeRemplissage","svgml","amp","tikzml","cube","angle","unitaire","u","v","w","c","droite3D","SensDeRotation3d","axe","N","sensDeRotation3d"],"mappings":"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","file":"js/3752.91960e6675603646321d.js","sourcesContent":["/**\n *\n *  Classe parente de tous les exercices\n *\n * @author Rémi Angot\n */\nexport default function Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = ''\n  this.consigne = ''\n  this.consigneCorrection = ''\n  this.listeQuestions = []\n  this.listeCorrections = []\n  this.introduction = ''\n  this.contenu = ''\n  this.contenuCorrection = ''\n  this.nbQuestions = 10\n  this.nbCols = 2\n  this.nbColsCorr = 2\n  this.spacing = 1\n  this.spacingCorr = 1\n  this.beamer = false\n\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte];\n  this.consigneModifiable = true\n  this.nbQuestionsModifiable = true\n  this.nbColsModifiable = true\n  this.nbColsCorrModifiable = true\n  this.spacingModifiable = true\n  this.spacingCorrModifiable = true\n  this.correctionDetailleeDisponible = false\n  this.correctionDetaillee = true\n  this.video = ''\n  this.boutonAide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,labelBouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,labelBouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,idYoutube,texte,labelBouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,urlPdf,texte=\"Aide\",labelBouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pasDeVersionLatex = false\n  this.interactif = false // Exercice sans saisie utilisateur par défaut\n  this.interactifObligatoire = false // Certains exercices sont uniquement des QCM et n'ont pas de version non interactiveout\n  this.qcm = false // Pour les exercices de type QCM : contient un tableau.\n  this.qcmDisponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n  this.modeQcm = false // Pour choisir la version QCM ou la version classique (false = version classique)\n  this.autoCorrection = [] // Liste des objets par question pour correction interactive || export AMC\n  this.tableauSolutionsDuQcm = [] // Pour sauvegarder les solutions des QCM\n  this.mg32Editable = false // pas d'interface par défaut pour les figures MG32\n  this.nouvelleVersion = function (numeroExercice) {}\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n","import { point, vecteur, droite, segment, polyline, polygone } from './2d.js'\nimport { matrix, multiply, norm, cross, dot } from 'mathjs'\nimport { context } from './context.js'\nconst math = { matrix: matrix, multiply: multiply, norm: norm, cross: cross, dot: dot }\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @author Rémi Angot\n */\nlet numId = 0\nfunction ObjetMathalea2D () {\n  this.positionLabel = 'above'\n  this.isVisible = true\n  this.color = 'black'\n  this.style = '' // stroke-dasharray=\"4 3\" pour des hachures //stroke-width=\"2\" pour un trait plus épais\n  this.styleTikz = ''\n  this.epaisseur = 1\n  this.opacite = 1\n  this.pointilles = false\n  this.id = numId\n  numId++\n  //   mesObjets.push(this);\n  context.objets2D.push(this)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * LE POINT\n *\n* @author Jean-Claude Lhote\n* Point de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n* le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n*/\nclass Point3d {\n  constructor (x3d, y3d, z3d, visible, label) {\n    const alpha = context.anglePerspective * Math.PI / 180\n    const rapport = context.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    this.x3d = x3d\n    this.y3d = y3d\n    this.z3d = z3d\n    this.visible = visible\n    this.label = label\n    const V = math.matrix([this.x3d, this.y3d, this.z3d])\n    const W = math.multiply(MT, V)\n    this.p2d = point(W._data[0], W._data[1], this.label)\n  }\n}\nexport function point3d (x3d, y3d, z3d = 0, visible = true, label = '') {\n  return new Point3d(x3d, y3d, z3d, visible, label)\n}\n\n/**\n   * LE VECTEUR\n   *\n   * @author Jean-Claude Lhote\n   * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n   * On les utilise dans tous les objets complexeimport Additionner_soustraires_decimaux from '../exercices/6e/6C20';\ns et dans toutes les transformations.import Nature_polygone from './../exercices/2e/2G12';\nimport Exercice_fractions_decomposer from './../exercices/6e/6N20';\n\n   * Ils servent notament à définir la direction des plans.\n   *\n   * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n   * A et B sont deux objets de type Point3d\n   * x,y et z sont trois nombres\n   * la commande math.matrix([x,y,z]) crée une matrice colonne.\n   *\n   * L'objet créé est de type Vecteur3d\n   * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n   * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n   */\nclass Vecteur3d {\n  constructor (...args) {\n    const alpha = context.anglePerspective * Math.PI / 180\n    const rapport = context.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    if (args.length == 2) {\n      this.x3d = args[1].x3d - args[0].x3d\n      this.y3d = args[1].y3d - args[0].y3d\n      this.z3d = args[1].z3d - args[0].z3d\n    } else {\n      if (typeof (args[0]) === 'number') {\n        this.x3d = args[0]\n        this.y3d = args[1]\n        this.z3d = args[2]\n      } else if (args.length == 1) {\n        this.x3d = args[0]._data[0]\n        this.y3d = args[0]._data[1]\n        this.z3d = args[0]._data[2]\n      }\n    }\n    this.matrice = math.matrix([this.x3d, this.y3d, this.z3d])\n    this.norme = Math.sqrt(this.x3d**2+this.y3d**2+this.z3d**2)\n    const W = math.multiply(MT, this.matrice)\n    this.p2d = vecteur(W._data[0], W._data[1])\n    this.representant = function (A) {\n      const B = translation3d(A, this)\n      return vecteur(A.p2d, B.p2d).representant(A.p2d)\n    }\n  }\n}\n\nexport function vecteur3d (...args) { // A,B deux Point3d ou x,y,z les composantes du vecteur\n  return new Vecteur3d(...args)\n}\n\n/**\n   * L'ARETE\n   * @author Jean-Claude lhote\n   *\n   *\n   *\n   */\nclass Arete3d {\n  constructor (point1, point2, color) {\n    this.extremite1 = point1\n    this.extremite2 = point2\n    this.color = color\n    if (!point1.visible || !point2.visible) {\n      this.visible = false\n    } else {\n      this.visible = true\n    }\n    this.p2d = segment(point1.p2d, point2.p2d, color)\n    if (!this.visible) {\n      this.p2d.pointilles = 2\n    } else {\n      this.p2d.pointilles = false\n    }\n  }\n}\nexport function arete3d (p1, p2, color = 'black') {\n  return new Arete3d(p1, p2, color)\n}\n\n/**\n   * LA DROITE\n   *\n   * @author Jean-claude Lhote\n   * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n   * Droite de l'espace définie par 2 points droite3d(A,B)\n   * Les droites servent principalement à définir des axes de rotation dans l'espace\n   */\nclass Droite3d {\n  constructor (point3D, vecteur3D) {\n    if (vecteur3D.constructor == Vecteur3d) {\n      this.directeur = vecteur3D\n    } else if (vecteur3D.constructor == Point3d) {\n      this.directeur = vecteur3d(point3D, vecteur3D)\n    }\n    this.origine = point3D\n    const M = translation3d(this.origine, this.directeur)\n    this.point = M\n    this.p2d = droite(this.origine.p2d, M.p2d) // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n    this.p2d.isVisible = false\n  }\n}\n\nexport function droite3d (point3D, vecteur3D) {\n  return new Droite3d(point3D, vecteur3D)\n}\n\n/**\n * LE DEMI-CERCLE\n *\n *@author Jean-Claude Lhote\n * Le nom est trompeur, il s'agit le plus souvent d'une demi-ellipse représentant un cercle projeté\n * Utilisé pour représenter un cercle dont une moitié est visible mais pas l'autre.\n *\n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible' et déterminera dans quel sens on crée le demi-cercle.\n * Si cote='caché' alors on tourne dans le sens direct et le tracé est en pointillés\n * Si cote='visible' alors on tourne dans le sens indirect et le tracé est plein.\n *\n */\nexport function demicercle3d (centre, normal, rayon, cote, color, angledepart = context.anglePerspective) {\n  let demiCercle; let signe; const M = []; const listepoints = []\n  if (cote == 'caché') {\n    signe = 1\n  } else {\n    signe = -1\n  }\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart))\n  listepoints.push(M[0].p2d)\n\n  for (let i = 1; i < 19; i++) {\n    M.push(rotation3d(M[i - 1], d, 10 * signe))\n    listepoints.push(M[i].p2d)\n  }\n  demiCercle = polyline(listepoints, color)\n  if (cote == 'caché') {\n    demiCercle.pointilles = 2\n    demiCercle.opacite = 0.3\n  }\n  return demiCercle\n}\n\n/**\n    * LE CERCLE\n    *\n    * @author Jean-Claude Lhote\n    *\n    * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n    * visible est un booléen\n    *\n    */\nexport function cercle3d (centre, normal, rayon, visible = true, color = 'black') {\n  let C; const M = []; const listepoints = []\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, context.anglePerspective))\n  listepoints.push(M[0].p2d)\n  for (let i = 1; i < 37; i++) {\n    M.push(rotation3d(M[i - 1], d, 10))\n    listepoints.push(M[i].p2d)\n  }\n  C = polygone(listepoints, color)\n  if (!visible) {\n    C.pointilles = 2\n  }\n  return C\n}\n\n/**\n   * LE POLYGONE\n   *\n   * @author Jean-Claude Lhote\n   * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n   */\nclass Polygone3d {\n  constructor (...args) {\n    if (Array.isArray(args[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = args[0]\n      if (args[1]) {\n        this.color = args[1]\n      }\n    } else {\n      this.listePoints = args\n      this.color = 'black'\n    }\n    const segments3d = []; let A; const segments = []\n    A = this.listePoints[0]\n    for (let i = 1; i < this.listePoints.length; i++) {\n      segments3d.push(arete3d(A, this.listePoints[i], this.color))\n      segments.push(segments3d[i - 1].p2d)\n      A = this.listePoints[i]\n    }\n    segments3d.push(arete3d(A, this.listePoints[0], this.color))\n    segments.push(segments3d[this.listePoints.length - 1].p2d)\n    this.aretes = segments3d\n    this.p2d = segments\n  }\n}\n\nexport function polygone3d (...args) {\n  return new Polygone3d(...args)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE COMPLEXES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA SPHERE\n   *\n   * @author Jean-Claude Lhote\n   * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n   * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n   * @param {Point3d} centre\n   * @param {Number} rayon\n   * @param {Number} nb_paralleles\n   * @param {Number} nb_meridiens\n   * @param {string} color\n   */\nfunction Sphere3d (centre, rayon, nb_paralleles, nb_meridiens, color) {\n  ObjetMathalea2D.call(this)\n  this.centre = centre\n  this.rayon = vecteur3d(rayon, 0, 0)\n  this.normal = vecteur3d(0, 0, 1)\n  this.color = color\n  this.nb_meridiens = nb_meridiens\n  this.nb_paralleles = nb_paralleles\n  const objets = []; let c1; let c2; let c3; let c4; let C; let D\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon.matrice))\n  const rayon2 = vecteur3d(math.cross(this.rayon.matrice, math.multiply(prodvec.matrice, 1 / math.norm(prodvec.matrice))))\n  const R = rayon\n  const cote1 = 'caché'\n  const cote2 = 'visible'\n  // objets.push(cercle3d(this.centre,rotationV3d(prodvec,this.normal,context.anglePerspective),rotationV3d(this.rayon,this.normal,context.anglePerspective),true,this.color))\n  for (let k = 0, rayon3; k < 1; k += 1 / (this.nb_paralleles + 1)) {\n    C = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(k * Math.PI / 2))\n    D = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(-k * Math.PI / 2))\n    rayon3 = vecteur3d(R * Math.cos(k * Math.PI / 2), 0, 0)\n    c1 = demicercle3d(C, this.normal, rayon3, cote1, this.color, context.anglePerspective)\n    c2 = demicercle3d(C, this.normal, rayon3, cote2, this.color, context.anglePerspective)\n    c3 = demicercle3d(D, this.normal, rayon3, cote1, this.color, context.anglePerspective)\n    c4 = demicercle3d(D, this.normal, rayon3, cote2, this.color, context.anglePerspective)\n    objets.push(c1, c2, c3, c4)\n  }\n  for (let k = 0, V, W; k < 1; k += 1 / this.nb_meridiens) {\n    V = rotationV3d(prodvec, this.normal, 90 + context.anglePerspective + k * 90)\n    W = rotationV3d(prodvec, this.normal, 90 + context.anglePerspective - (k + 1 / this.nb_meridiens) * 90)\n    c1 = demicercle3d(this.centre, V, rayon2, cote2, this.color, 0)\n    c2 = demicercle3d(this.centre, V, rayon2, cote1, this.color, 0)\n    c3 = demicercle3d(this.centre, W, rayon2, cote2, this.color, 0)\n    c4 = demicercle3d(this.centre, W, rayon2, cote1, this.color, 0)\n    objets.push(c1, c2, c3, c4)\n  }\n\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sphere3d (centre, rayon, nb_paralleles, nb_meridiens, color = 'black') {\n  return new Sphere3d(centre, rayon, nb_paralleles, nb_meridiens, color)\n}\n\n/**\n    * LE CONE\n    *\n    * @author Jean-Claude Lhote\n    *\n    * centrebase est le centre du disque de base\n    * sommet est le sommet du cône\n    * normal est un vecteur 3d normal au plan du disque (il détermine avec rayon de quel côté se trouve la partie visible)\n    *\n    */\nfunction Cone3d (centrebase, sommet, normal, rayon, generatrices = 18) {\n  ObjetMathalea2D.call(this)\n  this.sommet = sommet\n  this.centrebase = centrebase\n  this.normal = normal\n  this.rayon = vecteur3d(rayon,0,0)\n  const objets = []; let c1; let c2; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(normal.matrice, this.rayon.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = 'gray'\n    cote2 = 'visible'\n    color2 = 'black'\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = 'black'\n    color2 = 'gray'\n  }\n  c1 = demicercle3d(this.centrebase, this.normal, this.rayon, cote1, color1)\n  c2 = demicercle3d(this.centrebase, this.normal, this.rayon, cote2, color2)\n\n  for (let i = 0; i < c1.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = segment(this.sommet.p2d, c1.listePoints[i])\n      if (cote1 == 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  for (let i = 0; i < c2.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = segment(this.sommet.p2d, c2.listePoints[i])\n      if (cote2 == 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  objets.push(c1, c2)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cone3d (centre, sommet, normal, rayon, generatrices = 18) {\n  return new Cone3d(centre, sommet, normal, rayon, generatrices)\n}\n\n/**\n   * LE CYLINDRE\n   *\n   * @author Jean-Claude Lhote\n   * Crée un cylindre de révolution définit par les centres de ses 2 bases\n   * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes\n   * @param {Point3d} centrebase1\n   * @param {Point3d} centrebase2\n   * @param {Vecteur3d} normal\n   * @param {Vecteur3d} rayon1\n   * @param {Vecteur3d} rayon2\n   */\nfunction Cylindre3d (centrebase1, centrebase2, normal, rayon1, rayon2, color) {\n  ObjetMathalea2D.call(this)\n  this.centrebase1 = centrebase1\n  this.centrebase2 = centrebase2\n  this.normal = normal\n  this.rayon1 = rayon1\n  this.rayon2 = rayon2\n  this.color = color\n  const objets = []; let c1; let c2; let c3; let c4; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon1.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = this.color\n    cote2 = 'visible'\n    color2 = this.color\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = this.color\n    color2 = this.color\n  }\n  c1 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote1, color1)\n  c3 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote1, color1)\n  c2 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote2, color2)\n  c4 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote2, color2)\n  c3.pointilles = false\n  c3.color = this.color\n  for (let i = 0; i < c1.listePoints.length; i += 2) {\n    s = segment(c3.listePoints[i], c1.listePoints[i])\n    if (cote1 == 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  for (let i = 0; i < c2.listePoints.length; i += 2) {\n    s = segment(c4.listePoints[i], c2.listePoints[i])\n    if (cote2 == 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  objets.push(c1, c2, c3, c4)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cylindre3d (centrebase1, centrebase2, normal, rayon, rayon2, color = 'black') {\n  return new Cylindre3d(centrebase1, centrebase2, normal, rayon, rayon2, color)\n}\n\n/**\n   * LE PRISME\n   *\n   * @author Jean-Claude Lhote\n   * Crée un prisme à partir du base Polygone3d et d'un vecteur3d d'extrusion (on peut faire des prismes droits ou non droits)\n   */\nclass Prisme3d {\n  constructor (base, vecteur, color) {\n    ObjetMathalea2D.call(this)\n\n    this.color = color\n    base.color = color\n    this.base1 = base\n    this.base2 = translation3d(base, vecteur)\n    this.base2.color = this.base1.color\n    this.aretes = []\n    const objets = []; let s\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      objets.push(this.base1.p2d[i])\n    }\n    for (let i = 0; i < this.base2.listePoints.length; i++) {\n      objets.push(this.base2.p2d[i])\n    }\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      s = arete3d(this.base1.listePoints[i], this.base2.listePoints[i], this.color)\n      objets.push(s.p2d)\n    }\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.tikz()\n      }\n      return code\n    }\n  }\n}\n\nexport function prisme3d (base, vecteur, color = 'black') {\n  return new Prisme3d(base, vecteur, color)\n}\n\n/**\n   * LE cube\n   * @author Jean-Claude Lhote\n   * usage : cube(x,y,z,c,color) construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z.\n   * le face avant est dans le plan xz\n   *\n*/\nclass Cube3d {\n  constructor (x, y, z, c, color = 'black') {\n    let faceAV, faceDr, faceTOP\n    const A = point3d(x, y, z)\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n    const B = translation3d(A, vx)\n    const C = translation3d(B, vz)\n    const D = translation3d(A, vz)\n    const E = translation3d(A, vy)\n    const F = translation3d(E, vx)\n    const G = translation3d(F, vz)\n    const H = translation3d(D, vy)\n    faceAV = polygone([A.p2d, B.p2d, C.p2d, D.p2d], color)\n    faceDr = polygone([B.p2d, F.p2d, G.p2d, C.p2d], color)\n    faceTOP = polygone([D.p2d, C.p2d, G.p2d, H.p2d], color)\n    faceAV.couleurDeRemplissage = '#A9A9A9'\n    faceTOP.couleurDeRemplissage = 'white'\n    faceDr.couleurDeRemplissage = '#A5C400'\n    this.svg = function (coeff) {\n      return faceAV.svg(coeff) + '\\n' + faceTOP.svg(coeff) + '\\n' + faceDr.svg(coeff)\n    }\n    this.tikz = function () {\n      return faceAV.tikz() + '\\n' + faceTOP.tikz() + '\\n' + faceDr.tikz()\n    }\n  }\n}\nexport function cube3d (x, y, z, c) {\n  return new Cube3d(x, y, z, c)\n}\n\nclass Cube {\n  constructor (x, y, z, alpha, beta, colorD, colorT, colorG) {\n    ObjetMathalea2D.call(this)\n    this.x = x\n    this.y = y\n    this.z = z\n    this.alpha = alpha\n    this.beta = beta\n    this.colorD = colorD\n    this.colorG = colorG\n    this.colorT = colorT\n\n    this.lstPoints = []\n    this.lstPolygone = []\n    function proj (x, y, z, alpha, beta) {\n      const cosa = Math.cos(alpha * Math.PI / 180)\n      const sina = Math.sin(alpha * Math.PI / 180)\n      const cosb = Math.cos(beta * Math.PI / 180)\n      const sinb = Math.sin(beta * Math.PI / 180)\n      return point(cosa * x - sina * y, -sina * sinb * x - cosa * sinb * y + cosb * z)\n    }\n\n    this.lstPoints.push(proj(this.x, this.y, this.z, this.alpha, this.beta)) // point 0 en bas\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z, this.alpha, this.beta)) // point 1\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z + 1, this.alpha, this.beta)) // point 2\n    this.lstPoints.push(proj(this.x, this.y, this.z + 1, this.alpha, this.beta)) // point 3\n    this.lstPoints.push(proj(this.x + 1, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 4\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 5\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z, this.alpha, this.beta)) // point 6\n    let p\n    p = polygone([this.lstPoints[0], this.lstPoints[1], this.lstPoints[2], this.lstPoints[3]], 'black')\n    p.opaciteDeRemplissage = 1\n    p.couleurDeRemplissage = this.colorD\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[2], this.lstPoints[4], this.lstPoints[5], this.lstPoints[3]], 'black')\n    p.couleurDeRemplissage = this.colorG\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[3], this.lstPoints[5], this.lstPoints[6], this.lstPoints[0]], 'black')\n    p.couleurDeRemplissage = this.colorT\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svg(coeff)\n      }\n      code = `<g id=\"${this.id}\">${code}</g>`\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikz()\n      }\n      return code\n    }\n    this.svgml = function (coeff, amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svgml(coeff, amp)\n      }\n      return code\n    }\n    this.tikzml = function (amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikzml(amp)\n      }\n      return code\n    }\n  }\n}\nexport function cube (x = 0, y = 0, z = 0, alpha = 45, beta = -35, { colorD = 'green', colorT = 'white', colorG = 'gray' } = {}) {\n  return new Cube(x, y, z, alpha, beta, colorD, colorG, colorT)\n}\n\n/**\n   * LE PAVE\n   * @author Jean-Claude Lhote\n   * usage : pave(A,B,D,E) construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] sont délimitent 3 faces adjacentes.\n   *\n*/\nclass Pave3d {\n  constructor (A, B, D, E, color) {\n    ObjetMathalea2D.call(this)\n    const v1 = vecteur3d(A, B)\n    const v2 = vecteur3d(A, E)\n    const v3 = vecteur3d(A, D)\n    const C = translation3d(D, v1)\n    const H = translation3d(D, v2)\n    const G = translation3d(C, v2)\n    const F = translation3d(B, v2)\n    E.visible = false\n    this.color = color\n    this.base = polygone3d([A, B, F, E])\n    this.hauteur = v3\n    this.aretes = [arete3d(A, B, color), arete3d(A, D, color), arete3d(A, E, color), arete3d(C, B, color), arete3d(F, B, color), arete3d(C, D, color), arete3d(C, G, color), arete3d(F, G, color), arete3d(F, E, color), arete3d(H, G, color), arete3d(H, E, color), arete3d(H, D, color)]\n    this.svg = function (coeff) {\n      let code = ''\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.tikz()\n      }\n      return code\n    }\n  }\n}\nexport function pave3d (A, B, C, E, color = 'black') {\n  return new Pave3d(A, B, C, E, color)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA ROTATION VECTORIELLE\n   *\n   * @author Jean-Claude Lhote\n   * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n   * Elle sert à faire tourner des vecteurs essentiellement.\n   * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n   *\n   * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n   * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n   * @param {*} angle Angle de rotation\n   */\nexport function rotationV3d (point3D, vecteur3D, angle) { // point = ce qu'on fait tourner (Point3d) ; vecteur = directeur de l'axe de rotation [x,y,z] et angle de rotation en degrés\n  let matrice, V, p2\n  const norme = math.norm(vecteur3D.matrice)\n  const unitaire = math.multiply(vecteur3D.matrice, 1 / norme)\n  const u = unitaire._data[0]; const v = unitaire._data[1]; const w = unitaire._data[2]\n  const c = Math.cos(angle * Math.PI / 180); const s = Math.sin(angle * Math.PI / 180)\n  const k = 1 - c\n  matrice = math.matrix([[u * u * k + c, u * v * k - w * s, u * w * k + v * s], [u * v * k + w * s, v * v * k + c, v * w * k - u * s], [u * w * k - v * s, v * w * k + u * s, w * w * k + c]])\n  if (point3D.constructor == Point3d) {\n    V = math.matrix([point3D.x3d, point3D.y3d, point3D.z3d])\n    p2 = math.multiply(matrice, V)\n    return point3d(p2._data[0], p2._data[1], p2._data[2])\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D\n    p2 = math.multiply(matrice, V.matrice)\n    return vecteur3d(p2._data[0], p2._data[1], p2._data[2])\n  }\n}\n\n/**\n   * LA ROTATION D'AXE UNE DROITE\n   *\n   * @author Jean-Claude Lhote\n   *\n   * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n   * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n   * @param {Droite3d} droite3D Axe de rotation\n   * @param {Number} angle Angle de rotation\n   * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n   */\nexport function rotation3d (point3D, droite3D, angle, color) {\n  const directeur = droite3D.directeur\n  const origine = droite3D.origine\n  const p = []\n  if (point3D.constructor == Point3d) {\n    const V = vecteur3d(origine, point3d(0, 0, 0))\n    const W = vecteur3d(point3d(0, 0, 0), origine)\n    const M = translation3d(point3D, V)\n    const N = rotationV3d(M, directeur, angle)\n    return translation3d(N, W)\n  } else if (point3D.constructor == Vecteur3d) {\n    return rotationV3d(point3D, directeur, angle)\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(rotation3d(point3D.listePoints[i], droite3D, angle))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n\nfunction SensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  ObjetMathalea2D.call(this)\n  this.epaisseur = epaisseur\n  this.color = color\n  let M; let N; let s; const objets = []; let d; let A; let B\n  M = translation3d(axe.origine, rayon)\n  for (let i = 0; i < angle; i += 5) {\n    N = rotation3d(M, axe, 5)\n    s = segment(M.p2d, N.p2d)\n    s.color = this.color\n    s.epaisseur = this.epaisseur\n    objets.push(s)\n    M = N\n  }\n  N = rotation3d(M, axe, 5)\n  s = segment(M.p2d, N.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  d = droite3d(N, axe.directeur)\n  A = rotation3d(M, d, 30)\n  B = rotation3d(M, d, -30)\n  s = segment(N.p2d, A.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  s = segment(N.p2d, B.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  return new SensDeRotation3d(axe, rayon, angle, epaisseur, color)\n}\n\n/**\n   * LA TRANSLATION\n   *\n   * @author Jean-Claude Lhote\n   * @param {Point3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n   * @param {Vecteur3d} vecteur3D\n   */\nexport function translation3d (point3D, vecteur3D) {\n  if (point3D.constructor == Point3d) {\n    const x = point3D.x3d + vecteur3D.x3d\n    const y = point3D.y3d + vecteur3D.y3d\n    const z = point3D.z3d + vecteur3D.z3d\n    return point3d(x, y, z)\n  } else if (point3D.constructor == Polygone3d) {\n    const p = []\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(translation3d(point3D.listePoints[i], vecteur3D))\n    }\n    return polygone3d(p, point3D.color)\n  }\n}\nexport function homothetie3d (point3D, centre, rapport, color) {\n  let V\n  const p = []\n  if (point3D.constructor == Point3d) {\n    V = vecteur3d(centre, point3D)\n    V.x3d *= rapport\n    V.y3d *= rapport\n    V.y3d *= rapport\n    return translation3d(centre, V)\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D\n    V.x3d *= rapport\n    V.y3d *= rapport\n    V.y3d *= rapport\n    return V\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(homothetie3d(point3D.listePoints[i], centre, rapport, color))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n"],"sourceRoot":""}