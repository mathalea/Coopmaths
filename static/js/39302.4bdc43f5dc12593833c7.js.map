{"version":3,"sources":["webpack://mathalea/./src/js/modules/Alea2iep.js"],"names":["Alea2iep","this","idIEP","idHTML","tempo","vitesse","couleur","couleurCompas","couleurTexte","couleurPoint","couleurCodage","couleurTraitsDeConstruction","epaisseur","epaisseurTraitsDeConstruction","pointilles","liste_script","translationX","translationY","recadre","xmin","ymax","xMin","yMin","xMax","yMax","taille","width","height","push","x","A","calcul","y","regle","visibilite","position","point","angle","longueur","zoom","crayon","equerre","requerre","rapporteur","compas","orientation","ecartement","leve","xml","script","length","codeXML","join","html","id1","id2","context","id","window","listeScriptsIep","codeHTML","listeAnimationsIepACharger","htmlBouton","toggleVisibilityIEP","element","document","getElementById","elementBtn","style","display","marginTop","innerHTML","iepLoadPromise","autostart","then","iepApp","catch","error","console","log","montrer","objet","A1","deplacer","regleMontrer","options","crayonMontrer","equerreMontrer","requerreMontrer","compasMontrer","rapporteurMontrer","masquer","regleMasquer","crayonMasquer","equerreMasquer","requerreMasquer","compasMasquer","rapporteurMasquer","regleDeplacer","texteDeplacer","crayonDeplacer","equerreDeplacer","requerreDeplacer","compasDeplacer","rapporteurDeplacer","rotation","a","sens","typeObjet","droite","angleAvecHorizontale","isFinite","regleRotation","crayonRotation","equerreRotation","requerreRotation","compasRotation","rapporteurRotation","regleZoom","k","equerreZoom","requerreZoom","rapporteurZoom","compasZoom","pointCreer","dx","dy","label","nom","couleurLabel","M","textePoint","pointsCreer","args","enleveDernier","arr","slice","pointMasquer","pointMontrer","pointDeplacer","B","pointNommer","compasRetourner","compasEcarter","l","compasEcarterAvecRegle","compasEcarter2Points","s","segment","isVisible","compasLever","compasCoucher","compasTracerArc2Angles","angle1","angle2","pointillesTexte","Math","abs","sensTexte","compasTracerArcCentrePoint","centre","delta","visibility","compasCercleCentrePoint","requerreGlisserEquerre","rapporteurMasquerGraduationsExterieures","rapporteurMontrerGraduationsExterieures","rapporteurMasquerGraduationsInterieures","rapporteurMontrerGraduationsInterieures","rapporteurDeplacerRotation2Points","d","rapporteurCrayonMarqueAngle","O","pointAdistance","N","tracer","rapporteurTracerDemiDroiteAngle","B2","regleDemiDroiteOriginePoint","regleMasquerGraduations","regleMontrerGraduations","regleModifierLongueur","pointSurSegment","regleSegment","regleDroite","homothetie","regleProlongerSegment","B1","A2","vecteur","vecteurTexte","trait","traitRapide","traitMasquer","arg1","arg2","arg3","extremite1","extremite2","polygoneTracer","sommets","i","polygoneRapide","texte","police","couleurFond","opaciteFond","couleurCadre","epaisseurCadre","marge","margeGauche","margeDroite","margeHaut","margeBas","policeTexte","textePosition","longueurSegment","v","w","norme","ancrage","translation","mesureAngle","angleOriente","C","texteMasquer","pause","segmentCodage","undefined","codage","milieu","segmentCodageMasquer","segmentCodageMontrer","codageAngleDroit","C1","translation2Points","options1","codageAngleDroitMasquer","angleCodage","rayon","d1","d2","angleCodageMasquer","angleCodageMontrer","image","url","paralleleRegleEquerre2points3epoint","G","D","H1","H","projectionOrtho","droiteParPointEtParallele","C12","perpendiculaireRegleEquerre2points3epoint","longueurRegle","zoomEquerre","dist","appartientDroite","max","perpendiculaireRegleEquerreDroitePoint","P","alpha","mediatriceAuCompas","longueur1","longueur2","O2","arc1","arc2","arc3","arc4","mediatriceRegleEquerre","O3","hauteur","mediane","bissectriceAuCompas","masquerTraitsDeConstructions","cercleCirconscrit","couleurMediatrice","couleurCercle","m1","m2","m3","centreCercleCirconscrit","triangle3longueurs","ABC","AB","AC","BC","description","randint","triangle2points2longueurs","listePoints","nombreAvecEspace","triangleRectangleCoteHypotenuse","dAB","dBC","droiteParPointEtPerpendiculaire","cAC","cercle","pointIntersectionLC","c","triangleRectangle2Cotes","cBC","triangle1longueur2angles","NOM","BAC","CBA","mesure","a1","a2","D2","D1","E","E2","E1","F","F1","pointIntersectionDD","triangle2longueurs1angle","triangleEquilateral2Sommets","nomC","triangleEquilateral","parallelogramme3sommetsConsecutifs","nomD","csDejaTraces","min","parallelogramme2sommetsConsecutifsCentre","parallelogrammeAngleCentre","carre1point1longueur","polygoneAvecNom","rotationPoint","p","symetrieAxialePoint","symetrieAxiale","translationPoint","choix1","choix2","marques","marque1","marque2","demiTourPoint","homothetiePoint","positionTexte","couleurSave","t","arrondi","lprime","t1","texNombre","t2","rotationPolygone","noms","p2","sommet","symetrieAxialePolygone","translationPolygone","demiTourPolygone","homothetiePolygone"],"mappings":"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","file":"js/39302.4bdc43f5dc12593833c7.js","sourcesContent":["/* eslint-disable camelcase */\nimport { vecteur, polygoneAvecNom, translation, symetrieAxiale, appartientDroite, point, pointAdistance, droite, droiteParPointEtPerpendiculaire, segment, triangle2points2longueurs, cercle, pointIntersectionLC, homothetie, longueur, milieu, pointSurSegment, rotation, pointIntersectionDD, translation2Points, droiteParPointEtParallele, projectionOrtho, centreCercleCirconscrit, angleOriente, norme } from './2d.js'\nimport { calcul, randint, nombreAvecEspace, arrondi, texNombre } from './outils.js'\nimport iepLoadPromise from 'instrumenpoche'\nimport { context } from './context.js'\n\n/*\n * Classe parente de tous les objets Alea2iep\n *\n * @author Rémi Angot\n */\nexport default function Alea2iep () {\n  this.idIEP = 0 // Identifiant pour les tracés\n  this.idHTML = 0 // Identifiant pour les div et le svg\n  this.tempo = 5 // Pause par défaut après une instruction\n  this.vitesse = 10 // Vitesse par défaut pour les déplacements d'instruments\n  this.couleur = 'blue' // Couleur par défaut\n  this.couleurCompas = 'forestgreen'\n  this.couleurTexte = 'black'\n  this.couleurPoint = 'black' // Couleur du nom des points\n  this.couleurCodage = '#f15929'\n  this.couleurTraitsDeConstruction = 'gray'\n  this.epaisseur = 2\n  this.epaisseurTraitsDeConstruction = 1\n  this.pointilles = false\n  this.liste_script = [] // Liste des instructions xml mise à jour par les méthodes\n\n  this.translationX = 0\n  this.translationY = 10 // Par défaut l'angle en haut à gauche est le point de coordonnées (0,10)\n\n  this.recadre = function (xmin, ymax) {\n    this.translationX = 1 - xmin\n    this.translationY = ymax + 3\n  }\n\n  // Garde en mémoire les coordonnées extrêmes des objets créés\n  this.xMin = 0\n  this.yMin = 0\n  this.xMax = 0\n  this.yMax = 0\n\n  this.taille = function (width, height) {\n    this.liste_script.push(`<viewBox width=\"${width}\" height=\"${height}\" />`)\n  }\n  // Transforme les coordonnées MathALEA2D en coordonnées pour le XML d'IEP\n  this.x = function (A) {\n    const x = calcul((A.x + this.translationX) * 30, 0)\n    if (A.x > this.xMax) {\n      this.xMax = A.x\n    }\n    if (A.x < this.xMin) {\n      this.xMin = A.x\n    }\n    return x\n  }\n  this.y = function (A) {\n    const y = calcul((-A.y + this.translationY) * 30, 0)\n    if (A.y < this.yMin) {\n      this.yMin = A.y\n    }\n    if (A.y > this.yMax) {\n      this.yMax = A.y\n    }\n    return y\n  }\n\n  // Sauvegarde de l'état des instruments\n  this.regle = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    longueur: 15,\n    zoom: 100\n  }\n\n  this.crayon = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.equerre = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.requerre = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.rapporteur = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    zoom: 100\n  }\n\n  this.compas = {\n    visibilite: false,\n    position: point(0, 0),\n    angle: 0,\n    orientation: 'droite',\n    ecartement: 0,\n    leve: false,\n    zoom: 100\n  }\n\n  this.xml = ''\n\n  /**\n   * Renvoie le script xml\n   *\n   */\n  this.script = function () {\n    if (this.xml.length > 1) {\n      return this.xml\n    } else {\n      let codeXML = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n      codeXML += '<INSTRUMENPOCHE version=\"2\">\\n'\n      codeXML += this.liste_script.join('\\n')\n      codeXML += '\\n</INSTRUMENPOCHE>'\n      return codeXML\n    }\n  }\n\n  /**\n   * Renvoie le code HTML de l'animation\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   */\n  this.html = function (id1, id2) {\n    if (context.isHtml) {\n      const id = `IEP_${id1}_${id2}`\n      window.listeScriptsIep[id] = this.script() // On ajoute le script\n      const codeHTML = `<div id=\"IEPContainer${id}\" ></div>`\n      window.listeAnimationsIepACharger.push(id)\n      return codeHTML\n    }\n  }\n\n  /**\n   *\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   * @return Code HTML avec le bouton qui affiche ou masque un div avec l'animation\n   */\n  this.htmlBouton = function (id1, id2 = '') {\n    if (context.isHtml) {\n      const id = `IEP_${id1}_${id2}`\n      window.listeScriptsIep[id] = this.script() // On ajoute le script\n      const codeHTML = `<br><button class=\"ui mini compact button\" id=\"btnAnimation${id}\" onclick=\"toggleVisibilityIEP('${id}')\" style=\"margin-top:20px\"><i class=\"large play circle outline icon\"></i>Voir animation</button>\n            <div id=\"IEPContainer${id}\" style=\"display: none;\" ></div>`\n      if (!window.toggleVisibilityIEP) {\n        window.toggleVisibilityIEP = function (id) {\n          const element = document.getElementById(`IEPContainer${id}`)\n          const elementBtn = document.getElementById(`btnAnimation${id}`)\n          const xml = window.listeScriptsIep[id]\n          if (element.style.display === 'none') {\n            element.style.display = 'block'\n            element.style.marginTop = '30px'\n            elementBtn.innerHTML = '<i class=\"large stop circle outline icon\"></i>Masquer animation'\n            iepLoadPromise(element, xml, { zoom: true, autostart: true }).then(iepApp => {\n              // la figure est chargée\n            }).catch(error => { console.log(error) })\n          } else {\n            element.style.display = 'none'\n            elementBtn.innerHTML = '<i class=\"large play circle outline icon\"></i>Voir animation'\n          }\n        }\n      }\n      return codeHTML\n    } else {\n      return ''\n    }\n  }\n\n  /**\n **************************\n *** FONCTIONS COMMUNES ***\n **************************\n */\n\n  /**\n   *\n   * @param {string} objet - 'regle', 'equerre', 'requerre, 'compas', 'rapporteur' ou 'crayon'\n   * @param {point} A - Point (0, 0) par défaut\n   * @param {objet} options - { tempo : 10 }\n   */\n  this.montrer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    if (!this[objet].visibilite || this[objet].position !== A) { // On ajoute une ligne xml que si l'objet est caché ou doit apparaitre à un autre endroit\n      let codeXML = ''\n      let A1\n      if (typeof A === 'undefined') { // A1 est une copie de A ou (0,0) si A n'est pas défini\n        A1 = this[objet].position\n      } else {\n        A1 = A\n      }\n      if (this[objet].visibilite) { // S'il est déjà visible, montrer devient un déplcer\n        this.deplacer(objet, A1, { tempo: tempo, vitesse: vitesse })\n      } else {\n        codeXML = `<action objet=\"${objet}\" mouvement=\"montrer\" abscisse=\"${this.x(A1)}\" ordonnee=\"${this.y(A1)}\" tempo=\"${tempo}\" />`\n        this[objet].visibilite = true\n      }\n      this[objet].position = A1\n      this.liste_script.push(codeXML)\n    }\n  }\n\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.regleMontrer = function (A, options) {\n    this.montrer('regle', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.crayonMontrer = function (A, options) {\n    this.montrer('crayon', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.equerreMontrer = function (A, options) {\n    this.montrer('equerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.requerreMontrer = function (A, options) {\n    this.montrer('requerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.compasMontrer = function (A, options) {\n    this.montrer('compas', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.rapporteurMontrer = function (A, options) {\n    this.montrer('rapporteur', A, options)\n  }\n\n  /**\n   *\n   * @param {string} objet\n   * @param {objet} param1\n   */\n  this.masquer = function (objet, { tempo = this.tempo } = {}) {\n    if (this[objet].visibilite) { // On ajoute une ligne xml que si l'objet est visible\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"masquer\" tempo=\"${tempo}\" />`\n      this[objet].visibilite = false\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.regleMasquer = function (options) {\n    this.masquer('regle', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.crayonMasquer = function (options) {\n    this.masquer('crayon', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.equerreMasquer = function (options) {\n    this.masquer('equerre', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.requerreMasquer = function (options) {\n    this.masquer('requerre', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.compasMasquer = function (options) {\n    this.masquer('compas', options)\n  }\n  /**\n   *\n   * @param {objet} options\n   */\n  this.rapporteurMasquer = function (options) {\n    this.masquer('rapporteur', options)\n  }\n\n  /**\n *\n * @param {string} objet\n * @param {point} A\n * @param {objet} options\n */\n  this.deplacer = function (objet, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    if (this[objet].position !== A) { // On n'ajoute une commande xml que s'il y a vraiment un déplacement\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n      this[objet].position = A\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.regleDeplacer = function (A, options) {\n    this.deplacer('regle', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.texteDeplacer = function (id, A, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const codeXML = `<action objet=\"texte\" id=\"${id}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n    this.liste_script.push(codeXML)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.crayonDeplacer = function (A, options) {\n    this.deplacer('crayon', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.equerreDeplacer = function (A, options) {\n    this.deplacer('equerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.requerreDeplacer = function (A, options) {\n    this.deplacer('requerre', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.compasDeplacer = function (A, options) {\n    this.deplacer('compas', A, options)\n  }\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n  this.rapporteurDeplacer = function (A, options) {\n    this.deplacer('rapporteur', A, options)\n  }\n\n  /**\n *\n * @param {string} objet\n * @param {int} angle\n * @param {objet} options\n */\n  this.rotation = function (objet, a, { tempo = this.tempo, sens = calcul(this.vitesse / 2, 0) } = {}) {\n    let angle\n    if (a.typeObjet === 'point') {\n      const d = droite(this[objet].position, a)\n      angle = d.angleAvecHorizontale\n    } else {\n      angle = a\n    }\n    if (this[objet].angle !== a) { // Si la rotation est inutile, on ne la fait pas\n      // Les angles de MathALEA2D et de IEP sont opposés !!!!!\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"rotation\" angle=\"${-1 * angle}\" tempo=\"${tempo}\" sens=\"${sens}\" />`\n      this[objet].angle = angle\n      if (typeof angle === 'number' && isFinite(angle)) {\n        this.liste_script.push(codeXML)\n      } else {\n        console.log('Angle de rotation non défini pour l\\'objet .', objet)\n      }\n    }\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.regleRotation = function (angle, options) {\n    this.rotation('regle', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.crayonRotation = function (angle, options) {\n    this.rotation('crayon', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.equerreRotation = function (angle, options) {\n    this.rotation('equerre', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.requerreRotation = function (angle, options) {\n    this.rotation('requerre', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.compasRotation = function (angle, options) {\n    this.rotation('compas', angle, options)\n  }\n  /**\n *\n * @param {int} angle\n * @param {objet} options\n */\n  this.rapporteurRotation = function (angle, options) {\n    this.rotation('rapporteur', angle, options)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.regleZoom = function (k, { tempo = 0 } = {}) {\n    this.regle.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"regle\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.equerreZoom = function (k, { tempo = 0 } = {}) {\n    this.equerre.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"equerre\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.requerreZoom = function (k, { tempo = 0 } = {}) {\n    this.requerre.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"requerre\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.rapporteurZoom = function (k, { tempo = 0 } = {}) {\n    this.rapporteur.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"rapporteur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n *\n * @param {int} pourcentage 200 pour doubler la taille\n * @param {objet} options tempo = 0 par défaut\n */\n  this.compasZoom = function (k, { tempo = 0 } = {}) {\n    this.compas.zoom = k\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"compas\" />`)\n  }\n\n  /**\n **************************\n ********* POINT **********\n **************************\n */\n\n  /**\n * Crééer un point avec la croix pour le situer et son nom en bas à droite par défaut. L'id sera sauvegardé dans l'objet point. S'il n'est pas défini alors on prend le premier entier disponible.\n * @param {point} A\n * @param {objet} options { label: A.nom, tempo: this.tempo, couleur: this.couleurPoint, couleurLabel: this.couleurTexte, id }\n *\n */\n  this.pointCreer = function (A, { dx = 0.1, dy, label = A.nom, tempo = this.tempo, couleur = this.couleurPoint, couleurLabel = this.couleurTexte, id } = {}) {\n    if (typeof id !== 'undefined') {\n      A.id = id\n    } else {\n      this.idIEP++\n      A.id = this.idIEP\n    }\n    let codeXML\n    if (label) {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" />`\n      // codeXML += `\\n<action couleur=\"${couleurLabel}\" nom=\"${label}\" id=\"${this.idIEP}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\"  />`\n      const M = point(A.x, A.y)\n      if (typeof dx !== 'undefined') {\n        M.x += dx\n      }\n      if (typeof dy !== 'undefined') {\n        M.y += dy\n      }\n      this.textePoint(`$${label}$`, M, { tempo: 0, couleur: couleurLabel })\n    } else {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" tempo=\"${tempo}\" />`\n    }\n    this.liste_script.push(codeXML)\n  }\n  /**\n * Création de plusieurs points\n * Le dernier argument peut être une option qui sera appliquée à tous les points\n *\n * @param  {...points} points Points séparés par des virgules\n */\n  this.pointsCreer = function (...args) {\n    if (args[args.length - 1].typeObjet === 'point') {\n      for (const point of args) {\n        this.pointCreer(point, { tempo: 0 })\n      }\n    } else {\n      const options = args[args.length - 1]\n      const enleveDernier = arr => arr.slice(0, -1)\n      for (const point of enleveDernier(args)) {\n        this.pointCreer(point, options)\n      }\n    }\n  }\n  /**\n * Masquer un point\n * @param {point} A\n * @param {objet} options Défaut : { tempo: 0 }\n */\n  this.pointMasquer = function (A, { tempo = 0 } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"masquer\" objet=\"point\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Montrer un point qui aurait été caché\n   * @param {point} A\n   * @param {objet} options Défaut ; { tempo : this.tempo }\n   */\n  this.pointMontrer = function (A, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"montrer\" objet=\"point\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Anime la translation d'un point\n   * @param {point} A\n   * @param {int} x Abscisse du point d'arrivée\n   * @param {int} y Ordonnée du point d'arrivée\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.pointDeplacer = function (A, x, y, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const B = point(x, y)\n    this.liste_script.push(`<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" id=\"${A.id}\" mouvement=\"translation\" objet=\"point\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`)\n  }\n  /**\n   * Ajoute un label au point\n   * @param {point} A\n   * @param {string} nom\n   * @param {objet} options dx pour le déplacement vertical du nom du point, dy pour le déplacemetn horizontal, couleur: this.couleurPoint, tempo: this.tempo\n   */\n  this.pointNommer = function (A, nom, { dx, dy, couleur = this.couleurPoint, tempo = this.tempo } = {}) {\n    // const coordonneesTexte = ''\n    const M = point(A.x, A.y)\n    if (typeof dx !== 'undefined') {\n      M.x += dx\n    }\n    if (typeof dy !== 'undefined') {\n      M.y += dy\n    }\n    this.textePoint(`$${nom}$`, M, { tempo: tempo, couleur: couleur })\n    // this.liste_script.push(`<action couleur=\"${couleur}\" nom=\"${nom}\" id=\"${A.id}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\" ${coordonneesTexte} />`)\n  }\n\n  /**\n **************************\n ********* COMPAS *********\n **************************\n */\n\n  /**\n* Change l'orientation du compas. Par défaut, elle est vers la droite. L'orientation courante du compas est sauvegardée dans this.compas.orientation\n* @param {objet} options Défaut : { tempo: this.tempo}\n*/\n  this.compasRetourner = function ({ tempo = this.tempo } = {}) {\n    const codeXML = `<action mouvement=\"retourner\" objet=\"compas\" tempo=\"${tempo}\" />`\n    if (this.compas.orientation === 'droite') {\n      this.compas.orientation = 'gauche'\n    } else {\n      this.compas.orientation = 'droite'\n    }\n    this.liste_script.push(codeXML)\n  }\n  /**\n   *\n   * @param {int} longueur écartement en cm\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.compasEcarter = function (l, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    const codeXML = `<action ecart=\"${calcul(l * 30, 1)}\" mouvement=\"ecarter\" objet=\"compas\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`\n    this.compas.ecartement = l\n    this.liste_script.push(codeXML)\n  }\n  /**\n   * Fais apparaitre la règle à l'horizontale, met le compas vertical et écarte le compas le long de la règle pour lire son écartement\n   * @param {int} longueur\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n   */\n  this.compasEcarterAvecRegle = function (l, { tempo = this.tempo, vitesse = this.vitesse, sens = this.vitesse / 2 } = {}) {\n    this.regleRotation(0, { tempo: 0, sens: sens })\n    this.regleMontrer(this.compas.position, { tempo: 0 })\n    this.regleDeplacer(this.compas.position, { tempo: 0, vitesse: vitesse })\n    this.compasMontrer()\n    this.compasRotation(0, { tempo: 0, sens: sens })\n    this.compasEcarter(l, { tempo: tempo, vitesse: vitesse, sens: sens })\n  }\n  /**\n *\n * @param {point} A Pointe du compas\n * @param {point} B Mine du compas\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n */\n  this.compasEcarter2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2) } = {}) {\n    this.compasMontrer(A)\n    this.compasDeplacer(A, { tempo: tempo, vitesse: vitesse })\n    const s = segment(A, B)\n    s.isVisible = false\n    const angle = s.angleAvecHorizontale\n    this.compasRotation(angle, { tempo: tempo, sens: sens })\n    this.compasEcarter(longueur(A, B), { tempo: tempo, vitesse: vitesse })\n  }\n  /**\n * Remettre le compas en position standard. Son état est sauvegardé dans le booléen this.compas.leve.\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.compasLever = function ({ tempo = this.tempo } = {}) {\n    if (!this.compas.leve) { // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"lever\" objet=\"compas\" tempo=\"${tempo} />`\n      this.compas.leve = true\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n * Voir le compas en vue de dessus avant qu'il trace un arc de cercle\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.compasCoucher = function ({ tempo = this.tempo } = {}) {\n    if (this.compas.leve) { // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\" />`\n      this.compas.leve = false\n      this.liste_script.push(codeXML)\n    }\n  }\n  /**\n * Trace un arc de cercle en gardant l'écartement et le centre actuel. L'angle de départ sera choisi pour être le plus proche de l'angle actuel\n * @param {int} angle1\n * @param {int} angle2\n * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n * @return {id}\n */\n  this.compasTracerArc2Angles = function (angle1, angle2, { tempo = this.tempo, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : ''\n    this.idIEP += 1\n    if (Math.abs(this.compas.angle - angle1) > Math.abs(this.compas.angle - angle2)) { // On cherche à commencer par le point le plus proche de la position courante du compas\n      [angle1, angle2] = [angle2, angle1]\n    }\n    let codeXML = `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" tempo=\"${tempo}\" />\\n`\n    codeXML += '<action mouvement=\"lever\" objet=\"compas\" />\\n'\n    codeXML += `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" />\\n`\n    let sensTexte\n    if (angle2 > angle1) {\n      sensTexte = sens\n    } else {\n      sensTexte = -1 * sens\n    }\n    codeXML += `<action couleur=\"${couleur}\" epaisseur=\"${epaisseur}\" sens=\"${sensTexte}\" debut=\"${-angle1}\" fin=\"${-angle2}\" mouvement=\"tracer\" objet=\"compas\"  ${pointillesTexte} id=\"${this.idIEP}\" />\\n`\n    codeXML += `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\"/>`\n    this.compas.angle = angle2\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Trace un arc de cercle autour d'un point. La longueur de l'arc est déterminée par l'option delta en degré qui est ajoutée de part et d'autre du point\n   * @param {point} centre\n   * @param {point} point\n   * @param {objet} options Défaut : { delta: 10, tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n   * @return {id}\n   */\n  this.compasTracerArcCentrePoint = function (centre, point, { delta = 10, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, couleur = this.couleurCompas, pointilles = this.pointilles } = {}) {\n    this.compasMontrer()\n    this.compasDeplacer(centre, { tempo: tempo, vitesse: vitesse })\n    const s = segment(centre, point)\n    s.visibility = false\n    const angle1 = s.angleAvecHorizontale - delta\n    const angle2 = s.angleAvecHorizontale + delta\n    if ((Math.abs(this.compas.ecartement - longueur(this.compas.position, point))) > 0.1) {\n      this.compasEcarter(longueur(centre, point), { tempo: tempo, vitesse: vitesse })\n    }\n    return this.compasTracerArc2Angles(angle1, angle2, { tempo: tempo, vitesse: vitesse, epaisseur: epaisseur, sens: sens, couleur: couleur, pointilles: pointilles })\n  }\n  /**\n *\n * @param {point} centre\n * @param {point} point Point de départ du tracé du cercle\n * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n */\n  this.compasCercleCentrePoint = function (centre, point, { tempo = this.tempo, couleur = this.couleur, vitesse = this.vitesse, sens = calcul(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {\n    this.compasEcarter2Points(centre, point, { vitesse: vitesse, tempo: tempo })\n    const d = droite(centre, point)\n    const angle1 = d.angleAvecHorizontale\n    this.compasTracerArc2Angles(angle1, angle1 + 360, { tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, couleur: couleur, pointilles: pointilles })\n  }\n\n  /**\n **************************\n ******** REQUERRE ********\n **************************\n */\n\n  /**\n   *\n   * @param {int} déplacement en nombre de cm (le déplacement peut être positif ou négatif)\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n  this.requerreGlisserEquerre = function (a, { tempo = this.tempo, vitesse = this.vitesse } = {}) {\n    this.liste_script.push(`<action abscisse=\"${a * 30}\" mouvement=\"glisser\" objet=\"requerre\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`)\n  }\n\n  /**\n **************************\n ******* RAPPORTEUR *******\n **************************\n */\n\n  // Non pris en charge par le lecteur JS\n  // this.rapporteurCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"circulaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n  // this.rapporteurSemiCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"semicirculaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n\n  /**\n   * Masque la graduation externe du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMasquerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Montre la graduation extérieure si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMontrerGraduationsExterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"montrer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Masque la graduation interne du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMasquerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Montre la graduation interne si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.rapporteurMontrerGraduationsInterieures = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Met le rapporteur en position avec le centre en A et le 0 de droite alogné avec le point B\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n */\n  this.rapporteurDeplacerRotation2Points = function (A, B, { tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2) } = {}) {\n    const d = droite(A, B)\n    d.isVisible = false\n    this.rapporteurMontrer()\n    this.rapporteurDeplacer(A, { tempo: tempo, vitesse: vitesse })\n    this.rapporteurRotation(d.angleAvecHorizontale, { tempo: tempo, vitesse: vitesse, sens: sens })\n  }\n  /**\n * Fais une petite marque (couleur et épaisseur d'un trait de construction) sur une graduation du rapporteur\n * @param {int} angle\n * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, couleur: this.couleurTraitsDeConstruction, epaisseur: this.epaisseurTraitsDeConstruction }\n */\n  this.rapporteurCrayonMarqueAngle = function (angle, { tempo = this.tempo, vitesse = this.vitesse, couleur = this.couleurTraitsDeConstruction, epaisseur = this.epaisseurTraitsDeConstruction } = {}) {\n    const O = this.rapporteur.position\n    const M = pointAdistance(O, 5.2, angle + this.rapporteur.angle)\n    const N = pointAdistance(O, 5.5, angle + this.rapporteur.angle)\n    this.crayonMontrer()\n    this.crayonDeplacer(M, { tempo: tempo, vitesse: vitesse })\n    this.tracer(N, { tempo: tempo, vitesse: vitesse, couleur: couleur, epaisseur: epaisseur })\n  }\n  /**\n * Le crayon va faire une marque sur la graduation du rapporteur, le rapporteur va se cacher et on trace une demi-droite dont on peut choisir la \"longueur\" (par défaut 90% de celle de la règle)\n * @param {point} A Centre du rapporteur\n * @param {point} B Point avec lequel le 0 de droite sera aligné\n * @param {int} angle\n * @param {objet} options { longueur: 0.9 * this.regle.longueur, couleur: this.couleur, tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2, epaisseur: this.epaisseur, pointilles: this.pointilles }\n */\n  this.rapporteurTracerDemiDroiteAngle = function (A, B, angle, { longueur = 0.9 * this.regle.longueur, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2), epaisseur = this.epaisseur, pointilles = this.pointilles } = {}) {\n    if (angle > 0) {\n      this.rapporteurDeplacerRotation2Points(A, B, { tempo: tempo, vitesse: vitesse, sens: sens })\n      this.rapporteurCrayonMarqueAngle(angle, { tempo: tempo, vitesse: vitesse, sens: sens })\n    } else {\n      const B2 = rotation(B, A, 180)\n      this.rapporteurDeplacerRotation2Points(A, B2, { tempo: tempo, vitesse: vitesse, sens: sens })\n      this.rapporteurCrayonMarqueAngle(180 - Math.abs(angle), { tempo: tempo, vitesse: vitesse, sens: sens })\n    }\n    const d = droite(A, B)\n    d.isVisible = false\n    const M = pointAdistance(A, calcul(5.2 * this.rapporteur.zoom / 100, 1), d.angleAvecHorizontale + angle)\n    this.rapporteurMasquer({ tempo: tempo })\n    this.regleDemiDroiteOriginePoint(A, M, { longueur: longueur, couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })\n  }\n\n  /**\n **************************\n ********* REGLE **********\n **************************\n */\n\n  /**\n * Masquer les graduations sur la règle\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.regleMasquerGraduations = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"regle\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Montrer les graduations sur la règle si elles avaient été masquées\n * @param {objet} options Défaut : { tempo: this.tempo }\n */\n  this.regleMontrerGraduations = function ({ tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"regle\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n   * Modifie la taille de la règle\n   * @param {int} longueur\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.regleModifierLongueur = function (longueur = 20, { tempo = this.tempo } = {}) {\n    this.regle.longueur = longueur\n    this.liste_script.push(`<action mouvement=\"modifier_longueur\" objet=\"regle\" longueur=\"${longueur}\" tempo=\"${tempo}\"/>`)\n  }\n  /**\n * Trace une demi-droite d'origine O passant par A (ou en direction de A si les points sont trop éloignés)\n * @param {point} O Origine\n * @param {point} A Direction\n * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n */\n  this.regleDemiDroiteOriginePoint = function (O, A, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur\n    }\n    const M = pointSurSegment(O, A, options.longueur)\n    this.regleSegment(O, M, options)\n  }\n\n  /**\n   * Trace une droite passanrt par les points A et B\n   * @param {point} A\n   * @param {point} B\n   * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n   */\n  this.regleDroite = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur\n    }\n    const M = homothetie(B, A, calcul((-options.longueur * 0.5 + longueur(A, B) * 0.5) / longueur(A, B)))\n    const N = homothetie(A, B, calcul((-options.longueur * 0.5 + longueur(A, B) * 0.5) / longueur(A, B)))\n    if (this.x(A) <= this.x(B)) {\n      this.regleMontrer(M)\n      this.regleRotation(N, options)\n      this.regleSegment(M, N, options)\n    } else {\n      this.regleMontrer(N)\n      this.regleRotation(M, options)\n      this.regleSegment(N, M, options)\n    }\n  }\n  /**\n * Avec la règle, on prolonge le segment de l cm du coté de la 2e extrémité si l est positif sinon du côté de la première extrémité\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut {longueur: 3, tempo: this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n */\n  this.regleProlongerSegment = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur - 3\n    }\n    if (options.longueur > 0) {\n      const B1 = pointSurSegment(B, A, 3)\n      const B2 = pointSurSegment(B, A, -options.longueur)\n      this.regleSegment(B1, B2, options)\n    } else {\n      const A1 = pointSurSegment(A, B, 3)\n      const A2 = pointSurSegment(A, B, options.longueur)\n      this.regleSegment(A1, A2, options)\n    }\n  }\n\n  /**\n **************************\n ********* TRAITS *********\n **************************\n */\n\n  /**\n * Le crayon trace un trait de sa position courante jusqu'au point B\n * @param {point} B\n * @param {objet} options Défaut { tempo: this.tempo, vitesse: this.vitesse, epaisseur: this.epaisseur, couleur: this.couleur, pointilles: this.pointilles, vecteur: false }\n * @return {id} id utilisée pour le tracé\n */\n  this.tracer = function (B, { tempo = this.tempo, vitesse = this.vitesse, epaisseur = this.epaisseur, couleur = this.couleur, pointilles = this.pointilles, vecteur = false } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : ''\n    const vecteurTexte = vecteur ? 'style=\"vecteur\"' : ''\n    this.idIEP += 1\n    const codeXML = `<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" epaisseur=\"${epaisseur}\" couleur=\"${couleur}\" mouvement=\"tracer\" objet=\"crayon\" tempo=\"${tempo}\" vitesse=\"${vitesse}\"  ${pointillesTexte} ${vecteurTexte} id=\"${this.idIEP}\" />`\n    this.crayon.position = B\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Trace au crayon le segment [AB]\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n  this.trait = function (A, B, options = {}) {\n    this.crayonDeplacer(A, options)\n    return this.tracer(B, options)\n  }\n  /**\n   * Trace au crayon le segment [AB] sans tempo et avec une vitesse multipliée par 1 000\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n  this.traitRapide = function (A, B, options = {}) {\n    options.tempo = 0\n    options.vitesse = 10000\n    this.crayonDeplacer(A, options)\n    return this.tracer(B, options)\n  }\n  /**\n * Masque le trait d'id fourni\n * @param {int} id\n * @param {objet} options Défaut : { tempo: 0, vitesse: 200 }\n */\n  this.traitMasquer = function (id, { tempo = 0, vitesse = 200 } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"trait\" id=\"${id}\" vitesse=\"${vitesse}\" />`)\n  }\n  /**\n   *\n   * @param {segment/point} Segment à tracer ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points\n   * @returns {id} identifiant utilisé pour le trait\n   */\n  this.regleSegment = function (arg1, arg2, arg3) {\n    let A, B, options, id\n    if (arg1.typeObjet === 'segment') {\n      A = arg1.extremite1\n      B = arg1.extremite2\n      options = arg2\n    } else {\n      A = arg1\n      B = arg2\n      options = arg3\n    }\n    if (A.x <= B.x) { // Toujours avoir la règle de gauche à droite\n      this.regleMontrer(A, options)\n      this.regleRotation(B, options)\n    } else {\n      this.regleMontrer(B, options)\n      this.regleRotation(A, options)\n    }\n    if (longueur(this.crayon.position, A) < longueur(this.crayon.position, B)) { // Le crayon ira au point le plus proche\n      this.crayonMontrer(A, options)\n      id = this.tracer(B, options)\n    } else {\n      this.crayonMontrer(B, options)\n      id = this.tracer(A, options)\n    }\n    return id\n  }\n  /**\n   * Trace un polygone avec les options par défaut que l'on ne peut pas changer ici\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n  this.polygoneTracer = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.regleSegment(sommets[i], sommets[i + 1])\n    }\n    this.regleSegment(sommets[sommets.length - 1], sommets[0])\n  }\n\n  /**\n   * Trace un polygone avec traitRapide()\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n  this.polygoneRapide = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.traitRapide(sommets[i], sommets[i + 1])\n    }\n    this.traitRapide(sommets[sommets.length - 1], sommets[0])\n  }\n\n  /**\n **************************\n ********* TEXTE **********\n **************************\n */\n\n  /**\n   * Ecris un texte collé au point. On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {point} A\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   * @return {id}\n   */\n  this.textePoint = function (texte, A, { tempo = this.tempo, police = false, couleur = this.couleurTexte, taille, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas } = {}) {\n    this.idIEP++\n    const policeTexte = police ? `police=\"${police}\"` : ''\n    let options = ''\n    if (typeof couleurFond !== 'undefined') {\n      options += ` couleur_fond=\"${couleurFond}\"`\n    }\n    if (typeof opaciteFond !== 'undefined') {\n      options += ` opacite_fond=\"${opaciteFond}\"`\n    }\n    if (typeof couleurCadre !== 'undefined') {\n      options += ` couleur_cadre=\"${couleurCadre}\"`\n    }\n    if (typeof epaisseurCadre !== 'undefined') {\n      options += ` epaisseur_cadre=\"${epaisseurCadre}\"`\n    }\n    if (typeof marge !== 'undefined') {\n      options += ` marge=\"${marge}\"`\n    }\n    if (typeof margeGauche !== 'undefined') {\n      options += ` marge_gauche=\"${margeGauche}\"`\n    }\n    if (typeof margeDroite !== 'undefined') {\n      options += ` marge_droite=\"${margeDroite}\"`\n    }\n    if (typeof margeBas !== 'undefined') {\n      options += ` marge_bas=\"${margeBas}\"`\n    }\n    if (typeof margeHaut !== 'undefined') {\n      options += ` marge_haut=\"${margeHaut}\"`\n    }\n    if (typeof taille !== 'undefined') {\n      options += ` taille=\"${taille}\"`\n    }\n    let codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"creer\" objet=\"texte\" />`\n    codeXML += `\\n<action ${policeTexte} couleur=\"${couleur}\" texte=\"${texte}\" id=\"${this.idIEP}\" mouvement=\"ecrire\" objet=\"texte\" ${options} tempo=\"${tempo}\" />`\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n  /**\n   * Ecris un texte collé au point de coordonnées (x,y). On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {int} x Abscisse du coin en haut à gauche\n   * @param {int} y Ordonnée du coin en haut à gauche\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   */\n  this.textePosition = function (texte, x, y, options) {\n    const A = point(x, y)\n    return this.textePoint(texte, A, options)\n  }\n\n  this.longueurSegment = function (A, B, dy, options) {\n    const l = calcul(longueur(A, B, 1))\n    const v = vecteur(A, B)\n    const w = vecteur(-v.y * dy / norme(v), v.x * dy / norme(v))\n    const ancrage = translation(translation(pointSurSegment(A, B, l / 2 - 0.7), w), vecteur(0, 1))\n    return this.textePoint(`${l} cm`, ancrage, options)\n  }\n\n  this.mesureAngle = function (A, O, B) {\n    const a = angleOriente(A, O, B)\n    const C = translation(homothetie(rotation(A, O, a / 2), O, 1.3 / longueur(O, A)), vecteur(-0.2, 0.5))\n    return this.textePoint(Math.abs(a) + '°', C)\n  }\n  /**\n * Masque le trait d'id fourni\n * @param {int} id\n * @param {objet} options Défaut : { tempo: 0 }\n */\n  this.texteMasquer = function (id, { tempo = 0 } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"texte\" id=\"${id}\"  />`)\n  }\n\n  /**\n   * Met l'animation en pause forçant l'utilisateur à appuyer sur lecture pour voir la suite\n   */\n  this.pause = function () {\n    this.liste_script.push('<action mouvement=\"pause\" />')\n  }\n\n  /**\n **************************\n ******* CODAGES **********\n **************************\n */\n\n  /**\n   *\n   * @param {segment/point} Segment à coder ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points. Défaut : { tempo: this.tempo, couleur: this.couleurCodage, codage: '//', }\n   * @return {id}\n  */\n  this.segmentCodage = function (arg1, arg2 = {}, arg3 = {}) {\n    let s\n    let options = {}\n    if (arg1.typeObjet === 'segment') {\n      s = arg1\n      options = arg2\n    } else {\n      s = segment(arg1, arg2)\n      options = { ...arg3 }\n    }\n    if (options.tempo === undefined) {\n      options.tempo = this.tempo\n    }\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage\n    }\n    if (options.codage === undefined) {\n      options.codage = '\\\\'\n    }\n    this.idIEP++\n    const id = this.idIEP\n    const M = milieu(s.extremite1, s.extremite2)\n    const codeXML = `<action abscisse=\"${this.x(M)}\" ordonnee=\"${this.y(M)}\" forme=\"${options.codage}\"  couleur=\"${options.couleur}\" id=\"${id}\" tempo=\"${options.tempo}\" mouvement=\"creer\" objet=\"longueur\" />`\n    this.liste_script.push(codeXML)\n    return id\n  }\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.segmentCodageMasquer = function (id, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"longueur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n  this.segmentCodageMontrer = function (id, { tempo = this.tempo } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"longueur\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Trace le petit carré au crayon\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : {longueur : 0.3, couleur: this.couleurCodage}\n   * @return {array} [idTrait1, idTrait2]\n   */\n  this.codageAngleDroit = function (A, B, C, options = {}) {\n    this.crayonMontrer()\n    if (options.longueur === undefined) {\n      options.longueur = 0.3\n    }\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage\n    }\n    const C1 = pointSurSegment(B, C, options.longueur)\n    const A1 = pointSurSegment(B, A, options.longueur)\n    const M = translation2Points(A1, B, C1)\n    const options1 = { ...options } // On recopie options pour ouvoir en changer le tempo du premier tracé\n    options1.tempo = 0\n    const trait1 = this.trait(C1, M, options1)\n    const trait2 = this.trait(M, A1, options)\n    return [trait1, trait2]\n  }\n  /**\n   * Masque le codage d'un angle droit\n   * @param {int} id Identifiant du codage d'un angle droit\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.codageAngleDroitMasquer = function (id, { tempo = 0 } = {}) {\n    this.traitMasquer(id[0], { tempo: tempo })\n    this.traitMasquer(id[1], { tempo: tempo })\n  }\n\n  /**\n   * Code un angle. L'option codage peut être \"simple\", \"/\", \"//\", \"///\", \"O\"\n   * \"double\", \"double/\", \"double//\", \"double///\", \"doubleO\"\n   * \"triple\", \"triple/\", \"triple//\", \"triple///\", \"tripleO\"\n   * \"plein\", \"plein/\", \"plein//\", \"plein///\", \"pleinO\"\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : { rayon : 1, couleur: this.couleurCodage, codage: 'plein'}\n   * @return {id} L'identifiant correspond à l'identifiant des 3 points de l'angle séparés par _\n   */\n  this.angleCodage = function (B, A, C, { couleur = this.couleurCodage, codage = 'plein', rayon = 1, tempo = this.tempo } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    const d1 = droite(A, B)\n    const d2 = droite(A, C)\n    d1.isVisible = false\n    d2.isVisible = false\n    const angle1 = -d1.angleAvecHorizontale\n    const angle2 = -d2.angleAvecHorizontale\n    const codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" rayon=\"${rayon * 30}\" angle1=\"${angle1}\" angle2=\"${angle2}\" forme=\"${codage}\"  couleur=\"${couleur}\" id=\"${id}\" tempo=\"${tempo}\" mouvement=\"creer\" objet=\"angle\" />`\n    this.liste_script.push(codeXML)\n    return id\n  }\n\n  /**\n   * Masque un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.angleCodageMasquer = function (B, A, C, { tempo = 0 } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"angle\" tempo=\"${tempo}\" />`)\n  }\n  /**\n   * Montre un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n  this.angleCodageMontrer = function (B, A, C, { tempo = 0 } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"angle\" tempo=\"${tempo}\" />`)\n  }\n\n  /**\n   * Affiche une image (donnée par son URL) au point A\n   * @param {string} url\n   * @returns {id}\n   */\n  this.image = function (url, A = point(0, 0)) {\n    this.idIEP++\n    let codeXML\n    codeXML = `<action id=\"${this.idIEP}\" url=\"${url}\" mouvement=\"chargement\" objet=\"image\" />`\n    codeXML += `\\n<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"translation\" objet=\"image\" vitesse=\"100000\" />`\n    this.liste_script.push(codeXML)\n    return this.idIEP\n  }\n\n  /**\n *****************************************\n ********* MACROS-CONSTRUCTIONS **********\n *****************************************\n */\n\n  /**\n   * Trace la parallèle à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {*} options\n   */\n  this.paralleleRegleEquerre2points3epoint = function (A, B, C, options) {\n    let G, D, H1\n    // G est le point le plus à gauche, D le plus à droite et H le projeté de C sur (AB)\n    // H1 est un point de (AB) à gauche de H, c'est là où seront la règle et l'équerre avant de glisser\n    if (A.x < B.x) {\n      G = A\n      D = B\n    } else {\n      G = B\n      D = A\n    }\n    const d = droite(A, B)\n    const H = projectionOrtho(C, d)\n    if (H.x < D.x) {\n      H1 = pointSurSegment(H, D, -2) // H1 sera plus à gauche que H\n    } else if (H.x > D.x) {\n      H1 = pointSurSegment(H, D, 2)\n    } else {\n      H1 = pointSurSegment(H, G, 2)\n    }\n    const C1 = projectionOrtho(H1, droiteParPointEtParallele(C, d))\n    // C1 est le point d'arrivée de l'équerre après avoir glissé\n    const M = pointSurSegment(C1, C, 6)\n    // Le tracé de la parallèle ne fera que 6 cm pour ne pas dépassr de l'équerre. M est la fin de ce tracé\n\n    if (H.x < G.x && longueur(H, G) > 3) { // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G)\n      this.regleMasquer()\n    }\n    if (H.x > D.x && longueur(H, D) > 3) { // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(G, D)\n    }\n\n    this.equerreMontrer(H1)\n    if (M.x > C1.x) {\n      this.equerreRotation(d.angleAvecHorizontale - 90)\n    } else {\n      this.equerreRotation(d.angleAvecHorizontale + 90)\n    }\n    if (H1.y > C1.y) {\n      if (this.regle.visibilite) {\n        this.regleDeplacer(H1, { vitesse: this.vitesse, tempo: 0 })\n        this.regleRotation(C1, { sens: this.vitesse / 2, tempo: 0 })\n      } else {\n        this.regleDeplacer(H1, { vitesse: 1000, tempo: 0 })\n        this.regleRotation(C1, { sens: 1000, tempo: 0 })\n      }\n    } else {\n      const C12 = pointSurSegment(C1, H1, -2) // On monte un peu plus la règle pour que ça soit plus crédible\n      if (this.regle.visibilite) {\n        this.regleDeplacer(C12, { vitesse: this.vitesse, tempo: 0 })\n        this.regleRotation(H1, { sens: this.vitesse / 2, tempo: 0 })\n      } else {\n        this.regleDeplacer(C12, { vitesse: 1000, tempo: 0 })\n        this.regleRotation(H1, { sens: 1000, tempo: 0 })\n      }\n    }\n    this.regleMontrer()\n    this.equerreDeplacer(C1, options)\n    this.crayonMontrer()\n    this.crayonDeplacer(C1, options)\n    this.tracer(M, options)\n  }\n  /**\n     * Trace la perpendiculaire à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n     * @param {point} A\n     * @param {point} B\n     * @param {point} C\n     * @param {*} options\n     */\n  this.perpendiculaireRegleEquerre2points3epoint = function (A, B, C, options) {\n    const longueurRegle = this.regle.longueur\n    const zoomEquerre = this.equerre.zoom\n    const d = droite(A, B)\n    let dist\n    if (appartientDroite(C, A, B)) {\n      dist = 7.5\n    } else {\n      const H = projectionOrtho(C, d)\n      dist = longueur(H, C) + 2\n    }\n    this.equerreZoom(calcul(dist * 100 / 7.5))\n    this.regleModifierLongueur(Math.max(dist * 2, 15))\n\n    this.perpendiculaireRegleEquerreDroitePoint(d, C)\n    this.equerreZoom(zoomEquerre)\n    this.regleModifierLongueur(longueurRegle)\n  }\n\n  this.perpendiculaireRegleEquerreDroitePoint = function (d, P) {\n    const H = projectionOrtho(P, d)\n    const A = rotation(P, H, 90)\n    const B = rotation(A, H, 180)\n    const alpha = angleOriente(point(10000, H.y), H, B)\n    this.equerreRotation(alpha)\n    this.equerreMontrer(H)\n    this.regleSegment(H, P)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, H, P)\n    this.regleProlongerSegment(P, H, { longueur: longueur(P, H) * 2 })\n  }\n\n  /**\n *****************************************\n ********* DROITES REMARQUABLES **********\n *****************************************\n */\n\n  /**\n * Trace la médiatrice de [AB] au compas. Le paramétrage des longueurs correspond à la distance entre le milieu du segment et le point d'intersection des arcs de cercles\n *\n * @param {point} A\n * @param {point} B\n * @param {objet} options Défaut : {longueur1: 3, longueur2: 3, codage: 'X', couleurCodage : this.couleurCodage, couleurCompas: this.couleurCompas}\n * @return {array} [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]\n  */\n  this.mediatriceAuCompas = function (A, B, options = {}) {\n    if (options.longueur1 === undefined) {\n      options.longueur1 = 3\n    }\n    if (options.longueur2 === undefined) {\n      options.longueur2 = -3\n    }\n    if (options.codage === undefined) {\n      options.codage = 'X'\n    }\n    if (options.couleurCodage === undefined) {\n      options.couleurCodage = this.couleurCodage\n    }\n    if (options.couleurCompas === undefined) {\n      options.couleurCompas = this.couleurCompas\n    }\n    const O = milieu(A, B)\n    const O2 = rotation(A, O, -90)\n    const M = pointSurSegment(O, O2, options.longueur1)\n    const N = pointSurSegment(O, O2, options.longueur2)\n    this.compasMontrer()\n    this.compasDeplacer(A, options)\n    let arc1, arc2, arc3, arc4\n    if (options.longueur1 === -1 * options.longueur2) { // Si la distance est la même des deux côtés, on peut faire les arcs de part et d'autre\n      this.compasEcarter(longueur(A, M), { vitesse: options.vitesse, sens: options.vitesse })\n      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc2 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc3 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc4 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n    } else {\n      this.compasEcarter(longueur(A, M), options)\n      arc1 = this.compasTracerArcCentrePoint(A, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc2 = this.compasTracerArcCentrePoint(B, M, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc3 = this.compasTracerArcCentrePoint(B, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n      arc4 = this.compasTracerArcCentrePoint(A, N, { delta: options.delta, couleur: options.couleurCompas, sens: options.sens, vitesse: options.vitesse, tempo: options.tempo })\n    }\n    this.compasMasquer()\n    if (M.x <= N.x) {\n      this.regleDroite(M, N, options)\n    } else {\n      this.regleDroite(N, M, options)\n    }\n    this.regleMasquer()\n    const codage1 = this.segmentCodage(A, O, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })\n    const codage2 = this.segmentCodage(O, B, { codage: options.codage, couleur: options.couleurCodage, tempo: options.tempo })\n    const codageCarre = this.codageAngleDroit(A, O, O2, { couleur: options.couleurCodage, tempo: options.tempo, vitesse: options.vitesse })\n    return [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]\n  }\n  /**\n   * Trace la médiatrice du segment [AB] avec la méthode Règle + équerre.\n   * @param {point} A\n   * @param {point} B\n   * @param {booléen} codage\n   */\n  this.mediatriceRegleEquerre = function (A, B, codage = 'X') {\n    const O = milieu(A, B)\n    this.regleMontrer()\n    this.regleDeplacer(A)\n    this.regleRotation(B)\n    this.crayonMontrer()\n    const O2 = rotation(A, O, -90)\n    const O3 = rotation(A, O, 90)\n    const M = pointSurSegment(O, O2, 0.2)\n    const N = pointSurSegment(O, O3, 0.2)\n    if (this.y(M) > this.y(N)) {\n      this.trait(O, M)\n    } else {\n      this.trait(O, N)\n    }\n    this.regleMasquer()\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A)\n      this.equerreMontrer()\n      this.equerreRotation(B)\n    } else {\n      this.equerreDeplacer(B)\n      this.equerreMontrer()\n      this.equerreRotation(A)\n    }\n    this.equerreDeplacer(O)\n    this.crayonDeplacer(O)\n    this.trait(O, O2)\n    this.equerreMasquer()\n    this.regleDroite(O2, O3)\n    this.regleMasquer()\n    this.segmentCodage(A, O, codage)\n    this.segmentCodage(O, B, codage)\n    this.codageAngleDroit(A, O, O2)\n  }\n  /**\n   * Trace la hauteur issue de C dans un triangle ABC. Prolonge si besoin le segment [AB] pour avoir le pied de la hauteur et le codage de l'angle droit.\n   * @param {point} A 1er point de la base\n   * @param {point} B 2e point de la base\n   * @param {point} C Sommet dont est issue la hauteur\n   * @param {booléen} codage angle droit ajouté si true\n   */\n  this.hauteur = function (A, B, C, codage = true) {\n    const d = droite(A, B)\n    d.isVisible = false\n    const H = projectionOrtho(C, d)\n    let G, D\n    if (this.x(A) < this.x(B)) {\n      G = A\n      D = B\n    } else {\n      G = B\n      D = A\n    }\n    if (this.x(H) < this.x(G)) { // si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G, longueur(G, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)\n    }\n    if (this.x(H) > this.x(D)) { // si le pied de la hauteur est trop à droite\n      this.regleProlongerSegment(G, D, longueur(D, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true)\n    }\n    if (this.x(H) < this.x(G) || this.x(H) > this.x(D)) {\n      this.regleMasquer()\n    }\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A)\n      this.equerreMontrer()\n      this.equerreRotation(B)\n    } else {\n      this.equerreDeplacer(B)\n      this.equerreMontrer()\n      this.equerreRotation(A)\n    }\n    this.equerreDeplacer(H)\n    this.crayonMontrer()\n    this.crayonDeplacer(H)\n    this.trait(H, C)\n    this.equerreMasquer()\n    if (codage) {\n      this.codageAngleDroit(A, H, C)\n    }\n    this.crayonMasquer()\n  }\n  /**\n * Trace la médiane issue de C passant par le milieu de [AB]\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} options\n */\n  this.mediane = function (A, B, C, options = {}) {\n    if (options.codage === undefined) {\n      options.codage = 'X'\n    }\n    if (options.couleurTraitsDeConstruction === undefined) {\n      options.couleurTraitsDeConstruction = this.couleurTraitsDeConstruction\n    }\n    if (options.epaisseurTraitsDeConstruction === undefined) {\n      options.epaisseurTraitsDeConstruction = this.epaisseurTraitsDeConstruction\n    }\n    const O = milieu(A, B)\n    this.regleMontrer(A, options)\n    this.regleRotation(B, options)\n    this.crayonMontrer()\n    const O2 = rotation(A, O, -90)\n    const O3 = rotation(A, O, 90)\n    const M = pointSurSegment(O, O2, 0.2)\n    const N = pointSurSegment(O, O3, 0.2)\n    if (M.y > N.y) {\n      this.trait(O, M, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })\n    } else {\n      this.trait(O, N, { vitesse: options.vitesse, tempo: options.tempo, couleur: options.couleurTraitsDeConstruction, epaisseur: options.epaisseurTraitsDeConstruction })\n    }\n    this.regleSegment(O, C, options)\n    if (options.codage) {\n      this.segmentCodage(A, O, options)\n      this.segmentCodage(O, B, options)\n    }\n  }\n  /**\n * Trace la bissectrice de l'angle ABC au compas.\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} param3\n * @returns {objet} {arc1, arc2, arc3, arc4}\n */\n  this.bissectriceAuCompas = function (A, B, C, { codage = '/', l = 2, couleur = this.couleur, tempo = this.tempo, vitesse = this.vitesse, sens = calcul(this.vitesse / 2, 0), epaisseur = this.epaisseur, pointilles = this.pointilles, couleurCodage = this.couleurCodage, masquerTraitsDeConstructions = true } = {}) {\n    const A1 = pointSurSegment(B, A, l)\n    const C1 = pointSurSegment(B, C, l)\n    // const demiangle = calcul(angleOriente(A, B, C) / 2);\n    const angle = angleOriente(A, B, C)\n    const M = rotation(B, A1, -(180 - angle))\n    const options = { couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, pointilles: false }\n    const arc1 = this.compasTracerArcCentrePoint(B, A1, options)\n    const arc2 = this.compasTracerArcCentrePoint(B, C1, options)\n    const arc3 = this.compasTracerArcCentrePoint(A1, M, options)\n    const arc4 = this.compasTracerArcCentrePoint(C1, M, options)\n    this.compasMasquer()\n    this.regleDemiDroiteOriginePoint(B, M, { longueur: longueur(B, A), couleur: couleur, tempo: tempo, vitesse: vitesse, sens: sens, epaisseur: epaisseur, pointilles: pointilles })\n    this.regleMasquer()\n    this.crayonMasquer()\n    if (codage) {\n      this.angleCodage(A, B, M, { couleur: couleurCodage, codage: codage, tempo: tempo })\n      this.angleCodage(M, B, C, { couleur: couleurCodage, codage: codage, tempo: tempo })\n    }\n    if (masquerTraitsDeConstructions) {\n      this.traitMasquer(arc1)\n      this.traitMasquer(arc2)\n      this.traitMasquer(arc3)\n      this.traitMasquer(arc4)\n    }\n    return { arc1: arc1, arc2: arc2, arc3: arc3, arc4: arc4 }\n  }\n  /**\n * Construit les 3 médiatrices des côtés du triangle ABC puis le cercle circonscrit au triangle\n * @param {point} A\n * @param {point} B\n * @param {point} C\n * @param {objet} options\n */\n  this.cercleCirconscrit = function (A, B, C, options = {}) {\n    if (options.couleur === undefined) {\n      options.couleur = this.couleur\n    }\n    if (options.couleurMediatrice === undefined) {\n      options.couleurMediatrice = options.couleur\n    }\n    if (options.couleurCercle === undefined) {\n      options.couleurCercle = options.couleur\n    }\n    options.codage = 'X'\n    options.couleur = options.couleurMediatrice\n    const m1 = this.mediatriceAuCompas(A, B, options)\n    this.traitMasquer(m1[0]) // On cache les arcs de cercle une fois la médiatrice tracée\n    this.traitMasquer(m1[1])\n    this.traitMasquer(m1[2])\n    this.traitMasquer(m1[3])\n    options.codage = '||'\n    const m2 = this.mediatriceAuCompas(B, C, options)\n    this.traitMasquer(m2[0])\n    this.traitMasquer(m2[1])\n    this.traitMasquer(m2[2])\n    this.traitMasquer(m2[3])\n    options.codage = '///'\n    const m3 = this.mediatriceAuCompas(A, C, options)\n    this.traitMasquer(m3[0])\n    this.traitMasquer(m3[1])\n    this.traitMasquer(m3[2])\n    this.traitMasquer(m3[3])\n    const O = centreCercleCirconscrit(A, B, C)\n    options.couleur = options.couleurCercle\n    this.compasCercleCentrePoint(O, A, options)\n  }\n\n  /**\n *****************************************\n ************** TRIANGLES ****************\n *****************************************\n */\n\n  /**\n   * Macro de construction d'un triangle à partir de ses 3 dimensions. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BC Distance entre le 2e et le 3e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle3longueurs = function (ABC, AB, AC, BC, description = true) {\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, randint(-20, 20))\n    const p = triangle2points2longueurs(A, B, AC, BC)\n    const C = p.listePoints[2]\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)\n    this.pointCreer(A)\n    // this.regleRotation(droite(A,B).angleAvecHorizontale)\n    // this.regleMontrer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.crayonMasquer()\n    if (description) this.textePosition(`${A.nom + C.nom} = ${nombreAvecEspace(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${nombreAvecEspace(AC)} cm.`, 0, -3)\n    this.couleur = 'forestgreen'\n    this.epaisseur = 2\n    this.compasMontrer(A)\n    this.compasEcarterAvecRegle(AC)\n    this.compasTracerArcCentrePoint(A, C, 40)\n    if (description) this.textePosition(`${B.nom + C.nom} = ${nombreAvecEspace(BC)} cm donc ${C.nom} appartient au cercle de centre ${B.nom} et de rayon ${nombreAvecEspace(BC)} cm.`, 0, -4)\n    this.compasDeplacer(B)\n    this.compasEcarterAvecRegle(BC)\n    this.compasTracerArcCentrePoint(B, C)\n    this.compasMasquer()\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    if (description) this.textePosition(`Le point ${C.nom} est à une intersection des deux cercles.`, 0, -5)\n    this.pointCreer(C)\n    this.regleSegment(B, C)\n    this.regleSegment(C, A)\n    this.crayonMasquer()\n    this.regleMasquer()\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur d'un côté et de la longueur de l'hypoténuse.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangleRectangleCoteHypotenuse = function (ABC, AB, AC, description = true) { // Triangle rectangle en B\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, randint(-20, 20))\n    const dAB = droite(A, B)\n    dAB.isVisible = false\n    const dBC = droiteParPointEtPerpendiculaire(B, dAB)\n    dBC.isVisible = false\n    const cAC = cercle(A, AC)\n    cAC.isVisible = false\n    const C = pointIntersectionLC(dBC, cAC)\n    const c = homothetie(C, B, 1.2)\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if (longueur(A, C) > 8) this.equerreZoom(150)\n    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)\n    this.equerreRotation(dAB.angleAvecHorizontale)\n    this.pointCreer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)\n    this.equerreMontrer(A)\n    this.equerreDeplacer(B)\n    this.tracer(c)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, B, C)\n    this.crayonMasquer()\n    if (description) this.textePosition(`${A.nom + C.nom} = ${nombreAvecEspace(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${nombreAvecEspace(AC)} cm.`, 0, -4)\n    this.compasMontrer(A)\n    this.compasEcarterAvecRegle(AC)\n    this.couleur = 'forestgreen'\n    this.epaisseur = 2\n    this.compasTracerArcCentrePoint(A, C)\n    this.couleur = 'blue'\n    this.epaisseur = 2\n    if (description) this.textePosition(`${C.nom} est à une intersection de la perpendiculaire et du cercle.`, 0, -5)\n    this.crayonMontrer(C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleMasquer()\n    this.crayonMasquer()\n    return [A, B, C]\n  }\n\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur des deux côtés de l'angle droit.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangleRectangle2Cotes = function (ABC, AB, BC, description = true) { // Triangle rectangle en B\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, randint(-20, 20))\n    const dAB = droite(A, B)\n    dAB.isVisible = false\n    const dBC = droiteParPointEtPerpendiculaire(B, dAB)\n    dBC.isVisible = false\n    const cBC = cercle(B, BC)\n    cBC.isVisible = false\n    const C = pointIntersectionLC(dBC, cBC)\n    const c = homothetie(C, B, 1.2)\n    if (ABC.length !== 3) {\n      description = false\n    } else {\n      A.nom = ABC[0]\n      B.nom = ABC[1]\n      C.nom = ABC[2]\n    }\n\n    if (longueur(A, C) > 8) this.equerreZoom(150)\n    if (description) this.textePosition(`${A.nom + B.nom} = ${nombreAvecEspace(AB)} cm`, 0, -2)\n    this.equerreRotation(dAB.angleAvecHorizontale)\n    this.pointCreer(A)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3)\n    this.equerreMontrer(A)\n    this.equerreDeplacer(B)\n    this.tracer(c)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, B, C)\n    if (description) this.textePosition(`${B.nom + C.nom} = ${nombreAvecEspace(BC)} cm donc ${C.nom} est à ${nombreAvecEspace(BC)} cm de ${B.nom} sur la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -4)\n    this.regleMontrer(B)\n    this.regleRotation(C)\n    this.crayonDeplacer(C)\n    this.pointCreer(C)\n    this.couleur = 'blue'\n    this.epaisseur = 2\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleMasquer()\n    this.crayonMasquer()\n\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle à partir d'une longueur et des 2 angles adajcents au côté connu. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {*} CBA Angle au 2e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle1longueur2angles = function (NOM, AB, BAC, CBA, description = true, mesure = false) {\n    const angle = randint(-20, 20)\n    const a1 = BAC\n    const a2 = CBA\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, angle)\n    const D = pointAdistance(A, 5.2, a1 + angle)\n    const D2 = pointSurSegment(A, D, 10)\n    const D1 = pointSurSegment(D, D2, 0.4)\n    const E = pointAdistance(B, 3, 180 - a2 + angle)\n    const E2 = pointSurSegment(B, E, 10)\n    const E1 = pointSurSegment(E, E2, -0.4)\n    const F = pointAdistance(B, 5.2, 180 - a2 + angle)\n    const F1 = pointSurSegment(F, E2, 0.4)\n    const d = rotation(droite(A, B), A, a1)\n    D.isVisible = false\n    const d2 = rotation(droite(B, A), B, -a2)\n    d2.isVisible = false\n    const C = pointIntersectionDD(d, d2)\n    if (NOM.length !== 3) {\n      description = false\n    } else {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(A)\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${nombreAvecEspace(AB)} cm.`, 0, -4)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.couleur = 'grey'\n    this.epaisseur = 1\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(A)\n    this.rapporteurRotation(angle)\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)\n    this.epaisseur = 3\n    this.trait(D, D1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleSegment(A, D2)\n    this.regleMasquer()\n    this.angleCodage(B, A, C)\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(B)\n    if (description) this.textePosition(`On place un repère à ${a2} degrés pour tracer la demi-droite [${B.nom + C.nom}).`, 0, -6)\n    this.epaisseur = 3\n    this.trait(E, E1, 10)\n    this.trait(F, F1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleMontrer(B)\n    this.regleSegment(B, E2)\n    this.angleCodage(C, B, A)\n    this.pointCreer(C, '', 0)\n    this.pointNommer(C, C.nom, -0.5, 1)\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.regleSegment(B, C)\n    this.regleSegment(C, A)\n    this.regleMasquer()\n    this.crayonMasquer()\n    if (description && mesure) this.textePosition(`On peut mesurer ${A.nom + C.nom} ≈ ${nombreAvecEspace(longueur(A, C, 1))} cm et ${B.nom + C.nom} ≈ ${nombreAvecEspace(longueur(B, C, 1))} cm.`, 0, -7)\n\n    return [A, B, C]\n  }\n  /**\n   * Macro de construction d'un triangle à partir des longueurs des deux côtés d'un angle Le premier point a pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n  this.triangle2longueurs1angle = function (NOM, AB, AC, BAC, description = true, mesure = false) {\n    const angle = randint(-20, 20)\n    const a1 = BAC\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, angle)\n    const D = pointAdistance(A, 5.2, a1 + angle)\n    const D2 = pointSurSegment(A, D, 10)\n    const D1 = pointSurSegment(D, D2, 0.4)\n    const C = pointSurSegment(A, D2, AC)\n    if (NOM.length !== 3) {\n      description = false\n    } else {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(A)\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${nombreAvecEspace(AB)} cm.`, 0, -4)\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.couleur = 'grey'\n    this.epaisseur = 1\n    this.rapporteurMontrer(A)\n    this.rapporteurDeplacer(A)\n    this.rapporteurRotation(angle)\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5)\n    this.epaisseur = 3\n    this.trait(D, D1, 20)\n    this.epaisseur = 1\n    this.rapporteurMasquer()\n    this.regleSegment(A, D2)\n    this.angleCodage(B, A, C)\n    this.rapporteurMasquer()\n    if (description) this.textePosition(`On place le point ${C.nom} sur la demi-droite [${A.nom + C.nom}) à ${AC} cm de ${A.nom}.`, 0, -6)\n    this.epaisseur = 3\n    this.couleur = 'blue'\n    this.crayonDeplacer(C)\n    this.pointCreer(C)\n    this.regleSegment(A, C)\n    this.crayonMasquer()\n    if (description) this.textePosition(`On trace le côté [${B.nom + C.nom}].`, 0, -7)\n    this.regleMontrer(C)\n    this.crayonMontrer(C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    return [A, B, C]\n  }\n\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de 2 points\n   * @param {point} A\n   * @param {point} B\n   * @param {string} nomC\n   * @return {array} [A, B, C]\n   */\n  this.triangleEquilateral2Sommets = function (A, B, nomC = '') {\n    const C = rotation(B, A, 60)\n    C.nom = nomC\n    this.traitRapide(A, B)\n    this.pointCreer(A, A.nom, 0)\n    this.pointCreer(B, B.nom, 0)\n    this.compasEcarter2Points(A, B)\n    this.compasTracerArcCentrePoint(A, C)\n    this.compasTracerArcCentrePoint(B, C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, C)\n    this.segmentCodage(B, C)\n    return [A, B, C]\n  }\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de la longueur du côté. Le premier point a pour coordonnées (6;0)\n   * @param {string} NOM\n   * @param {number} AB\n   * @return {array} [A, B, C]\n   */\n\n  this.triangleEquilateral = function (NOM, AB) {\n    const A = point(6, 0)\n    const B = pointAdistance(A, AB, randint(-20, 20))\n    const C = rotation(B, A, 60)\n    if (NOM.length === 3) {\n      A.nom = NOM[0]\n      B.nom = NOM[1]\n      C.nom = NOM[2]\n    }\n    this.regleSegment(A, B)\n    this.pointCreer(A)\n    this.pointCreer(B)\n    this.compasEcarter2Points(A, B)\n    this.compasTracerArcCentrePoint(A, C)\n    this.compasTracerArcCentrePoint(B, C)\n    this.pointCreer(C)\n    this.compasMasquer()\n    this.regleSegment(A, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, C)\n    this.segmentCodage(B, C)\n    return [A, B, C]\n  }\n\n  /**\n ************************************************\n ************** PARALLELOGRAMMES ****************\n ************************************************\n */\n\n  /**\n   * Trace un parallélogramme à partir de la donnée de 3 sommets consécutifs\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {string} nomD\n   * @param {boolean} description\n   * @param {boolean} csDejaTraces À true (par défaut), les 2 côtés seront faits immédiatement, sinon, on les tracera à la règle.\n   */\n  this.parallelogramme3sommetsConsecutifs = function (A, B, C, nomD = '', description = true, csDejaTraces = true) {\n    const D = translation2Points(C, B, A)\n    D.nom = nomD\n    const xMin = Math.min(A.x, B.x, C.x, D.x)\n    const yMin = Math.min(A.y, B.y, C.y, D.y)\n    // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n    this.traitRapide(A, B)\n    this.traitRapide(B, C)\n    this.pointCreer(A, A.nom, 0)\n    this.pointCreer(B, B.nom, 0)\n    this.pointCreer(C, C.nom, 0)\n    this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses côtés opposés sont de même longueur.`, xMin - 1, yMin - 1)\n    this.compasEcarter2Points(B, A)\n    this.textePosition(`${B.nom + A.nom} = ${C.nom + D.nom}`, xMin - 1, yMin - 2)\n    this.compasTracerArcCentrePoint(C, D)\n    this.compasEcarter2Points(B, C)\n    this.textePosition(`${B.nom + C.nom} = ${A.nom + D.nom}`, xMin - 1, yMin - 3)\n    this.compasTracerArcCentrePoint(A, D, 10)\n    this.pointCreer(D)\n    this.compasMasquer()\n    this.regleSegment(C, D)\n    this.regleSegment(D, A)\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, B, { codage: '///', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(D, C, { codage: '///', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(B, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(A, D, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n  }\n  /**\n   * Trace le parallélogramme ABCD de centre O à partir de [AB] et O.\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   * @param {string} nomC\n   * @param {string} nomD\n   * @param {boolean} description\n   */\n  this.parallelogramme2sommetsConsecutifsCentre = function (A, B, O, nomC = '', nomD = '', description = true) {\n    const C = translation2Points(O, A, O)\n    C.nom = nomC\n    const D = translation2Points(O, B, O)\n    D.nom = nomD\n    const nom = A.nom + B.nom + C.nom + D.nom\n    if (longueur(A, C) > 12 || longueur(B, D) > 12) {\n      this.regleModifierLongueur(30)\n    }\n    const xMin = Math.min(A.x, B.x, C.x, D.x)\n    const yMin = Math.min(A.y, B.y, C.y, D.y)\n    // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n    this.traitRapide(A, B)\n    this.pointCreer(A, { tempo: 0 })\n    this.pointCreer(B, { tempo: 0 })\n    this.pointCreer(O, { tempo: 0 })\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses diagonales se coupent en leur milieu.`, xMin - 1, yMin - 1)\n    }\n    this.pointilles = true\n    this.epaisseur = 1\n    this.couleur = this.couleurTraitsDeConstruction\n    this.regleDemiDroiteOriginePoint(A, O, { longueur: longueur(A, C) + 3 })\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.compasEcarter2Points(A, O)\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + O.nom} = ${O.nom + C.nom}`, xMin - 1, yMin - 2)\n    }\n    this.pointilles = false\n    this.compasTracerArcCentrePoint(O, C)\n    this.compasMasquer()\n    this.pointilles = true\n    this.regleDemiDroiteOriginePoint(B, O, { longueur: longueur(B, D) + 3 })\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.pointilles = false\n    this.compasEcarter2Points(B, O)\n    if (description && nom.length === 4) {\n      this.textePosition(`${B.nom + O.nom} = ${O.nom + D.nom}`, xMin - 1, yMin - 3)\n    }\n    this.compasTracerArcCentrePoint(O, D)\n    this.compasMasquer()\n    this.couleur = 'blue'\n    this.epaisseur = 3\n    this.pointCreer(D)\n    this.regleSegment(A, D)\n    this.regleSegment(D, C)\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.compasMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(A, O, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(O, C, { codage: '//', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(B, O, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })\n    this.segmentCodage(O, D, { codage: 'O', couleur: this.couleurCodage, tempo: 0 })\n  }\n  /**\n   * Trace la parallélogramme ABCD de centre O en partant de [AD), [AB) et O (mais sans voir la position de B et D au départ)\n   * @param {point} D\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   */\n  this.parallelogrammeAngleCentre = function (D, A, B, O) {\n    const B1 = pointSurSegment(A, B, longueur(A, B) + 2)\n    const D1 = pointSurSegment(A, D, longueur(A, D) + 2)\n    const C = translation2Points(B, A, D)\n    this.traitRapide(A, B1)\n    this.traitRapide(A, D1)\n    this.pointCreer(O, { tempo: 0 })\n    this.pointCreer(A, { tempo: 0 })\n    this.regleDemiDroiteOriginePoint(A, O, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1, pointilles: true })\n    this.pointilles = false\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.compasEcarter2Points(A, O)\n    this.compasTracerArcCentrePoint(O, C, { couleur: this.couleurTraitsDeConstruction })\n    this.compasMasquer()\n    this.paralleleRegleEquerre2points3epoint(B1, A, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.equerreMasquer()\n    this.regleDroite(C, D, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.paralleleRegleEquerre2points3epoint(A, D1, C, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.equerreMasquer()\n    this.regleDroite(C, B, { couleur: this.couleurTraitsDeConstruction, epaisseur: 1 })\n    this.pointCreer(D, { tempo: 0 })\n    this.pointCreer(B, { tempo: 0 })\n    this.pointCreer(C, { tempo: 0 })\n    this.regleSegment(B, C)\n    this.regleSegment(C, D)\n    this.regleMasquer()\n    this.crayonMasquer()\n  }\n\n  /**\n   ************************************************\n   ************** Carrés ****************\n   ************************************************\n   */\n\n  /**\n   * Macro crée par Sophie Desruelle\n   * @param {objet} A\n   * @param {number} c\n   * @returns polygoneAvecNom\n   */\n  this.carre1point1longueur = function (nom, A, c) {\n    const interligne = 1\n    A = point(5, 0, nom[0])\n    const B = pointAdistance(A, c, randint(-20, 20), nom[1])\n    const C = rotation(A, B, -90, nom[2])\n    const D = rotation(B, A, 90, nom[3])\n    const E = pointSurSegment(A, D, c + 2, 'E')\n    const F = pointSurSegment(D, C, c + 2, 'F')\n    this.equerreZoom((c + 3) * 100 / 7.5)\n    this.tempo = 20\n\n    this.textePosition(`1) On veut construire un carré dont les côtés mesurent ${c} cm, donc on commence par tracer un segment, ici [${nom[0] + nom[1]}], de cette longueur.`, 0, -2)\n\n    this.pointCreer(A, { tempo: 0 }) // On coupe la pause pour ne pas voir le déplacement du point\n    this.pointNommer(A, A.nom, { dx: -0.5, dy: 0 }) // On déplace le label du point A vers la gauche\n    this.regleSegment(A, B)\n    this.pointCreer(B)\n    this.regleMasquer()\n    this.longueurSegment(A, B, -1)\n\n    this.textePosition(`2) Un carré possède 4 angles droits, donc on trace la perpendiculaire à (${nom[0] + nom[1]}) passant par ${nom[0]}.`, 0, -2 - 1 * interligne)\n\n    this.equerreMontrer()\n    this.equerreDeplacer(A)\n    this.equerreRotation(B)\n    this.trait(A, E)\n    this.equerreMasquer()\n    this.codageAngleDroit(B, A, D)\n\n    this.textePosition(`3) Les 4 côtés d'un carré sont de la même longueur, donc on place le point ${nom[3]} sur cette perpendiculaire, à ${c} cm de ${nom[0]}.`, 0, -2 - 2 * interligne)\n\n    this.regleSegment(A, D)\n    this.pointCreer(D, { tempo: 0 })\n    this.pointNommer(D, D.nom, { dx: -0.7, dy: 0.5 })\n    this.regleMasquer()\n    this.segmentCodage(A, B)\n    this.segmentCodage(A, D)\n\n    this.textePosition(`4) De même, on trace la perpendiculaire à (${nom[0] + nom[3]}) passant par ${nom[3]}, puis on place le point ${nom[2]} sur cette perpendiculaire, à ${c} cm de ${nom[3]}.`, 0, -2 - 3 * interligne)\n\n    this.equerreMontrer()\n    this.equerreDeplacer(D)\n    this.equerreRotation(A)\n    this.trait(D, F)\n    this.equerreMasquer()\n    this.codageAngleDroit(A, D, C)\n\n    this.regleSegment(D, C)\n    this.pointCreer(C, { tempo: 0 })\n    this.pointNommer(C, C.nom, { dx: 0, dy: 0.9 })\n    this.regleMasquer()\n    this.segmentCodage(D, C)\n\n    this.textePosition(`5) On trace le segment [${nom[1] + nom[2]}].`, 0, -2 - 4 * interligne)\n\n    this.regleSegment(C, B)\n    this.regleMasquer()\n    this.segmentCodage(B, C)\n\n    this.textePosition(`6) On vérifie que ${nom[1] + nom[2]} = ${c} cm et que les deux derniers angles tracés sont droits.`, 0, -2 - 5 * interligne)\n\n    this.equerreMontrer(C, { tempo: 0 })\n    this.equerreRotation(D)\n    this.equerreMasquer()\n    this.codageAngleDroit(D, C, B)\n\n    this.equerreMontrer(B, { tempo: 0 })\n    this.equerreRotation(C)\n    this.equerreMasquer()\n    this.codageAngleDroit(C, B, A)\n    return polygoneAvecNom(A, B, C, D)\n  }\n\n  /********************************************/\n  /** *********** Transformations **************/\n  /********************************************/\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de la rotation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @author Jean-Claude Lhote\n   */\n  this.rotationPoint = function (p, centre, angle, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = true } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = rotation(p, centre, angle, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    this.regleSegment(centre, p) // On trace le support du rapporteur\n    this.rapporteurMontrer(centre)\n    this.rapporteurTracerDemiDroiteAngle(centre, p, angle) // On trace le deuxième côté\n    this.regleMasquer()\n    this.rapporteurMasquer()\n    this.compasEcarter2Points(centre, p) // on prend l'écartement du compas\n    this.compasTracerArcCentrePoint(centre, image) // On fait l'arc qui coupe la demi-droite\n    this.compasMasquer()\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // On marque le point image (qui est nommé)\n    if (codage) {\n      if (Math.abs(angle) === 90) {\n        this.codageAngleDroit(p, centre, image, { couleur: couleurCodage })\n      } else {\n        this.angleCodage(p, centre, image, { couleur: couleurCodage })\n        this.textePoint(Math.abs(angle) + '°', translation(homothetie(rotation(p, centre, angle / 2), centre, 1.3 / longueur(centre, p)), vecteur(-0.2, 0.5)))\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {objet} p point dont on construit l'image et qui doit être tracé.\n   * @param {objet} d axe de symétrie.\n   * @param {string} nom nom de l'image\n   * @param {objet} options couleur et couleurCodage\n   * @author Liouba Leroux et Jean-Claude Lhote\n   */\n  this.symetrieAxialePoint = function (p, d, nom, { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = '//' } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = symetrieAxiale(p, d, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if (longueur(p, image) !== 0) {\n      const M = milieu(p, image) // on crée le point milieu\n      const N = rotation(p, M, 90)\n      const D = rotation(N, M, 180)\n      this.regleMasquerGraduations()\n      this.perpendiculaireRegleEquerre2points3epoint(N, D, p)\n      this.compasEcarter2Points(M, p)\n      this.compasTracerArcCentrePoint(M, image)\n      this.regleSegment(p, image)\n      this.regleMasquer()\n      this.equerreMasquer()\n      this.segmentCodage(p, M, { codage: codage, couleur: couleurCodage })\n      this.segmentCodage(image, M, { codage: codage, couleur: couleurCodage })\n      this.crayonMasquer()\n      this.compasMasquer()\n    }\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n  }\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} le point de départ de la translation\n   * @param {objet} le point d'arrivée de la translation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @author Jean-Claude Lhote\n   */\n  this.translationPoint = function (p, A, B, nom, { couleur = 'black', couleurCodage = this.couleurCodage } = {}) {\n    const v = vecteur(A, B)\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = translation(p, v, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if (longueur(A, p) !== 0) { // si le point de départ A est l'antécédent, alors le point d'arrivée B est l'image... pas besoin de construction\n      this.compasEcarter2Points(A, p)\n      this.compasTracerArcCentrePoint(B, image)\n      this.compasEcarter2Points(A, B)\n      this.compasTracerArcCentrePoint(p, image)\n    }\n    this.compasMasquer()\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur })\n    const choix1 = randint(0, 4)\n    const choix2 = randint(0, 4, choix1)\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    const marque1 = marques[choix1]\n    const marque2 = marques[choix2]\n    this.couleur = 'green'\n    this.traitRapide(p, image)\n    this.traitRapide(A, B)\n    this.segmentCodage(p, image, { codage: marque1, couleur: couleurCodage })\n    this.segmentCodage(A, B, { codage: marque1, couleur: couleurCodage })\n    this.couleur = 'red'\n    this.traitRapide(B, image)\n    this.traitRapide(A, p)\n    this.segmentCodage(B, image, { codage: marque2, couleur: couleurCodage })\n    this.segmentCodage(A, p, { codage: marque2, couleur: couleurCodage })\n  }\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de symétrie\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur, couleurCodage et codage\n   * @author Jean-Claude Lhote\n   */\n  this.demiTourPoint = function (p, centre, nom, { couleur = 'black', couleurCodage = this.couleurCodage, codage = '//' } = {}) {\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = rotation(p, centre, 180, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    this.compasEcarter2Points(centre, p)\n    this.compasTracerArcCentrePoint(centre, image)\n    this.compasMasquer()\n    this.crayonDeplacer(p)\n    this.regleSegment(p, image)\n    this.couleur = couleur\n    this.epaisseur = 2\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.segmentCodage(p, centre, { codage: codage, couleur: couleurCodage })\n    this.segmentCodage(centre, image, { codage: codage, couleur: couleurCodage })\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n  this.homothetiePoint = function (p, centre, k, nom, { couleur = this.couleur, positionTexte = { x: 0, y: 0 } } = {}) {\n    this.epaisseur = 1 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    const couleurSave = this.couleur\n    this.couleur = 'grey'\n    let t\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\"\n    }\n    const image = homothetie(p, centre, k, nom) // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n    if (k > 0) {\n      t = this.textePosition(`Comme le rapport est positif alors les points ${p.nom} et ${image.nom} sont du même côté de ${centre.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })\n    } else {\n      t = this.textePosition(`Comme le rapport est négatif alors ${centre.nom} est entre les points ${p.nom} et ${image.nom}`, positionTexte.x, positionTexte.y, { taille: 15 })\n    }\n    this.regleSegment(p, centre)\n    const l = arrondi(longueur(p, centre), 1)\n    const lprime = arrondi(calcul(l * Math.abs(k)))\n    const t1 = this.textePosition(`La mesure de ${centre.nom}${p.nom} est ${texNombre(arrondi(l, 1))} cm et le rapport de l'homothetie est ${texNombre(k)}`, positionTexte.x, positionTexte.y - 1, { taille: 15 })\n    const t2 = this.textePosition(`donc ${centre.nom}${image.nom} mesure ${texNombre(l)} cm × ${texNombre(Math.abs(k))} = ${texNombre(lprime)} cm`, positionTexte.x, positionTexte.y - 2, { taille: 15 })\n    this.regleSegment(centre, image)\n    this.pointCreer(image, { couleur: couleur, couleurLabel: couleur }) // on construit l'image\n    this.regleMasquer()\n    this.crayonMasquer()\n    this.pause()\n    this.texteMasquer(t1)\n    this.texteMasquer(t2)\n    this.texteMasquer(t)\n    this.couleur = couleurSave\n  }\n  /**\n   *\n   * @param {objet} p le polygone qui est déjà tracé\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de rotation\n   * @author Jean-Claude Lhote\n   * @param {objet} param4 options couleur et couleurCodage\n  */\n  this.rotationPolygone = function (p, centre, angle, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    let nom\n    const p2 = rotation(p, centre, angle) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let i = 0; let codage\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      if (i < 1) {\n        codage = true\n      } else {\n        codage = false\n      }\n      if (longueur(centre, sommet) !== 0) {\n        this.rotationPoint(sommet, centre, angle, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })\n      }\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image et qui doit être tracé avec ses points nommés.\n   * @param {objet} d axe de symétrie.\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n   * @param {objet} param3 options couleur et couleurCodage\n   * @author Liouba Leroux et Jean-Claude Lhote\n   */\n  this.symetrieAxialePolygone = function (p, d, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    let nom\n    const p2 = symetrieAxiale(p, d) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    // const N = homothetie(milieu(p.listePoints[0], p2.listePoints[0]), milieu(p.listePoints[1], p2.listePoints[1]), 1.23456) // créer unh point de l'axe de symétrie pour les alignements et les mesure d'angles\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let i = 0\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.symetrieAxialePoint(sommet, d, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })\n      i++\n    }\n    this.compasMasquer()\n    this.crayonMasquer()\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image\n   * @param {objet} A point de départ de la translation\n   * @param {objet} B point d'arrivée de la translation\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n * @param {objet} param3 options couleur et couleurCodage\n * @author Jean-Claude Lhote\n*/\n  this.translationPolygone = function (p, A, B, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage, codage = 'O' } = {}) {\n    let nom\n    const v = vecteur(A, B)\n    const p2 = translation(p, v) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let i = 0\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.translationPoint(sommet, A, B, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: codage })\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)\n    i++\n  }\n  /**\n   *\n   * @param {objet} p  le polygone dont on veut construire l'image qui doit être tracé\n   * @param {objet} centre le centre de symétrie\n   * @param {array} noms les noms des sommets images (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur et couleurCodage\n   * @author Jean-Claude Lhote\n   */\n  this.demiTourPolygone = function (p, centre, noms = [], { couleur = this.couleur, couleurCodage = this.couleurCodage } = {}) {\n    const p2 = rotation(p, centre, 180) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 0.5 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    let nom\n    let i = 0\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\']\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.demiTourPoint(sommet, centre, nom, { couleur: couleur, couleurCodage: couleurCodage, codage: marques[i] })\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.polygoneRapide(p2)// figure svg de l'exercice\n  }\n\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n  this.homothetiePolygone = function (p, centre, k, noms = [], { couleur = this.couleur } = {}) {\n    let nom\n    const p2 = homothetie(p, centre, k) // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    this.epaisseur = 1 // épaisseur et couleur de crayon de papier bien taillé pour la construction\n    this.couleur = 'grey'\n    const t = this.textePosition('Comme k est ' + (k >= 0 ? 'positif' : 'négatif') + ' alors ' + (k >= 0 ? 'les figures sont du même côté de ' + centre.nom : centre.nom + ' est entre les figures'), 0, 0, { taille: 15 })\n    let i = 0\n    for (const sommet of p.listePoints) { // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i]\n      } else {\n        nom = sommet.nom + \"'\"\n      }\n      this.homothetiePoint(sommet, centre, k, nom, { couleur: couleur })\n      i++\n    }\n    this.epaisseur = 2\n    this.couleur = couleur\n    this.polygoneRapide(...p2.listePoints) // on trace le polygone image en bleu épaisseur 2\n    this.texteMasquer(t)\n  }\n  /** **** Fin de la classe Alea2iep */\n}\n"],"sourceRoot":""}