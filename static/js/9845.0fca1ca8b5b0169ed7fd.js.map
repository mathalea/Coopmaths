{"version":3,"sources":["webpack://mathalea/./src/js/exercices/ClasseExercice.js","webpack://mathalea/./src/js/exercices/beta/beta4C10-6.js"],"names":["Exercice","this","titre","consigne","consigneCorrection","listeQuestions","listeCorrections","introduction","contenu","contenuCorrection","nbQuestions","nbCols","nbColsCorr","spacing","spacingCorr","beamer","besoinFormulaireNumerique","besoinFormulaireTexte","besoinFormulaireCaseACocher","consigneModifiable","nbQuestionsModifiable","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","correctionDetailleeDisponible","correctionDetaillee","video","boutonAide","tailleDiaporama","pasDeVersionLatex","qcm","qcmDisponible","modeQcm","mg32Editable","nouvelleVersion","numeroExercice","listePackages","Exercice_tableau_multiplications_relatifs","sup","type_de_questions_disponibles","parseInt","listeTypeDeQuestions","combinaisonListes","texte","texteCorr","i","cpt","nbMax","num","Relatif","randint","lettre_tab","lettre","length","nom_expression","lettreDepuisChiffre","signe_expression","nb_termes","place_lettre","liste_nombres","relatifs","slice","liste_termes","indice","push","ecritureNombreRelatif","splice","signe_lettre","calcul_nombres","calcul","texte_en_couleur_et_gras","k","setRegleSigneProduit","getSigneProduitString","getSigneProduitNumber","nb_num","denom","setRegleSigneQuotient","nb_lettres","exp_lettre","indexOf","listeQuestionsToContenu"],"mappings":"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","file":"js/9845.0fca1ca8b5b0169ed7fd.js","sourcesContent":["/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nexport default function Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = ''\n  this.consigne = ''\n  this.consigneCorrection = ''\n  this.listeQuestions = []\n  this.listeCorrections = []\n  this.introduction = ''\n  this.contenu = ''\n  this.contenuCorrection = ''\n  this.nbQuestions = 10\n  this.nbCols = 2\n  this.nbColsCorr = 2\n  this.spacing = 1\n  this.spacingCorr = 1\n  this.beamer = false\n\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte];\n  this.consigneModifiable = true\n  this.nbQuestionsModifiable = true\n  this.nbColsModifiable = true\n  this.nbColsCorrModifiable = true\n  this.spacingModifiable = true\n  this.spacingCorrModifiable = true\n  this.correctionDetailleeDisponible = false\n  this.correctionDetaillee = true\n  this.video = ''\n  this.boutonAide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pasDeVersionLatex = false\n  this.qcm = false // Pour les exercices de type QCM : contient un tableau.\n  this.qcmDisponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n  this.modeQcm = false // Pour choisir la version QCM ou la version classique (false = version classique)\n\n  this.mg32Editable = false // pas d'interface par défaut pour les figures MG32\n  this.nouvelleVersion = function (numeroExercice) {}\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n","import Exercice from '../ClasseExercice.js';\nimport {listeQuestionsToContenu, randint, combinaisonListes,\n Relatif, lettreDepuisChiffre, ecritureNombreRelatif,\n texte_en_couleur_et_gras} from '../../modules/outils.js'\nexport const titre = 'Multiplications et quotients de relatifs : signe avec une lettre'\n\n/**\n* Effectuer des multiplications de relatifs dans un tableau à double entrée\n*\n* @Auteur Cédric GROLLEAU\n* 4C10-6\n*/\nexport default function Exercice_tableau_multiplications_relatifs() {\n  Exercice.call(this); // Héritage de la classe Exercice()\n  this.sup = 3;\n  this.titre = titre;\n  this.consigne = '';\n  this.correctionDetailleeDisponible = true;\n  this.correctionDetaillee = false;\n  this.spacing = 2;\n  this.nbQuestions = 3;\n  this.nbQuestionsModifiable = true;\n\n  this.nouvelleVersion = function () {\n    this.sup = parseInt(this.sup);\n\tthis.listeQuestions = []; // Liste de questions\n    this.listeCorrections = []; // Liste de questions corrigées\n    let type_de_questions_disponibles;\n\tswitch (this.sup) {\n        case 1: // multiplications\n          type_de_questions_disponibles = [1];\n          break;\n        case 2: // Quotient\n          type_de_questions_disponibles = [2];\n          break;\n        case 3: // multiplications et quotients\n          type_de_questions_disponibles = [1, 2];\n          break;\n        case 4: // avec puissances\n          type_de_questions_disponibles = [3, 4];\n          break;\n\t\tcase 5: // mélange\n          type_de_questions_disponibles = [1, 2, 3, 4];\n          break;\n     }\n\tlet listeTypeDeQuestions = combinaisonListes(type_de_questions_disponibles, this.nbQuestions);\n\tfor (let i = 0, texte, texteCorr, cpt = 0; i < this.nbQuestions && cpt < 50;) {\n\t\t// on ne choisit que des nombres compris entre 1 et 20\n\t\tlet nbMax = 20;\n\t\t// Le tableau des relatifs necessaires, il m'en faut max 5 !\n\t\tlet num = new Relatif(\n\t\trandint(-1, 1, [0]) * randint(1, nbMax),\n\t\trandint(-1, 1, [0]) * randint(1, nbMax),\n\t\trandint(-1, 1, [0]) * randint(1, nbMax),\n\t\trandint(-1, 1, [0]) * randint(1, nbMax),\n\t\trandint(-1, 1, [0]) * randint(1, nbMax)\n\t\t);\n\t\tlet lettre_tab = ['n','x','y','a','m'];\n\t\tlet lettre = lettre_tab[randint(0, lettre_tab.length-1)];\n\t\tlet nom_expression = lettreDepuisChiffre(i + 1);\n\t\tlet signe_expression = randint(-1, 1, [0]);\n\t\tlet nb_termes = listeTypeDeQuestions[i] == 1 ? randint(3, 5) : randint(4, 6);\n\t\tlet place_lettre = randint(0, nb_termes-1);\n\t\tlet liste_nombres = num.relatifs.slice(0,nb_termes-1);\n\t\tlet liste_termes = [];\n\t\tfor (let indice=0 ; indice < liste_nombres.length; indice++ ) {\n\t\t\tliste_termes.push(ecritureNombreRelatif(liste_nombres[indice]));\n\t\t}\n\t\tliste_termes.splice(place_lettre,0,lettre);\n\t\tlet calcul = \"\";\n\t\tlet signe_lettre, calcul_nombres;\n\t\ttexte = `Donne le signe de $ ${lettre} $ pour que ${nom_expression} soit ${signe_expression==-1 ? 'negatif' : 'positif'}. <br>`;\n\t\ttexteCorr = `${texte_en_couleur_et_gras(\"Supposons que \" + lettre + \" soit positif : \")}`; \n\t\tswitch (listeTypeDeQuestions[i]) {\n\t\t\tcase 1: // multiplications\n\t\t\t\tcalcul += `${liste_termes[0]} `;\n\t\t\t\tfor (let k=1; k<nb_termes ; k++) {\n\t\t\t\t\tcalcul += `\\\\times ${liste_termes[k]}`\n\t\t\t\t}\n\t\t\t\ttexte += ` ${nom_expression} = $ ${calcul} $ <br>`;\n\t\t\t\tif (this.correctionDetaillee) {\n\t\t\t\t\t//texteCorr += `<br> $ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n\t\t\t\t\t//for (let k=1; k<nb_termes-2 ; k++) {\n\t\t\t\t\t//\ttexteCorr += `  , $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n\t\t\t\t\t//}\n\t\t\t\t\t//texteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[parseInt(nb_termes-2)])} $ est ${num.getSigneString()[parseInt(nb_termes-2)]}`;\n\t\t\t\t\tliste_nombres.push(1);\n\t\t\t\t\ttexteCorr += `<br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\ttexteCorr += `<br><br> Donc si ${texte_en_couleur_et_gras(lettre +\" est positif\",\"black\")} $ ${calcul} $ est ${texte_en_couleur_et_gras(num.getSigneProduitString(...liste_nombres),\"black\")}.`;\n\t\t\t\t\ttexteCorr += `<br><br> ${texte_en_couleur_et_gras(\"Supposons maintenant que \" + lettre + \" soit négatif : \")}`;\n\t\t\t\t\t//texteCorr += ` $ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n\t\t\t\t\t//for (let k=1; k<nb_termes-1 ; k++) {\n\t\t\t\t\t//\ttexteCorr += `  , $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]} `\n\t\t\t\t\t//}\n\t\t\t\t\t//texteCorr += ` et ${lettre} est négatif.`;\n\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\ttexteCorr += `<br><br> Donc si ${texte_en_couleur_et_gras(lettre +\" est négatif\",\"black\")} $ ${calcul} $ est ${texte_en_couleur_et_gras(num.getSigneProduitString(...liste_nombres),\"black\")}.`;\n\t\t\t\t\ttexteCorr += `<br><br> ${texte_en_couleur_et_gras(\"Conclusion :\")} <br>` + texte_en_couleur_et_gras(`Il faut donc que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'négatif' : 'positif'} pour que ${nom_expression} soit ${signe_expression==-1 ? 'négatif' : 'positif'}`,\"black\");\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\ttexteCorr = `<br> Il faut que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'positif' : 'négatif'} pour que ${nom_expression} soit ${signe_expression==-1 ? 'négatif' : 'positif'}.`;\n\t\t\t\t}\n\t\t\t\tbreak;\t\t\t\t\n\t\t\tcase 2: // quotient de 2 produits\n\t\t\t\tcalcul += '\\\\dfrac {' + liste_termes[0];\n\t\t\t\tlet nb_num = randint(2, nb_termes-2);\n\t\t\t\tfor (let k=1; k<nb_num+1 ; k++) {\n\t\t\t\t\tcalcul += `\\\\times ${liste_termes[k]}`\n\t\t\t\t}\n\t\t\t\tcalcul += '}{' + liste_termes[nb_num+1];\n\t\t\t\tfor (let denom=nb_num+2; denom<nb_termes ; denom++) {\n\t\t\t\t\tcalcul += `\\\\times ${liste_termes[denom]}`\n\t\t\t\t}\n\t\t\t\tcalcul += '}';\n\t\t\t\ttexte += ` ${nom_expression} = $ ${calcul} $ <br>`;\n\t\t\t\tif (this.correctionDetaillee) {\n\t\t\t\t\t//texteCorr += `$ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n\t\t\t\t\t//for (let k=1; k<nb_termes-1 ; k++) {\n\t\t\t\t\t//\ttexteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n\t\t\t\t\t//}\n\t\t\t\t\ttexteCorr += `<br> ${num.setRegleSigneQuotient(...liste_nombres)}`;\n\t\t\t\t\ttexteCorr += `<br><br> Donc si ${texte_en_couleur_et_gras(lettre+\" est positif\",\"black\")} $ ${calcul} $ est ${texte_en_couleur_et_gras(num.getSigneProduitString(...liste_nombres),\"black\")}.`;\n\t\t\t\t\ttexteCorr += `<br><br> ${texte_en_couleur_et_gras(\"Supposons maintenant que \" + lettre + \" soit négatif : \")}`\n\t\t\t\t\t//$ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n\t\t\t\t\t//for (let k=1; k<nb_termes-1 ; k++) {\n\t\t\t\t\t//\ttexteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n\t\t\t\t\t//}\n\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\ttexteCorr += `<br> ${num.setRegleSigneQuotient(...liste_nombres)}`;\n\t\t\t\t\ttexteCorr += `<br><br> Donc si ${texte_en_couleur_et_gras(lettre+\" est négatif\",\"black\")} $ ${calcul} $ est ${texte_en_couleur_et_gras(num.getSigneProduitString(...liste_nombres),\"black\")}.`;\n\t\t\t\t\ttexteCorr += `<br><br> ${texte_en_couleur_et_gras(\"Conclusion :\")} <br>` + texte_en_couleur_et_gras(`Il faut donc que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'négatif' : 'positif'} pour que ${nom_expression} soit ${signe_expression==-1 ? 'négatif' : 'positif'}`,\"black\");\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\ttexteCorr = `<br> Il faut que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'positif' : 'négatif'} pour que ${nom_expression} soit ${signe_expression==-1 ? 'négatif' : 'positif'}.`;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3: // produit avec plusieurs fois la lettre\n\t\t\t\tsigne_lettre = randint(-1, 1, [0]);\n\t\t\t\ttexte = `Donne le signe de ${nom_expression} si $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}. <br>`;\n\t\t\t\ttexteCorr = '';\n\t\t\t\tlet nb_lettres = randint(1,3);\n\t\t\t\tplace_lettre = randint(0, nb_termes-1);\n\t\t\t\tfor (let k=0; k<nb_lettres;k++) {\n\t\t\t\t  liste_termes.splice(place_lettre,0,lettre);\n\t\t\t\t}\n\t\t\t\tcalcul += `${liste_termes[0]} `;\n\t\t\t\tfor (let k=1; k<nb_termes+nb_lettres ; k++) {\n\t\t\t\t\tcalcul += `\\\\times ${liste_termes[k]}`\n\t\t\t\t}\n\t\t\t\tcalcul_nombres = `${liste_nombres[0]} `;\n\t\t\t\tfor (let k=1; k<nb_termes-1 ; k++) {\n\t\t\t\t\tcalcul_nombres += `\\\\times ${liste_nombres[k]}`\n\t\t\t\t}\n\t\t\t\ttexte += ` ${nom_expression} = $ ${calcul} $ <br>`;\n\t\t\t\tif (this.correctionDetaillee) {\n\t\t\t\t\tif (nb_lettres==1 || nb_lettres==3) {\n\t\t\t\t\t\ttexteCorr += `On trouve ${nb_lettres+1} fois le facteur $ ${lettre} $.<br> Or ${nb_lettres+1} est pair donc leur produit sera positif.`;\n\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calcul_nombres} $`;\n\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.`,\"black\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttexteCorr += `On trouve ${nb_lettres+1} fois le facteur $ ${lettre} $. <br> Or ${nb_lettres+1} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signe_lettre==-1 ? 'négatif' : 'positif'}.`;\n\t\t\t\t\t\tif (signe_lettre==-1) {\n\t\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`;\n\t\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}.`,\"black\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`;\n\t\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}.`,\"black\");\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (nb_lettres==1 || nb_lettres==3) {\n\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.<br>`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (signe_lettre==-1) {\n\t\t\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est négatif.<br>`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est positif.<br>`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4: // produit avec plusieurs fois la lettre\n\t\t\t\tsigne_lettre = randint(-1, 1, [0]);\n\t\t\t\ttexte = `Donne le signe de ${nom_expression} si $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}. <br>`;\n\t\t\t\ttexteCorr = '';\n\t\t\t\tlet exp_lettre = randint(2,7);\n\t\t\t\tif (place_lettre==0) {\n\t\t\t\t\t\tcalcul += liste_termes[0]+ \"^{\" + exp_lettre +\"}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcalcul += liste_termes[0];\n\t\t\t\t\t}\n\t\t\t\tfor (let k=1; k<nb_termes ; k++) {\n\t\t\t\t\tif (k==place_lettre) {\n\t\t\t\t\t\tcalcul += '\\\\times ' + liste_termes[k]+ \"^{\" + exp_lettre +\"}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcalcul += '\\\\times ' + liste_termes[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcalcul_nombres = `${liste_nombres[0]} `;\n\t\t\t\tfor (let k=1; k<nb_termes-1 ; k++) {\n\t\t\t\t\tcalcul_nombres += `\\\\times ${liste_nombres[k]}`\n\t\t\t\t}\n\t\t\t\ttexte += ` ${nom_expression} = $ ${calcul} $ <br>`;\n\t\t\t\tif (this.correctionDetaillee) {\n\t\t\t\t\tif (exp_lettre % 2 == 0) {\n\t\t\t\t\t\ttexteCorr += `On trouve ${exp_lettre} fois le facteur $ ${lettre} $.<br> Or ${exp_lettre} est pair donc leur produit sera positif.`;\n\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calcul_nombres} $`;\n\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.`,\"black\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttexteCorr += `On trouve ${exp_lettre} fois le facteur $ ${lettre} $. <br> Or ${exp_lettre} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signe_lettre==-1 ? 'négatif' : 'positif'}.`;\n\t\t\t\t\t\tif (signe_lettre==-1) {\n\t\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`;\n\t\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}.`,\"black\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`;\n\t\t\t\t\t\t\ttexteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`;\n\t\t\t\t\t\t\ttexteCorr += '<br><br>' + texte_en_couleur_et_gras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre==-1 ? 'négatif' : 'positif'}.`,\"black\");\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (exp_lettre % 2 == 0) {\n\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.<br>`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (signe_lettre==-1) {\n\t\t\t\t\t\t\tliste_nombres.push(-1);\n\t\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est négatif.<br>`;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est positif.<br>`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\t\n\t\t}\n\t\tif (this.listeQuestions.indexOf(texte) == -1) {\n\t\t// Si la question n'a jamais été posée, on en créé une autre\n\t\tthis.listeQuestions.push(texte);\n\t\tthis.listeCorrections.push(texteCorr);\n\t\ti++;\n\t\t}\n\t\tcpt++;\n    }\n\tlisteQuestionsToContenu(this);\n  }\n  this.besoinFormulaireNumerique = [\n    \"Niveau de difficulté\",\n    3,\n    '1 : Multiplications\\n2 : Quotients \\n3 : Multiplications et quotients \\n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \\n5 : Mélange ',\n  ];\n}\n\n\n"],"sourceRoot":""}