/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmathalea"] = self["webpackChunkmathalea"] || []).push([["src_js_exercices_ClasseExercice_js-src_js_modules_3d_js"],{

/***/ "./src/js/exercices/ClasseExercice.js":
/*!********************************************!*\
  !*** ./src/js/exercices/ClasseExercice.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Exercice)\n/* harmony export */ });\n/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nfunction Exercice() {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = '';\n  this.consigne = '';\n  this.consigneCorrection = '';\n  this.listeQuestions = [];\n  this.listeCorrections = [];\n  this.introduction = '';\n  this.contenu = '';\n  this.contenuCorrection = '';\n  this.nbQuestions = 10;\n  this.nbCols = 2;\n  this.nbColsCorr = 2;\n  this.spacing = 1;\n  this.spacingCorr = 1;\n  this.beamer = false;\n  this.besoinFormulaireNumerique = false; // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n\n  this.besoinFormulaireTexte = false; // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n\n  this.besoinFormulaireCaseACocher = false; // Sinon this.besoinFormulaireCaseACocher = [texte];\n\n  this.consigneModifiable = true;\n  this.nbQuestionsModifiable = true;\n  this.nbColsModifiable = true;\n  this.nbColsCorrModifiable = true;\n  this.spacingModifiable = true;\n  this.spacingCorrModifiable = true;\n  this.correctionDetailleeDisponible = false;\n  this.correctionDetaillee = true;\n  this.video = '';\n  this.boutonAide = false;\n  this.tailleDiaporama = 50; // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n\n  this.pasDeVersionLatex = false;\n  this.qcm = false; // Pour les exercices de type QCM : contient un tableau.\n\n  this.qcmDisponible = false; // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n\n  this.modeQcm = false; // Pour choisir la version QCM ou la version classique (false = version classique)\n\n  this.mg32Editable = false; // pas d'interface par défaut pour les figures MG32\n\n  this.nouvelleVersion = function (numeroExercice) {};\n\n  this.listePackages = []; // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZXhlcmNpY2VzL0NsYXNzZUV4ZXJjaWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0aGFsZWEvLi9zcmMvanMvZXhlcmNpY2VzL0NsYXNzZUV4ZXJjaWNlLmpzP2RiNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogIENsYXNzZSBwYXJlbnRlIGRlIHRvdXMgbGVzIGV4ZXJjaWNlc1xuICpcbiAqIEBBdXRldXIgUsOpbWkgQW5nb3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXhlcmNpY2UgKCkge1xuICAvLyBDbGFzc2UgcGFyZW50ZSBkZSB0b3VzIGxlcyBleGVyY2ljZXMgcXVpIHNlcm9udCBjcsOpw6lzXG4gIHRoaXMudGl0cmUgPSAnJ1xuICB0aGlzLmNvbnNpZ25lID0gJydcbiAgdGhpcy5jb25zaWduZUNvcnJlY3Rpb24gPSAnJ1xuICB0aGlzLmxpc3RlUXVlc3Rpb25zID0gW11cbiAgdGhpcy5saXN0ZUNvcnJlY3Rpb25zID0gW11cbiAgdGhpcy5pbnRyb2R1Y3Rpb24gPSAnJ1xuICB0aGlzLmNvbnRlbnUgPSAnJ1xuICB0aGlzLmNvbnRlbnVDb3JyZWN0aW9uID0gJydcbiAgdGhpcy5uYlF1ZXN0aW9ucyA9IDEwXG4gIHRoaXMubmJDb2xzID0gMlxuICB0aGlzLm5iQ29sc0NvcnIgPSAyXG4gIHRoaXMuc3BhY2luZyA9IDFcbiAgdGhpcy5zcGFjaW5nQ29yciA9IDFcbiAgdGhpcy5iZWFtZXIgPSBmYWxzZVxuXG4gIHRoaXMuYmVzb2luRm9ybXVsYWlyZU51bWVyaXF1ZSA9IGZhbHNlIC8vIFNpbm9uIHRoaXMuYmVzb2luRm9ybXVsYWlyZU51bWVyaXF1ZSA9IFt0ZXh0ZSxtYXgsdG9vbHRpcCBmYWN1bHRhdGlmXTtcbiAgdGhpcy5iZXNvaW5Gb3JtdWxhaXJlVGV4dGUgPSBmYWxzZSAvLyBTaW5vbiB0aGlzLmJlc29pbkZvcm11bGFpcmVUZXh0ZSA9IFt0ZXh0ZSx0b29sdGlwXTtcbiAgdGhpcy5iZXNvaW5Gb3JtdWxhaXJlQ2FzZUFDb2NoZXIgPSBmYWxzZSAvLyBTaW5vbiB0aGlzLmJlc29pbkZvcm11bGFpcmVDYXNlQUNvY2hlciA9IFt0ZXh0ZV07XG4gIHRoaXMuY29uc2lnbmVNb2RpZmlhYmxlID0gdHJ1ZVxuICB0aGlzLm5iUXVlc3Rpb25zTW9kaWZpYWJsZSA9IHRydWVcbiAgdGhpcy5uYkNvbHNNb2RpZmlhYmxlID0gdHJ1ZVxuICB0aGlzLm5iQ29sc0NvcnJNb2RpZmlhYmxlID0gdHJ1ZVxuICB0aGlzLnNwYWNpbmdNb2RpZmlhYmxlID0gdHJ1ZVxuICB0aGlzLnNwYWNpbmdDb3JyTW9kaWZpYWJsZSA9IHRydWVcbiAgdGhpcy5jb3JyZWN0aW9uRGV0YWlsbGVlRGlzcG9uaWJsZSA9IGZhbHNlXG4gIHRoaXMuY29ycmVjdGlvbkRldGFpbGxlZSA9IHRydWVcbiAgdGhpcy52aWRlbyA9ICcnXG4gIHRoaXMuYm91dG9uQWlkZSA9IGZhbHNlXG4gIHRoaXMudGFpbGxlRGlhcG9yYW1hID0gNTAgLy8gVGFpbGxlIGVuIHBpeGVscyBwb3VyIGxlIGNhbGN1bCBjaHJvbm9tw6l0csOpXG4gIC8vIHRoaXMuYm91dG9uQWlkZSA9IG1vZGFsVGV4dGVDb3VydChudW1lcm9FeGVyY2ljZSx0ZXh0ZSxsYWJlbF9ib3V0b249XCJBaWRlXCIsaWNvbmU9XCJpbmZvIGNpcmNsZVwiKVxuICAvLyB0aGlzLmJvdXRvbkFpZGUgPSBtb2RhbFRleHRlTG9uZyhudW1lcm9FeGVyY2ljZSx0aXRyZSx0ZXh0ZSxsYWJlbF9ib3V0b249XCJBaWRlXCIsaWNvbmU9XCJpbmZvIGNpcmNsZVwiKVxuICAvLyB0aGlzLmJvdXRvbkFpZGUgPSBtb2RhbFlvdXR1YmUobnVtZXJvRXhlcmNpY2UsaWRfeW91dHViZSx0ZXh0ZSxsYWJlbF9ib3V0b249XCJBaWRlIC0gVmlkw6lvXCIsaWNvbmU9XCJ5b3V0dWJlXCIpXG4gIC8vIHRoaXMuYm91dG9uQWlkZSA9IG1vZGFsUGRmKG51bWVyb0V4ZXJjaWNlLHVybF9wZGYsdGV4dGU9XCJBaWRlXCIsbGFiZWxfYm91dG9uPVwiQWlkZSAtIFBERlwiLGljb25lPVwiZmlsZSBwZGZcIilcbiAgLy8gdGhpcy52c3BhY2UgPSAtMSAvL0Fqb3V0ZSB1biBcXHZzcGFjZXstMWNtfSBhdmFudCBsJ8Opbm9uY8OpIGNlIHF1aSBwZXV0IMOqdHJlIHByYXRpcXVlIHBvdXIgZGVzIGV4ZXJjaWNlcyBhdmVjIGRlcyBmaWd1cmVzLlxuICB0aGlzLnBhc0RlVmVyc2lvbkxhdGV4ID0gZmFsc2VcbiAgdGhpcy5xY20gPSBmYWxzZSAvLyBQb3VyIGxlcyBleGVyY2ljZXMgZGUgdHlwZSBRQ00gOiBjb250aWVudCB1biB0YWJsZWF1LlxuICB0aGlzLnFjbURpc3BvbmlibGUgPSBmYWxzZSAvLyBQb3VyIGFqb3V0ZXIgdW5lIGNhc2Ugw6AgY29jaGVyIE1vZGUgUUNNIHF1aSBwZXJtZXQgZGUgY2hhbmdlciBsZSBzdGF0dXQgZGUgdGhpcy5tb2RlUWNtXG4gIHRoaXMubW9kZVFjbSA9IGZhbHNlIC8vIFBvdXIgY2hvaXNpciBsYSB2ZXJzaW9uIFFDTSBvdSBsYSB2ZXJzaW9uIGNsYXNzaXF1ZSAoZmFsc2UgPSB2ZXJzaW9uIGNsYXNzaXF1ZSlcblxuICB0aGlzLm1nMzJFZGl0YWJsZSA9IGZhbHNlIC8vIHBhcyBkJ2ludGVyZmFjZSBwYXIgZMOpZmF1dCBwb3VyIGxlcyBmaWd1cmVzIE1HMzJcbiAgdGhpcy5ub3V2ZWxsZVZlcnNpb24gPSBmdW5jdGlvbiAobnVtZXJvRXhlcmNpY2UpIHt9XG4gIHRoaXMubGlzdGVQYWNrYWdlcyA9IFtdIC8vIHN0cmluZyBvdSBsaXN0ZSBkZSBzdHJpbmcgYXZlYyBsZSBub20gZGVzIHBhY2thZ2VzIHNww6ljaWZpcXVlcyDDoCBham91dGVyIGRhbnMgbGUgcHLDqWFtYnVsZVxuICAvLyB0aGlzLnR5cGVFeGVyY2ljZSA9IFwiTUczMlwiO1xuICAvLyB0aGlzLmRpbWVuc2lvbnNEaXZNZzMyID0gWzUwMCwgNDUwXTtcbiAgLy8gdGhpcy50eXBlRXhlcmNpY2UgPSBcIlNjcmF0Y2hcIlxuICAvLyB0aGlzLnFjbT1bXCJRdWVscyBzb250IGxlcyBub21icmVzIHBhaXJzID9cIixbNywxMiwzNCwyNSwxOF0sWzAsMSwxLDAsMV1dID0+W1wiTGEgcXVlc3Rpb25cIixbbGVzIHLDqXBvbnNlc10sW2Jvbm5lPTEgZXQgbWF1dmFpc2U9MF1dXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/exercices/ClasseExercice.js\n");

/***/ }),

/***/ "./src/js/modules/3d.js":
/*!******************************!*\
  !*** ./src/js/modules/3d.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"point3d\": () => (/* binding */ point3d),\n/* harmony export */   \"vecteur3d\": () => (/* binding */ vecteur3d),\n/* harmony export */   \"arete3d\": () => (/* binding */ arete3d),\n/* harmony export */   \"droite3d\": () => (/* binding */ droite3d),\n/* harmony export */   \"demicercle3d\": () => (/* binding */ demicercle3d),\n/* harmony export */   \"cercle3d\": () => (/* binding */ cercle3d),\n/* harmony export */   \"polygone3d\": () => (/* binding */ polygone3d),\n/* harmony export */   \"sphere3d\": () => (/* binding */ sphere3d),\n/* harmony export */   \"cone3d\": () => (/* binding */ cone3d),\n/* harmony export */   \"cylindre3d\": () => (/* binding */ cylindre3d),\n/* harmony export */   \"prisme3d\": () => (/* binding */ prisme3d),\n/* harmony export */   \"cube3d\": () => (/* binding */ cube3d),\n/* harmony export */   \"cube\": () => (/* binding */ cube),\n/* harmony export */   \"pave3d\": () => (/* binding */ pave3d),\n/* harmony export */   \"rotationV3d\": () => (/* binding */ rotationV3d),\n/* harmony export */   \"rotation3d\": () => (/* binding */ rotation3d),\n/* harmony export */   \"sensDeRotation3d\": () => (/* binding */ sensDeRotation3d),\n/* harmony export */   \"translation3d\": () => (/* binding */ translation3d),\n/* harmony export */   \"homothetie3d\": () => (/* binding */ homothetie3d)\n/* harmony export */ });\n/* harmony import */ var _2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./2d.js */ \"./src/js/modules/2d.js\");\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mathjs */ \"./node_modules/.pnpm/mathjs@9.3.2/node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* global mathalea */\n\n\nconst math = {\n  matrix: mathjs__WEBPACK_IMPORTED_MODULE_1__.matrix,\n  multiply: mathjs__WEBPACK_IMPORTED_MODULE_1__.multiply,\n  norm: mathjs__WEBPACK_IMPORTED_MODULE_1__.norm,\n  cross: mathjs__WEBPACK_IMPORTED_MODULE_1__.cross,\n  dot: mathjs__WEBPACK_IMPORTED_MODULE_1__.dot\n};\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @Auteur Rémi Angot\n */\n\nlet numId = 0;\n\nfunction ObjetMathalea2D() {\n  this.positionLabel = 'above';\n  this.isVisible = true;\n  this.color = 'black';\n  this.style = ''; // stroke-dasharray=\"4 3\" pour des hachures //stroke-width=\"2\" pour un trait plus épais\n\n  this.styleTikz = '';\n  this.epaisseur = 1;\n  this.opacite = 1;\n  this.pointilles = false;\n  this.id = numId;\n  numId++; //   mesObjets.push(this);\n\n  mathalea.objets2D.push(this);\n}\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * LE POINT\n *\n* @Auteur Jean-Claude Lhote\n* Point de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n* le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n*/\n\n\nclass Point3d {\n  constructor(x3d, y3d, z3d, visible, label) {\n    const alpha = mathalea.anglePerspective * Math.PI / 180;\n    const rapport = mathalea.coeffPerspective;\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]]);\n    this.x3d = x3d;\n    this.y3d = y3d;\n    this.z3d = z3d;\n    this.visible = visible;\n    this.label = label;\n    const V = math.matrix([this.x3d, this.y3d, this.z3d]);\n    const W = math.multiply(MT, V);\n    this.p2d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(W._data[0], W._data[1], this.label);\n  }\n\n}\n\nfunction point3d(x3d, y3d, z3d = 0, visible = true, label = '') {\n  return new Point3d(x3d, y3d, z3d, visible, label);\n}\n/**\n   * LE VECTEUR\n   *\n   * @Auteur Jean-Claude Lhote\n   * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n   * On les utilise dans tous les objets complexeimport Additionner_soustraires_decimaux from '../exercices/6e/6C20';\ns et dans toutes les transformations.import Nature_polygone from './../exercices/2e/2G12';\nimport Exercice_fractions_decomposer from './../exercices/6e/6N20';\n\n   * Ils servent notament à définir la direction des plans.\n   *\n   * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n   * A et B sont deux objets de type Point3d\n   * x,y et z sont trois nombres\n   * la commande math.matrix([x,y,z]) crée une matrice colonne.\n   *\n   * L'objet créé est de type Vecteur3d\n   * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n   * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n   */\n\nclass Vecteur3d {\n  constructor(...args) {\n    const alpha = mathalea.anglePerspective * Math.PI / 180;\n    const rapport = mathalea.coeffPerspective;\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]]);\n\n    if (args.length == 2) {\n      this.x3d = args[1].x3d - args[0].x3d;\n      this.y3d = args[1].y3d - args[0].y3d;\n      this.z3d = args[1].z3d - args[0].z3d;\n    } else {\n      if (typeof args[0] === 'number') {\n        this.x3d = args[0];\n        this.y3d = args[1];\n        this.z3d = args[2];\n      } else if (args.length == 1) {\n        this.x3d = args[0]._data[0];\n        this.y3d = args[0]._data[1];\n        this.z3d = args[0]._data[2];\n      }\n    }\n\n    this.matrice = math.matrix([this.x3d, this.y3d, this.z3d]);\n    const W = math.multiply(MT, this.matrice);\n    this.p2d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(W._data[0], W._data[1]);\n\n    this.representant = function (A) {\n      const B = translation3d(A, this);\n      return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A.p2d, B.p2d).representant(A.p2d);\n    };\n  }\n\n}\n\nfunction vecteur3d(...args) {\n  // A,B deux Point3d ou x,y,z les composantes du vecteur\n  return new Vecteur3d(...args);\n}\n/**\n   * L'ARETE\n   * @Auteur Jean-Claude lhote\n   *\n   *\n   *\n   */\n\nclass Arete3d {\n  constructor(point1, point2, color) {\n    this.extremite1 = point1;\n    this.extremite2 = point2;\n    this.color = color;\n\n    if (!point1.visible || !point2.visible) {\n      this.visible = false;\n    } else {\n      this.visible = true;\n    }\n\n    this.p2d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(point1.p2d, point2.p2d, color);\n\n    if (!this.visible) {\n      this.p2d.pointilles = 2;\n    } else {\n      this.p2d.pointilles = false;\n    }\n  }\n\n}\n\nfunction arete3d(p1, p2, color = 'black') {\n  return new Arete3d(p1, p2, color);\n}\n/**\n   * LA DROITE\n   *\n   * @Auteur Jean-claude Lhote\n   * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n   * Droite de l'espace définie par 2 points droite3d(A,B)\n   * Les droites servent principalement à définir des axes de rotation dans l'espace\n   */\n\nclass Droite3d {\n  constructor(point3D, vecteur3D) {\n    if (vecteur3D.constructor == Vecteur3d) {\n      this.directeur = vecteur3D;\n    } else if (vecteur3D.constructor == Point3d) {\n      this.directeur = vecteur3d(point3D, vecteur3D);\n    }\n\n    this.origine = point3D;\n    const M = translation3d(this.origine, this.directeur);\n    this.point = M;\n    this.p2d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(this.origine.p2d, M.p2d); // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n\n    this.p2d.isVisible = false;\n  }\n\n}\n\nfunction droite3d(point3D, vecteur3D) {\n  return new Droite3d(point3D, vecteur3D);\n}\n/**\n * LE DEMI-CERCLE\n *\n *@Auteur Jean-Claude Lhote\n * Le nom est trompeur, il s'agit le plus souvent d'une demi-ellipse représentant un cercle projeté\n * Utilisé pour représenter un cercle dont une moitié est visible mais pas l'autre.\n *\n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible' et déterminera dans quel sens on crée le demi-cercle.\n * Si cote='caché' alors on tourne dans le sens direct et le tracé est en pointillés\n * Si cote='visible' alors on tourne dans le sens indirect et le tracé est plein.\n *\n */\n\nfunction demicercle3d(centre, normal, rayon, cote, color, angledepart = mathalea.anglePerspective) {\n  let demiCercle;\n  let signe;\n  const M = [];\n  const listepoints = [];\n\n  if (cote == 'caché') {\n    signe = 1;\n  } else {\n    signe = -1;\n  }\n\n  const d = droite3d(centre, normal);\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart));\n  listepoints.push(M[0].p2d);\n\n  for (let i = 1; i < 19; i++) {\n    M.push(rotation3d(M[i - 1], d, 10 * signe));\n    listepoints.push(M[i].p2d);\n  }\n\n  demiCercle = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polyline)(listepoints, color);\n\n  if (cote == 'caché') {\n    demiCercle.pointilles = 2;\n    demiCercle.opacite = 0.3;\n  }\n\n  return demiCercle;\n}\n/**\n    * LE CERCLE\n    *\n    * @Auteur Jean-Claude Lhote\n    *\n    * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n    * visible est un booléen\n    *\n    */\n\nfunction cercle3d(centre, normal, rayon, visible = true, color = 'black') {\n  let C;\n  const M = [];\n  const listepoints = [];\n  const d = droite3d(centre, normal);\n  M.push(rotation3d(translation3d(centre, rayon), d, mathalea.anglePerspective));\n  listepoints.push(M[0].p2d);\n\n  for (let i = 1; i < 37; i++) {\n    M.push(rotation3d(M[i - 1], d, 10));\n    listepoints.push(M[i].p2d);\n  }\n\n  C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)(listepoints, color);\n\n  if (!visible) {\n    C.pointilles = 2;\n  }\n\n  return C;\n}\n/**\n   * LE POLYGONE\n   *\n   * @Auteur Jean-Claude Lhote\n   * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n   */\n\nclass Polygone3d {\n  constructor(...args) {\n    if (Array.isArray(args[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = args[0];\n\n      if (args[1]) {\n        this.color = args[1];\n      }\n    } else {\n      this.listePoints = args;\n      this.color = 'black';\n    }\n\n    const segments3d = [];\n    let A;\n    const segments = [];\n    A = this.listePoints[0];\n\n    for (let i = 1; i < this.listePoints.length; i++) {\n      segments3d.push(arete3d(A, this.listePoints[i], this.color));\n      segments.push(segments3d[i - 1].p2d);\n      A = this.listePoints[i];\n    }\n\n    segments3d.push(arete3d(A, this.listePoints[0], this.color));\n    segments.push(segments3d[this.listePoints.length - 1].p2d);\n    this.aretes = segments3d;\n    this.p2d = segments;\n  }\n\n}\n\nfunction polygone3d(...args) {\n  return new Polygone3d(...args);\n}\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE COMPLEXES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA SPHERE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n   * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n   * @param {Point3d} centre\n   * @param {Number} rayon\n   * @param {Number} nb_paralleles\n   * @param {Number} nb_meridiens\n   * @param {string} color\n   */\n\nfunction Sphere3d(centre, rayon, nb_paralleles, nb_meridiens, color) {\n  ObjetMathalea2D.call(this);\n  this.centre = centre;\n  this.rayon = vecteur3d(rayon, 0, 0);\n  this.normal = vecteur3d(0, 0, 1);\n  this.color = color;\n  this.nb_meridiens = nb_meridiens;\n  this.nb_paralleles = nb_paralleles;\n  const objets = [];\n  let c1;\n  let c2;\n  let c3;\n  let c4;\n  let C;\n  let D;\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon.matrice));\n  let cote1, cote2, rayon2, R;\n  rayon2 = vecteur3d(math.cross(this.rayon.matrice, math.multiply(prodvec.matrice, 1 / math.norm(prodvec.matrice))));\n  R = rayon;\n  cote1 = 'caché';\n  cote2 = 'visible'; // objets.push(cercle3d(this.centre,rotationV3d(prodvec,this.normal,mathalea.anglePerspective),rotationV3d(this.rayon,this.normal,mathalea.anglePerspective),true,this.color))\n\n  for (let k = 0, rayon3; k < 1; k += 1 / (this.nb_paralleles + 1)) {\n    C = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(k * Math.PI / 2));\n    D = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(-k * Math.PI / 2));\n    rayon3 = vecteur3d(R * Math.cos(k * Math.PI / 2), 0, 0);\n    c1 = demicercle3d(C, this.normal, rayon3, cote1, this.color, mathalea.anglePerspective);\n    c2 = demicercle3d(C, this.normal, rayon3, cote2, this.color, mathalea.anglePerspective);\n    c3 = demicercle3d(D, this.normal, rayon3, cote1, this.color, mathalea.anglePerspective);\n    c4 = demicercle3d(D, this.normal, rayon3, cote2, this.color, mathalea.anglePerspective);\n    objets.push(c1, c2, c3, c4);\n  }\n\n  for (let k = 0, V, W; k < 1; k += 1 / this.nb_meridiens) {\n    V = rotationV3d(prodvec, this.normal, 90 + mathalea.anglePerspective + k * 90);\n    W = rotationV3d(prodvec, this.normal, 90 + mathalea.anglePerspective - (k + 1 / this.nb_meridiens) * 90);\n    c1 = demicercle3d(this.centre, V, rayon2, cote2, this.color, 0);\n    c2 = demicercle3d(this.centre, V, rayon2, cote1, this.color, 0);\n    c3 = demicercle3d(this.centre, W, rayon2, cote2, this.color, 0);\n    c4 = demicercle3d(this.centre, W, rayon2, cote1, this.color, 0);\n    objets.push(c1, c2, c3, c4);\n  }\n\n  this.svg = function (coeff) {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff);\n    }\n\n    return code;\n  };\n\n  this.tikz = function () {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz();\n    }\n\n    return code;\n  };\n}\n\nfunction sphere3d(centre, rayon, nb_paralleles, nb_meridiens, color = 'black') {\n  return new Sphere3d(centre, rayon, nb_paralleles, nb_meridiens, color);\n}\n/**\n    * LE CONE\n    *\n    * @Auteur Jean-Claude Lhote\n    *\n    * centrebase est le centre du disque de base\n    * sommet est le sommet du cône\n    * normal est un vecteur 3d normal au plan du disque (il détermine avec rayon de quel côté se trouve la partie visible)\n    *\n    */\n\nfunction Cone3d(centrebase, sommet, normal, rayon, generatrices = 18) {\n  ObjetMathalea2D.call(this);\n  this.sommet = sommet;\n  this.centrebase = centrebase;\n  this.normal = normal;\n  this.rayon = rayon;\n  const objets = [];\n  let c1;\n  let c2;\n  let s;\n  let color1;\n  let color2;\n  const prodvec = vecteur3d(math.cross(normal.matrice, rayon.matrice));\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice);\n  let cote1, cote2;\n\n  if (prodscal > 0) {\n    cote1 = 'caché';\n    color1 = 'gray';\n    cote2 = 'visible';\n    color2 = 'black';\n  } else {\n    cote2 = 'caché';\n    cote1 = 'visible';\n    color1 = 'black';\n    color2 = 'gray';\n  }\n\n  c1 = demicercle3d(this.centrebase, this.normal, this.rayon, cote1, color1);\n  c2 = demicercle3d(this.centrebase, this.normal, this.rayon, cote2, color2);\n\n  for (let i = 0; i < c1.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(this.sommet.p2d, c1.listePoints[i]);\n\n      if (cote1 == 'caché') {\n        s.pointilles = 2;\n        s.color = 'gray';\n      } else {\n        s.color = 'black';\n      }\n\n      objets.push(s);\n    }\n  }\n\n  for (let i = 0; i < c2.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(this.sommet.p2d, c2.listePoints[i]);\n\n      if (cote2 == 'caché') {\n        s.pointilles = 2;\n        s.color = 'gray';\n      } else {\n        s.color = 'black';\n      }\n\n      objets.push(s);\n    }\n  }\n\n  objets.push(c1, c2);\n\n  this.svg = function (coeff) {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff);\n    }\n\n    return code;\n  };\n\n  this.tikz = function () {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz();\n    }\n\n    return code;\n  };\n}\n\nfunction cone3d(centre, sommet, normal, rayon, generatrices = 18) {\n  return new Cone3d(centre, sommet, normal, rayon, generatrices);\n}\n/**\n   * LE CYLINDRE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Crée un cylindre de révolution définit par les centres de ses 2 bases\n   * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes\n   * @param {Point3d} centrebase1\n   * @param {Point3d} centrebase2\n   * @param {Vecteur3d} normal\n   * @param {Vecteur3d} rayon1\n   * @param {Vecteur3d} rayon2\n   */\n\nfunction Cylindre3d(centrebase1, centrebase2, normal, rayon1, rayon2, color) {\n  ObjetMathalea2D.call(this);\n  this.centrebase1 = centrebase1;\n  this.centrebase2 = centrebase2;\n  this.normal = normal;\n  this.rayon1 = rayon1;\n  this.rayon2 = rayon2;\n  this.color = color;\n  const objets = [];\n  let c1;\n  let c2;\n  let c3;\n  let c4;\n  let s;\n  let color1;\n  let color2;\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon1.matrice));\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice);\n  let cote1, cote2;\n\n  if (prodscal > 0) {\n    cote1 = 'caché';\n    color1 = this.color;\n    cote2 = 'visible';\n    color2 = this.color;\n  } else {\n    cote2 = 'caché';\n    cote1 = 'visible';\n    color1 = this.color;\n    color2 = this.color;\n  }\n\n  c1 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote1, color1);\n  c3 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote1, color1);\n  c2 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote2, color2);\n  c4 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote2, color2);\n  c3.pointilles = false;\n  c3.color = this.color;\n\n  for (let i = 0; i < c1.listePoints.length; i += 2) {\n    s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(c3.listePoints[i], c1.listePoints[i]);\n\n    if (cote1 == 'caché') {\n      s.pointilles = 2;\n      s.color = this.color;\n      s.opacite = 0.3;\n    } else {\n      s.color = this.color;\n    }\n\n    objets.push(s);\n  }\n\n  for (let i = 0; i < c2.listePoints.length; i += 2) {\n    s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(c4.listePoints[i], c2.listePoints[i]);\n\n    if (cote2 == 'caché') {\n      s.pointilles = 2;\n      s.color = this.color;\n      s.opacite = 0.3;\n    } else {\n      s.color = this.color;\n    }\n\n    objets.push(s);\n  }\n\n  objets.push(c1, c2, c3, c4);\n\n  this.svg = function (coeff) {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff);\n    }\n\n    return code;\n  };\n\n  this.tikz = function () {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz();\n    }\n\n    return code;\n  };\n}\n\nfunction cylindre3d(centrebase1, centrebase2, normal, rayon, rayon2, color = 'black') {\n  return new Cylindre3d(centrebase1, centrebase2, normal, rayon, rayon2, color);\n}\n/**\n   * LE PRISME\n   *\n   * @Auteur Jean-Claude Lhote\n   * Crée un prisme à partir du base Polygone3d et d'un vecteur3d d'extrusion (on peut faire des prismes droits ou non droits)\n   */\n\nclass Prisme3d {\n  constructor(base, vecteur, color) {\n    ObjetMathalea2D.call(this);\n    this.color = color;\n    base.color = color;\n    this.base1 = base;\n    this.base2 = translation3d(base, vecteur);\n    this.base2.color = this.base1.color;\n    this.aretes = [];\n    const objets = [];\n    let s;\n\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      objets.push(this.base1.p2d[i]);\n    }\n\n    for (let i = 0; i < this.base2.listePoints.length; i++) {\n      objets.push(this.base2.p2d[i]);\n    }\n\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      s = arete3d(this.base1.listePoints[i], this.base2.listePoints[i], this.color);\n      objets.push(s.p2d);\n    }\n\n    this.svg = function (coeff) {\n      let code = '';\n\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.svg(coeff);\n      }\n\n      return code;\n    };\n\n    this.tikz = function () {\n      let code = '';\n\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.tikz();\n      }\n\n      return code;\n    };\n  }\n\n}\n\nfunction prisme3d(base, vecteur, color = 'black') {\n  return new Prisme3d(base, vecteur, color);\n}\n/**\n   * LE cube\n   * @Auteur Jean-Claude Lhote\n   * usage : cube(x,y,z,c,color) construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z.\n   * le face avant est dans le plan xz\n   *\n*/\n\nclass Cube3d {\n  constructor(x, y, z, c, color = 'black') {\n    let faceAV, faceDr, faceTOP;\n    const A = point3d(x, y, z);\n    const vx = vecteur3d(c, 0, 0);\n    const vy = vecteur3d(0, c, 0);\n    const vz = vecteur3d(0, 0, c);\n    const B = translation3d(A, vx);\n    const C = translation3d(B, vz);\n    const D = translation3d(A, vz);\n    const E = translation3d(A, vy);\n    const F = translation3d(E, vx);\n    const G = translation3d(F, vz);\n    const H = translation3d(D, vy);\n    faceAV = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([A.p2d, B.p2d, C.p2d, D.p2d], color);\n    faceDr = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([B.p2d, F.p2d, G.p2d, C.p2d], color);\n    faceTOP = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([D.p2d, C.p2d, G.p2d, H.p2d], color);\n    faceAV.couleurDeRemplissage = '#A9A9A9';\n    faceTOP.couleurDeRemplissage = 'white';\n    faceDr.couleurDeRemplissage = '#A5C400';\n\n    this.svg = function (coeff) {\n      return faceAV.svg(coeff) + '\\n' + faceTOP.svg(coeff) + '\\n' + faceDr.svg(coeff);\n    };\n\n    this.tikz = function () {\n      return faceAV.tikz() + '\\n' + faceTOP.tikz() + '\\n' + faceDr.tikz();\n    };\n  }\n\n}\n\nfunction cube3d(x, y, z, c) {\n  return new Cube3d(x, y, z, c);\n}\n\nclass Cube {\n  constructor(x, y, z, alpha, beta, colorD, colorT, colorG) {\n    ObjetMathalea2D.call(this);\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.alpha = alpha;\n    this.beta = beta;\n    this.colorD = colorD;\n    this.colorG = colorG;\n    this.colorT = colorT;\n    this.lstPoints = [];\n    this.lstPolygone = [];\n\n    function proj(x, y, z, alpha, beta) {\n      const cosa = Math.cos(alpha * Math.PI / 180);\n      const sina = Math.sin(alpha * Math.PI / 180);\n      const cosb = Math.cos(beta * Math.PI / 180);\n      const sinb = Math.sin(beta * Math.PI / 180);\n      return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(cosa * x - sina * y, -sina * sinb * x - cosa * sinb * y + cosb * z);\n    }\n\n    this.lstPoints.push(proj(this.x, this.y, this.z, this.alpha, this.beta)); // point 0 en bas\n\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z, this.alpha, this.beta)); // point 1\n\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z + 1, this.alpha, this.beta)); // point 2\n\n    this.lstPoints.push(proj(this.x, this.y, this.z + 1, this.alpha, this.beta)); // point 3\n\n    this.lstPoints.push(proj(this.x + 1, this.y + 1, this.z + 1, this.alpha, this.beta)); // point 4\n\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z + 1, this.alpha, this.beta)); // point 5\n\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z, this.alpha, this.beta)); // point 6\n\n    let p;\n    p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[0], this.lstPoints[1], this.lstPoints[2], this.lstPoints[3]], 'black');\n    p.opaciteDeRemplissage = 1;\n    p.couleurDeRemplissage = this.colorD;\n    this.lstPolygone.push(p);\n    p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[2], this.lstPoints[4], this.lstPoints[5], this.lstPoints[3]], 'black');\n    p.couleurDeRemplissage = this.colorG;\n    p.opaciteDeRemplissage = 1;\n    this.lstPolygone.push(p);\n    p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[3], this.lstPoints[5], this.lstPoints[6], this.lstPoints[0]], 'black');\n    p.couleurDeRemplissage = this.colorT;\n    p.opaciteDeRemplissage = 1;\n    this.lstPolygone.push(p);\n\n    this.svg = function (coeff) {\n      let code = '';\n\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svg(coeff);\n      }\n\n      code = `<g id=\"${this.id}\">${code}</g>`;\n      return code;\n    };\n\n    this.tikz = function () {\n      let code = '';\n\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikz();\n      }\n\n      return code;\n    };\n\n    this.svgml = function (coeff, amp) {\n      let code = '';\n\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svgml(coeff, amp);\n      }\n\n      return code;\n    };\n\n    this.tikzml = function (amp) {\n      let code = '';\n\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikzml(amp);\n      }\n\n      return code;\n    };\n  }\n\n}\n\nfunction cube(x = 0, y = 0, z = 0, alpha = 45, beta = -35, {\n  colorD = 'green',\n  colorT = 'white',\n  colorG = 'gray'\n} = {}) {\n  return new Cube(x, y, z, alpha, beta, colorD, colorG, colorT);\n}\n/**\n   * LE PAVE\n   * @Auteur Jean-Claude Lhote\n   * usage : pave(A,B,D,E) construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] sont délimitent 3 faces adjacentes.\n   *\n*/\n\nclass Pave3d {\n  constructor(A, B, D, E, color) {\n    ObjetMathalea2D.call(this);\n    const v1 = vecteur3d(A, B);\n    const v2 = vecteur3d(A, E);\n    const v3 = vecteur3d(A, D);\n    const C = translation3d(D, v1);\n    const H = translation3d(D, v2);\n    const G = translation3d(C, v2);\n    const F = translation3d(B, v2);\n    E.visible = false;\n    this.color = color;\n    this.base = polygone3d([A, B, F, E]);\n    this.hauteur = v3;\n    this.aretes = [arete3d(A, B, color), arete3d(A, D, color), arete3d(A, E, color), arete3d(C, B, color), arete3d(F, B, color), arete3d(C, D, color), arete3d(C, G, color), arete3d(F, G, color), arete3d(F, E, color), arete3d(H, G, color), arete3d(H, E, color), arete3d(H, D, color)];\n\n    this.svg = function (coeff) {\n      let code = '';\n\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.svg(coeff);\n      }\n\n      return code;\n    };\n\n    this.tikz = function () {\n      let code = '';\n\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.tikz();\n      }\n\n      return code;\n    };\n  }\n\n}\n\nfunction pave3d(A, B, C, E, color = 'black') {\n  return new Pave3d(A, B, C, E, color);\n}\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA ROTATION VECTORIELLE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n   * Elle sert à faire tourner des vecteurs essentiellement.\n   * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n   *\n   * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n   * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n   * @param {*} angle Angle de rotation\n   */\n\nfunction rotationV3d(point3D, vecteur3D, angle) {\n  // point = ce qu'on fait tourner (Point3d) ; vecteur = directeur de l'axe de rotation [x,y,z] et angle de rotation en degrés\n  let matrice, V, p2;\n  const norme = math.norm(vecteur3D.matrice);\n  const unitaire = math.multiply(vecteur3D.matrice, 1 / norme);\n  const u = unitaire._data[0];\n  const v = unitaire._data[1];\n  const w = unitaire._data[2];\n  const c = Math.cos(angle * Math.PI / 180);\n  const s = Math.sin(angle * Math.PI / 180);\n  const k = 1 - c;\n  matrice = math.matrix([[u * u * k + c, u * v * k - w * s, u * w * k + v * s], [u * v * k + w * s, v * v * k + c, v * w * k - u * s], [u * w * k - v * s, v * w * k + u * s, w * w * k + c]]);\n\n  if (point3D.constructor == Point3d) {\n    V = math.matrix([point3D.x3d, point3D.y3d, point3D.z3d]);\n    p2 = math.multiply(matrice, V);\n    return point3d(p2._data[0], p2._data[1], p2._data[2]);\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D;\n    p2 = math.multiply(matrice, V.matrice);\n    return vecteur3d(p2._data[0], p2._data[1], p2._data[2]);\n  }\n}\n/**\n   * LA ROTATION D'AXE UNE DROITE\n   *\n   * @Auteur Jean-Claude Lhote\n   *\n   * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n   * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n   * @param {Droite3d} droite3D Axe de rotation\n   * @param {Number} angle Angle de rotation\n   * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n   */\n\nfunction rotation3d(point3D, droite3D, angle, color) {\n  const directeur = droite3D.directeur;\n  const origine = droite3D.origine;\n  const p = [];\n\n  if (point3D.constructor == Point3d) {\n    const V = vecteur3d(origine, point3d(0, 0, 0));\n    const W = vecteur3d(point3d(0, 0, 0), origine);\n    const M = translation3d(point3D, V);\n    const N = rotationV3d(M, directeur, angle);\n    return translation3d(N, W);\n  } else if (point3D.constructor == Vecteur3d) {\n    return rotationV3d(point3D, directeur, angle);\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(rotation3d(point3D.listePoints[i], droite3D, angle));\n    }\n\n    if (typeof color !== 'undefined') {\n      return polygone3d(p, color);\n    } else {\n      return polygone3d(p, point3D.color);\n    }\n  }\n}\n\nfunction SensDeRotation3d(axe, rayon, angle, epaisseur, color) {\n  ObjetMathalea2D.call(this);\n  this.epaisseur = epaisseur;\n  this.color = color;\n  let M;\n  let N;\n  let s;\n  const objets = [];\n  let d;\n  let A;\n  let B;\n  M = translation3d(axe.origine, rayon);\n\n  for (let i = 0; i < angle; i += 5) {\n    N = rotation3d(M, axe, 5);\n    s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(M.p2d, N.p2d);\n    s.color = this.color;\n    s.epaisseur = this.epaisseur;\n    objets.push(s);\n    M = N;\n  }\n\n  N = rotation3d(M, axe, 5);\n  s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(M.p2d, N.p2d);\n  s.color = this.color;\n  s.epaisseur = this.epaisseur;\n  objets.push(s);\n  d = droite3d(N, axe.directeur);\n  A = rotation3d(M, d, 30);\n  B = rotation3d(M, d, -30);\n  s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(N.p2d, A.p2d);\n  s.color = this.color;\n  s.epaisseur = this.epaisseur;\n  objets.push(s);\n  s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(N.p2d, B.p2d);\n  s.color = this.color;\n  s.epaisseur = this.epaisseur;\n  objets.push(s);\n\n  this.svg = function (coeff) {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff);\n    }\n\n    return code;\n  };\n\n  this.tikz = function () {\n    let code = '';\n\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz();\n    }\n\n    return code;\n  };\n}\n\nfunction sensDeRotation3d(axe, rayon, angle, epaisseur, color) {\n  return new SensDeRotation3d(axe, rayon, angle, epaisseur, color);\n}\n/**\n   * LA TRANSLATION\n   *\n   * @Auteur Jean-Claude Lhote\n   * @param {Point3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n   * @param {Vecteur3d} vecteur3D\n   */\n\nfunction translation3d(point3D, vecteur3D) {\n  if (point3D.constructor == Point3d) {\n    const x = point3D.x3d + vecteur3D.x3d;\n    const y = point3D.y3d + vecteur3D.y3d;\n    const z = point3D.z3d + vecteur3D.z3d;\n    return point3d(x, y, z);\n  } else if (point3D.constructor == Polygone3d) {\n    const p = [];\n\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(translation3d(point3D.listePoints[i], vecteur3D));\n    }\n\n    return polygone3d(p, point3D.color);\n  }\n}\nfunction homothetie3d(point3D, centre, rapport, color) {\n  let V;\n  const p = [];\n\n  if (point3D.constructor == Point3d) {\n    V = vecteur3d(centre, point3D);\n    V.x3d *= rapport;\n    V.y3d *= rapport;\n    V.y3d *= rapport;\n    return translation3d(centre, V);\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D;\n    V.x3d *= rapport;\n    V.y3d *= rapport;\n    V.y3d *= rapport;\n    return V;\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(homothetie3d(point3D.listePoints[i], centre, rapport, color));\n    }\n\n    if (typeof color !== 'undefined') {\n      return polygone3d(p, color);\n    } else {\n      return polygone3d(p, point3D.color);\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbW9kdWxlcy8zZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGhhbGVhLy4vc3JjL2pzL21vZHVsZXMvM2QuanM/ZTM5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgbWF0aGFsZWEgKi9cbmltcG9ydCB7IHBvaW50LCB2ZWN0ZXVyLCBkcm9pdGUsIHNlZ21lbnQsIHBvbHlsaW5lLCBwb2x5Z29uZSB9IGZyb20gJy4vMmQuanMnXG5pbXBvcnQgeyBtYXRyaXgsIG11bHRpcGx5LCBub3JtLCBjcm9zcywgZG90IH0gZnJvbSAnbWF0aGpzJ1xuY29uc3QgbWF0aCA9IHsgbWF0cml4OiBtYXRyaXgsIG11bHRpcGx5OiBtdWx0aXBseSwgbm9ybTogbm9ybSwgY3Jvc3M6IGNyb3NzLCBkb3Q6IGRvdCB9XG5cbi8qXG4lJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJVxuJSUlJSUlJSUlJSUlJSUgT0JKRVQgUEFSRU5UICUlJSUlJSUlJSUlJSVcbiUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlXG4qL1xuXG4vKlxuICogQ2xhc3NlIHBhcmVudGUgZGUgdG91cyBsZXMgb2JqZXRzIGRlIE1hdGhBTEVBMkRcbiAqXG4gKiBAQXV0ZXVyIFLDqW1pIEFuZ290XG4gKi9cbmxldCBudW1JZCA9IDBcbmZ1bmN0aW9uIE9iamV0TWF0aGFsZWEyRCAoKSB7XG4gIHRoaXMucG9zaXRpb25MYWJlbCA9ICdhYm92ZSdcbiAgdGhpcy5pc1Zpc2libGUgPSB0cnVlXG4gIHRoaXMuY29sb3IgPSAnYmxhY2snXG4gIHRoaXMuc3R5bGUgPSAnJyAvLyBzdHJva2UtZGFzaGFycmF5PVwiNCAzXCIgcG91ciBkZXMgaGFjaHVyZXMgLy9zdHJva2Utd2lkdGg9XCIyXCIgcG91ciB1biB0cmFpdCBwbHVzIMOpcGFpc1xuICB0aGlzLnN0eWxlVGlreiA9ICcnXG4gIHRoaXMuZXBhaXNzZXVyID0gMVxuICB0aGlzLm9wYWNpdGUgPSAxXG4gIHRoaXMucG9pbnRpbGxlcyA9IGZhbHNlXG4gIHRoaXMuaWQgPSBudW1JZFxuICBudW1JZCsrXG4gIC8vICAgbWVzT2JqZXRzLnB1c2godGhpcyk7XG4gIG1hdGhhbGVhLm9iamV0czJELnB1c2godGhpcylcbn1cblxuLypcbiUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlXG4lJSUlJSUlJSUlJSUlJSBPQkpFVFMgREUgQkFTRSAlJSUlJSUlJSUlJVxuJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSVcbiovXG5cbi8qKlxuICogTEUgUE9JTlRcbiAqXG4qIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiogUG9pbnQgZGUgbCdlc3BhY2UgZMOpZmluaSBwYXIgc2VzIHRyb2lzIGNvb3Jkb25uw6llcyAoU2kgZGV1eCBzb250IGRvbm7DqWVzIHNldWxlbWVudCwgbGUgcG9pbnQgZXN0IGRhbnMgbGUgcGxhbiBYWSlcbiogbGUgcGFyYW3DqHRyZSB2aXNpYmxlIGTDqWZpbml0IHNpIGNlIHBvaW50IGVzdCBwbGFjw6kgZGV2YW50IChwYXIgZMOpZmF1dCkgb3UgZGVycmnDqHJlIHVuZSBzdXJmYWNlLiBJbCBzZXJhIHV0aWxpc8OpIHBvdXIgZMOpZmluaXIgbGEgdmlzaWJpbGl0w6kgZGVzIGFyw6p0ZXMgcXVpIGVuIHBhcnRlbnRcbiovXG5jbGFzcyBQb2ludDNkIHtcbiAgY29uc3RydWN0b3IgKHgzZCwgeTNkLCB6M2QsIHZpc2libGUsIGxhYmVsKSB7XG4gICAgY29uc3QgYWxwaGEgPSBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlICogTWF0aC5QSSAvIDE4MFxuICAgIGNvbnN0IHJhcHBvcnQgPSBtYXRoYWxlYS5jb2VmZlBlcnNwZWN0aXZlXG4gICAgY29uc3QgTVQgPSBtYXRoLm1hdHJpeChbWzEsIHJhcHBvcnQgKiBNYXRoLmNvcyhhbHBoYSksIDBdLCBbMCwgcmFwcG9ydCAqIE1hdGguc2luKGFscGhhKSwgMV1dKVxuICAgIHRoaXMueDNkID0geDNkXG4gICAgdGhpcy55M2QgPSB5M2RcbiAgICB0aGlzLnozZCA9IHozZFxuICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGVcbiAgICB0aGlzLmxhYmVsID0gbGFiZWxcbiAgICBjb25zdCBWID0gbWF0aC5tYXRyaXgoW3RoaXMueDNkLCB0aGlzLnkzZCwgdGhpcy56M2RdKVxuICAgIGNvbnN0IFcgPSBtYXRoLm11bHRpcGx5KE1ULCBWKVxuICAgIHRoaXMucDJkID0gcG9pbnQoVy5fZGF0YVswXSwgVy5fZGF0YVsxXSwgdGhpcy5sYWJlbClcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50M2QgKHgzZCwgeTNkLCB6M2QgPSAwLCB2aXNpYmxlID0gdHJ1ZSwgbGFiZWwgPSAnJykge1xuICByZXR1cm4gbmV3IFBvaW50M2QoeDNkLCB5M2QsIHozZCwgdmlzaWJsZSwgbGFiZWwpXG59XG5cbi8qKlxuICAgKiBMRSBWRUNURVVSXG4gICAqXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICogbGUgdmVjdGV1cjNkIGVzdCBzYW5zIGRvdXRlIGwnb2JqZXQgbGUgcGx1cyBpbXBvcnRhbnQgZGUgY2V0dGUgYmFzZSBkJ29iamV0c1xuICAgKiBPbiBsZXMgdXRpbGlzZSBkYW5zIHRvdXMgbGVzIG9iamV0cyBjb21wbGV4ZWltcG9ydCBBZGRpdGlvbm5lcl9zb3VzdHJhaXJlc19kZWNpbWF1eCBmcm9tICcuLi9leGVyY2ljZXMvNmUvNkMyMCc7XG5zIGV0IGRhbnMgdG91dGVzIGxlcyB0cmFuc2Zvcm1hdGlvbnMuaW1wb3J0IE5hdHVyZV9wb2x5Z29uZSBmcm9tICcuLy4uL2V4ZXJjaWNlcy8yZS8yRzEyJztcbmltcG9ydCBFeGVyY2ljZV9mcmFjdGlvbnNfZGVjb21wb3NlciBmcm9tICcuLy4uL2V4ZXJjaWNlcy82ZS82TjIwJztcblxuICAgKiBJbHMgc2VydmVudCBub3RhbWVudCDDoCBkw6lmaW5pciBsYSBkaXJlY3Rpb24gZGVzIHBsYW5zLlxuICAgKlxuICAgKiAzIHVzYWdlcyA6IHZlY3RldXIzZChBLEIpIG91IHZlY3RldXIzZCh4LHkseikgb3UgdmVjdGV1cjNkKG1hdGgubWF0cml4KFt4LHksel0pKVxuICAgKiBBIGV0IEIgc29udCBkZXV4IG9iamV0cyBkZSB0eXBlIFBvaW50M2RcbiAgICogeCx5IGV0IHogc29udCB0cm9pcyBub21icmVzXG4gICAqIGxhIGNvbW1hbmRlIG1hdGgubWF0cml4KFt4LHksel0pIGNyw6llIHVuZSBtYXRyaWNlIGNvbG9ubmUuXG4gICAqXG4gICAqIEwnb2JqZXQgY3LDqcOpIGVzdCBkZSB0eXBlIFZlY3RldXIzZFxuICAgKiBzYSBwcm9wcmnDqXTDqSBwMmQgZXN0IHVuIG9iamV0IFZlY3RldXIgKDIgZGltZW5zaW9ucyA6IGMnZXN0IGxhIHByb2plY3Rpb24gZHUgdmVjdGV1cilcbiAgICogc2EgcHJvcHJpw6l0w6kgdGhpcy5yZXByZXNlbnRhbnQoQSkgZXN0IGxlIGRlc3NpbiBkdSByZXByw6lzZW50YW50IGQnb3JpZ2luZSBBLlxuICAgKi9cbmNsYXNzIFZlY3RldXIzZCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgY29uc3QgYWxwaGEgPSBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlICogTWF0aC5QSSAvIDE4MFxuICAgIGNvbnN0IHJhcHBvcnQgPSBtYXRoYWxlYS5jb2VmZlBlcnNwZWN0aXZlXG4gICAgY29uc3QgTVQgPSBtYXRoLm1hdHJpeChbWzEsIHJhcHBvcnQgKiBNYXRoLmNvcyhhbHBoYSksIDBdLCBbMCwgcmFwcG9ydCAqIE1hdGguc2luKGFscGhhKSwgMV1dKVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICB0aGlzLngzZCA9IGFyZ3NbMV0ueDNkIC0gYXJnc1swXS54M2RcbiAgICAgIHRoaXMueTNkID0gYXJnc1sxXS55M2QgLSBhcmdzWzBdLnkzZFxuICAgICAgdGhpcy56M2QgPSBhcmdzWzFdLnozZCAtIGFyZ3NbMF0uejNkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKGFyZ3NbMF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLngzZCA9IGFyZ3NbMF1cbiAgICAgICAgdGhpcy55M2QgPSBhcmdzWzFdXG4gICAgICAgIHRoaXMuejNkID0gYXJnc1syXVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRoaXMueDNkID0gYXJnc1swXS5fZGF0YVswXVxuICAgICAgICB0aGlzLnkzZCA9IGFyZ3NbMF0uX2RhdGFbMV1cbiAgICAgICAgdGhpcy56M2QgPSBhcmdzWzBdLl9kYXRhWzJdXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0cmljZSA9IG1hdGgubWF0cml4KFt0aGlzLngzZCwgdGhpcy55M2QsIHRoaXMuejNkXSlcbiAgICBjb25zdCBXID0gbWF0aC5tdWx0aXBseShNVCwgdGhpcy5tYXRyaWNlKVxuICAgIHRoaXMucDJkID0gdmVjdGV1cihXLl9kYXRhWzBdLCBXLl9kYXRhWzFdKVxuICAgIHRoaXMucmVwcmVzZW50YW50ID0gZnVuY3Rpb24gKEEpIHtcbiAgICAgIGNvbnN0IEIgPSB0cmFuc2xhdGlvbjNkKEEsIHRoaXMpXG4gICAgICByZXR1cm4gdmVjdGV1cihBLnAyZCwgQi5wMmQpLnJlcHJlc2VudGFudChBLnAyZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlY3RldXIzZCAoLi4uYXJncykgeyAvLyBBLEIgZGV1eCBQb2ludDNkIG91IHgseSx6IGxlcyBjb21wb3NhbnRlcyBkdSB2ZWN0ZXVyXG4gIHJldHVybiBuZXcgVmVjdGV1cjNkKC4uLmFyZ3MpXG59XG5cbi8qKlxuICAgKiBMJ0FSRVRFXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgbGhvdGVcbiAgICpcbiAgICpcbiAgICpcbiAgICovXG5jbGFzcyBBcmV0ZTNkIHtcbiAgY29uc3RydWN0b3IgKHBvaW50MSwgcG9pbnQyLCBjb2xvcikge1xuICAgIHRoaXMuZXh0cmVtaXRlMSA9IHBvaW50MVxuICAgIHRoaXMuZXh0cmVtaXRlMiA9IHBvaW50MlxuICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgIGlmICghcG9pbnQxLnZpc2libGUgfHwgIXBvaW50Mi52aXNpYmxlKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpc2libGUgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMucDJkID0gc2VnbWVudChwb2ludDEucDJkLCBwb2ludDIucDJkLCBjb2xvcilcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgdGhpcy5wMmQucG9pbnRpbGxlcyA9IDJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wMmQucG9pbnRpbGxlcyA9IGZhbHNlXG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXJldGUzZCAocDEsIHAyLCBjb2xvciA9ICdibGFjaycpIHtcbiAgcmV0dXJuIG5ldyBBcmV0ZTNkKHAxLCBwMiwgY29sb3IpXG59XG5cbi8qKlxuICAgKiBMQSBEUk9JVEVcbiAgICpcbiAgICogQEF1dGV1ciBKZWFuLWNsYXVkZSBMaG90ZVxuICAgKiBEcm9pdGUgZGUgbCdlc3BhY2UgZMOpZmluaWUgcGFyIHBvaW50IGV0IHZlY3RldXIgZGlyZWN0ZXVyIGRyb2l0ZTNkKEEsdilcbiAgICogRHJvaXRlIGRlIGwnZXNwYWNlIGTDqWZpbmllIHBhciAyIHBvaW50cyBkcm9pdGUzZChBLEIpXG4gICAqIExlcyBkcm9pdGVzIHNlcnZlbnQgcHJpbmNpcGFsZW1lbnQgw6AgZMOpZmluaXIgZGVzIGF4ZXMgZGUgcm90YXRpb24gZGFucyBsJ2VzcGFjZVxuICAgKi9cbmNsYXNzIERyb2l0ZTNkIHtcbiAgY29uc3RydWN0b3IgKHBvaW50M0QsIHZlY3RldXIzRCkge1xuICAgIGlmICh2ZWN0ZXVyM0QuY29uc3RydWN0b3IgPT0gVmVjdGV1cjNkKSB7XG4gICAgICB0aGlzLmRpcmVjdGV1ciA9IHZlY3RldXIzRFxuICAgIH0gZWxzZSBpZiAodmVjdGV1cjNELmNvbnN0cnVjdG9yID09IFBvaW50M2QpIHtcbiAgICAgIHRoaXMuZGlyZWN0ZXVyID0gdmVjdGV1cjNkKHBvaW50M0QsIHZlY3RldXIzRClcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5lID0gcG9pbnQzRFxuICAgIGNvbnN0IE0gPSB0cmFuc2xhdGlvbjNkKHRoaXMub3JpZ2luZSwgdGhpcy5kaXJlY3RldXIpXG4gICAgdGhpcy5wb2ludCA9IE1cbiAgICB0aGlzLnAyZCA9IGRyb2l0ZSh0aGlzLm9yaWdpbmUucDJkLCBNLnAyZCkgLy8gbGEgZHJvaXRlIGNvcnJlc3BuZGFudCDDoCBsYSBwcm9qZWN0aW9uIGRlIGNldHRlIGRyb2l0ZSBkYW5zIGxlIHBsYW4gTWF0aGFsZWEyZFxuICAgIHRoaXMucDJkLmlzVmlzaWJsZSA9IGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyb2l0ZTNkIChwb2ludDNELCB2ZWN0ZXVyM0QpIHtcbiAgcmV0dXJuIG5ldyBEcm9pdGUzZChwb2ludDNELCB2ZWN0ZXVyM0QpXG59XG5cbi8qKlxuICogTEUgREVNSS1DRVJDTEVcbiAqXG4gKkBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAqIExlIG5vbSBlc3QgdHJvbXBldXIsIGlsIHMnYWdpdCBsZSBwbHVzIHNvdXZlbnQgZCd1bmUgZGVtaS1lbGxpcHNlIHJlcHLDqXNlbnRhbnQgdW4gY2VyY2xlIHByb2pldMOpXG4gKiBVdGlsaXPDqSBwb3VyIHJlcHLDqXNlbnRlciB1biBjZXJjbGUgZG9udCB1bmUgbW9pdGnDqSBlc3QgdmlzaWJsZSBtYWlzIHBhcyBsJ2F1dHJlLlxuICpcbiAqIG5vcm1hbCBldCByYXlvbiBzb250IGRldXggdmVjdGV1cnMgM2RcbiAqIG5vcm1hbCBlc3QgdW4gdmVjdGV1ciBub3JtYWwgYXUgcGxhbiBkdSBjZXJjbGVcbiAqIHJheW9uIGVzdCBsZSB2ZWN0ZXVyIHF1aSBwYXJ0IGR1IGNlbnRyZSBldCBxdWkgam9pbnQgbGEgMWVyZSBleHRyZW1pdMOpIHZpc2libGUuXG4gKiBjb3RlIGVzdCBzb2l0ICdjYWNow6knIHNvaXQgJ3Zpc2libGUnIGV0IGTDqXRlcm1pbmVyYSBkYW5zIHF1ZWwgc2VucyBvbiBjcsOpZSBsZSBkZW1pLWNlcmNsZS5cbiAqIFNpIGNvdGU9J2NhY2jDqScgYWxvcnMgb24gdG91cm5lIGRhbnMgbGUgc2VucyBkaXJlY3QgZXQgbGUgdHJhY8OpIGVzdCBlbiBwb2ludGlsbMOpc1xuICogU2kgY290ZT0ndmlzaWJsZScgYWxvcnMgb24gdG91cm5lIGRhbnMgbGUgc2VucyBpbmRpcmVjdCBldCBsZSB0cmFjw6kgZXN0IHBsZWluLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbWljZXJjbGUzZCAoY2VudHJlLCBub3JtYWwsIHJheW9uLCBjb3RlLCBjb2xvciwgYW5nbGVkZXBhcnQgPSBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKSB7XG4gIGxldCBkZW1pQ2VyY2xlOyBsZXQgc2lnbmU7IGNvbnN0IE0gPSBbXTsgY29uc3QgbGlzdGVwb2ludHMgPSBbXVxuICBpZiAoY290ZSA9PSAnY2FjaMOpJykge1xuICAgIHNpZ25lID0gMVxuICB9IGVsc2Uge1xuICAgIHNpZ25lID0gLTFcbiAgfVxuICBjb25zdCBkID0gZHJvaXRlM2QoY2VudHJlLCBub3JtYWwpXG4gIE0ucHVzaChyb3RhdGlvbjNkKHRyYW5zbGF0aW9uM2QoY2VudHJlLCByYXlvbiksIGQsIGFuZ2xlZGVwYXJ0KSlcbiAgbGlzdGVwb2ludHMucHVzaChNWzBdLnAyZClcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IDE5OyBpKyspIHtcbiAgICBNLnB1c2gocm90YXRpb24zZChNW2kgLSAxXSwgZCwgMTAgKiBzaWduZSkpXG4gICAgbGlzdGVwb2ludHMucHVzaChNW2ldLnAyZClcbiAgfVxuICBkZW1pQ2VyY2xlID0gcG9seWxpbmUobGlzdGVwb2ludHMsIGNvbG9yKVxuICBpZiAoY290ZSA9PSAnY2FjaMOpJykge1xuICAgIGRlbWlDZXJjbGUucG9pbnRpbGxlcyA9IDJcbiAgICBkZW1pQ2VyY2xlLm9wYWNpdGUgPSAwLjNcbiAgfVxuICByZXR1cm4gZGVtaUNlcmNsZVxufVxuXG4vKipcbiAgICAqIExFIENFUkNMRVxuICAgICpcbiAgICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICAqXG4gICAgKiBDJ2VzdCBsYSB2ZXJzaW9uIGVudGnDqHJlIGR1IGNlcmNsZSA6IHNvaXQgdG90YWxlbWVudCB2aXNpYmxlLCBzb2l0IHRvdGFsZW1lbnQgY2FjaMOpLlxuICAgICogdmlzaWJsZSBlc3QgdW4gYm9vbMOpZW5cbiAgICAqXG4gICAgKi9cbmV4cG9ydCBmdW5jdGlvbiBjZXJjbGUzZCAoY2VudHJlLCBub3JtYWwsIHJheW9uLCB2aXNpYmxlID0gdHJ1ZSwgY29sb3IgPSAnYmxhY2snKSB7XG4gIGxldCBDOyBjb25zdCBNID0gW107IGNvbnN0IGxpc3RlcG9pbnRzID0gW11cbiAgY29uc3QgZCA9IGRyb2l0ZTNkKGNlbnRyZSwgbm9ybWFsKVxuICBNLnB1c2gocm90YXRpb24zZCh0cmFuc2xhdGlvbjNkKGNlbnRyZSwgcmF5b24pLCBkLCBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKSlcbiAgbGlzdGVwb2ludHMucHVzaChNWzBdLnAyZClcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCAzNzsgaSsrKSB7XG4gICAgTS5wdXNoKHJvdGF0aW9uM2QoTVtpIC0gMV0sIGQsIDEwKSlcbiAgICBsaXN0ZXBvaW50cy5wdXNoKE1baV0ucDJkKVxuICB9XG4gIEMgPSBwb2x5Z29uZShsaXN0ZXBvaW50cywgY29sb3IpXG4gIGlmICghdmlzaWJsZSkge1xuICAgIEMucG9pbnRpbGxlcyA9IDJcbiAgfVxuICByZXR1cm4gQ1xufVxuXG4vKipcbiAgICogTEUgUE9MWUdPTkVcbiAgICpcbiAgICogQEF1dGV1ciBKZWFuLUNsYXVkZSBMaG90ZVxuICAgKiB1c2FnZXMgOiBwb2x5Z29uZTNkKFtBLEIsQywuLi5dLGNvbG9yKSBvdSBwb2x5Z29uZTNkKEEsQixDLi4uKSBvw7kgQSxCLEMgLi4uIHNvbnQgZGVzIHBvaW50M2QuIGNvbG9yPSdibGFjaycgcGFyIGTDqWZhdXQuXG4gICAqL1xuY2xhc3MgUG9seWdvbmUzZCB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIC8vIFNpIGxlIHByZW1pZXIgYXJndW1lbnQgZXN0IHVuIHRhYmxlYXVcbiAgICAgIHRoaXMubGlzdGVQb2ludHMgPSBhcmdzWzBdXG4gICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICB0aGlzLmNvbG9yID0gYXJnc1sxXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3RlUG9pbnRzID0gYXJnc1xuICAgICAgdGhpcy5jb2xvciA9ICdibGFjaydcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudHMzZCA9IFtdOyBsZXQgQTsgY29uc3Qgc2VnbWVudHMgPSBbXVxuICAgIEEgPSB0aGlzLmxpc3RlUG9pbnRzWzBdXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmxpc3RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWdtZW50czNkLnB1c2goYXJldGUzZChBLCB0aGlzLmxpc3RlUG9pbnRzW2ldLCB0aGlzLmNvbG9yKSlcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudHMzZFtpIC0gMV0ucDJkKVxuICAgICAgQSA9IHRoaXMubGlzdGVQb2ludHNbaV1cbiAgICB9XG4gICAgc2VnbWVudHMzZC5wdXNoKGFyZXRlM2QoQSwgdGhpcy5saXN0ZVBvaW50c1swXSwgdGhpcy5jb2xvcikpXG4gICAgc2VnbWVudHMucHVzaChzZWdtZW50czNkW3RoaXMubGlzdGVQb2ludHMubGVuZ3RoIC0gMV0ucDJkKVxuICAgIHRoaXMuYXJldGVzID0gc2VnbWVudHMzZFxuICAgIHRoaXMucDJkID0gc2VnbWVudHNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbmUzZCAoLi4uYXJncykge1xuICByZXR1cm4gbmV3IFBvbHlnb25lM2QoLi4uYXJncylcbn1cblxuLypcbiUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlXG4lJSUlJSUlJSUlJSUlJSBPQkpFVFMgREUgQ09NUExFWEVTICUlJSUlJVxuJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSVcbiovXG5cbi8qKlxuICAgKiBMQSBTUEhFUkVcbiAgICpcbiAgICogQEF1dGV1ciBKZWFuLUNsYXVkZSBMaG90ZVxuICAgKiBQcm9kdWl0IHVuZSBzcGjDqHJlIDogY2hvaXNpciB1biBub21icmUgZGUgcGFyYWxsw6hsZXMgaW1wYWlyIHBvdXIgYXZvaXIgbCfDqXF1YXRldXIuIG5vcm1hbCBkw6lmaW5pIGwnYXhlIE5vcmQtU3VkLlxuICAgKiByYXlvbiBlc3QgbGUgcmF5b24gZGUgbGEgc3Bow6hyZS4gbCfDqXF1YXRldXIgZXN0IGRhbnMgbGUgcGxhbiB4eSBsJ2F4ZSBOb3JkLVN1ZCBlc3Qgc3VyIHpcbiAgICogQHBhcmFtIHtQb2ludDNkfSBjZW50cmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJheW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuYl9wYXJhbGxlbGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuYl9tZXJpZGllbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAqL1xuZnVuY3Rpb24gU3BoZXJlM2QgKGNlbnRyZSwgcmF5b24sIG5iX3BhcmFsbGVsZXMsIG5iX21lcmlkaWVucywgY29sb3IpIHtcbiAgT2JqZXRNYXRoYWxlYTJELmNhbGwodGhpcylcbiAgdGhpcy5jZW50cmUgPSBjZW50cmVcbiAgdGhpcy5yYXlvbiA9IHZlY3RldXIzZChyYXlvbiwgMCwgMClcbiAgdGhpcy5ub3JtYWwgPSB2ZWN0ZXVyM2QoMCwgMCwgMSlcbiAgdGhpcy5jb2xvciA9IGNvbG9yXG4gIHRoaXMubmJfbWVyaWRpZW5zID0gbmJfbWVyaWRpZW5zXG4gIHRoaXMubmJfcGFyYWxsZWxlcyA9IG5iX3BhcmFsbGVsZXNcbiAgY29uc3Qgb2JqZXRzID0gW107IGxldCBjMTsgbGV0IGMyOyBsZXQgYzM7IGxldCBjNDsgbGV0IEM7IGxldCBEXG4gIGNvbnN0IHByb2R2ZWMgPSB2ZWN0ZXVyM2QobWF0aC5jcm9zcyh0aGlzLm5vcm1hbC5tYXRyaWNlLCB0aGlzLnJheW9uLm1hdHJpY2UpKVxuICBsZXQgY290ZTEsIGNvdGUyLCByYXlvbjIsIFJcbiAgcmF5b24yID0gdmVjdGV1cjNkKG1hdGguY3Jvc3ModGhpcy5yYXlvbi5tYXRyaWNlLCBtYXRoLm11bHRpcGx5KHByb2R2ZWMubWF0cmljZSwgMSAvIG1hdGgubm9ybShwcm9kdmVjLm1hdHJpY2UpKSkpXG4gIFIgPSByYXlvblxuICBjb3RlMSA9ICdjYWNow6knXG4gIGNvdGUyID0gJ3Zpc2libGUnXG4gIC8vIG9iamV0cy5wdXNoKGNlcmNsZTNkKHRoaXMuY2VudHJlLHJvdGF0aW9uVjNkKHByb2R2ZWMsdGhpcy5ub3JtYWwsbWF0aGFsZWEuYW5nbGVQZXJzcGVjdGl2ZSkscm90YXRpb25WM2QodGhpcy5yYXlvbix0aGlzLm5vcm1hbCxtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKSx0cnVlLHRoaXMuY29sb3IpKVxuICBmb3IgKGxldCBrID0gMCwgcmF5b24zOyBrIDwgMTsgayArPSAxIC8gKHRoaXMubmJfcGFyYWxsZWxlcyArIDEpKSB7XG4gICAgQyA9IHBvaW50M2QoY2VudHJlLngzZCwgY2VudHJlLnkzZCwgY2VudHJlLnozZCArIFIgKiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpKVxuICAgIEQgPSBwb2ludDNkKGNlbnRyZS54M2QsIGNlbnRyZS55M2QsIGNlbnRyZS56M2QgKyBSICogTWF0aC5zaW4oLWsgKiBNYXRoLlBJIC8gMikpXG4gICAgcmF5b24zID0gdmVjdGV1cjNkKFIgKiBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpLCAwLCAwKVxuICAgIGMxID0gZGVtaWNlcmNsZTNkKEMsIHRoaXMubm9ybWFsLCByYXlvbjMsIGNvdGUxLCB0aGlzLmNvbG9yLCBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKVxuICAgIGMyID0gZGVtaWNlcmNsZTNkKEMsIHRoaXMubm9ybWFsLCByYXlvbjMsIGNvdGUyLCB0aGlzLmNvbG9yLCBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKVxuICAgIGMzID0gZGVtaWNlcmNsZTNkKEQsIHRoaXMubm9ybWFsLCByYXlvbjMsIGNvdGUxLCB0aGlzLmNvbG9yLCBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKVxuICAgIGM0ID0gZGVtaWNlcmNsZTNkKEQsIHRoaXMubm9ybWFsLCByYXlvbjMsIGNvdGUyLCB0aGlzLmNvbG9yLCBtYXRoYWxlYS5hbmdsZVBlcnNwZWN0aXZlKVxuICAgIG9iamV0cy5wdXNoKGMxLCBjMiwgYzMsIGM0KVxuICB9XG4gIGZvciAobGV0IGsgPSAwLCBWLCBXOyBrIDwgMTsgayArPSAxIC8gdGhpcy5uYl9tZXJpZGllbnMpIHtcbiAgICBWID0gcm90YXRpb25WM2QocHJvZHZlYywgdGhpcy5ub3JtYWwsIDkwICsgbWF0aGFsZWEuYW5nbGVQZXJzcGVjdGl2ZSArIGsgKiA5MClcbiAgICBXID0gcm90YXRpb25WM2QocHJvZHZlYywgdGhpcy5ub3JtYWwsIDkwICsgbWF0aGFsZWEuYW5nbGVQZXJzcGVjdGl2ZSAtIChrICsgMSAvIHRoaXMubmJfbWVyaWRpZW5zKSAqIDkwKVxuICAgIGMxID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlLCBWLCByYXlvbjIsIGNvdGUyLCB0aGlzLmNvbG9yLCAwKVxuICAgIGMyID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlLCBWLCByYXlvbjIsIGNvdGUxLCB0aGlzLmNvbG9yLCAwKVxuICAgIGMzID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlLCBXLCByYXlvbjIsIGNvdGUyLCB0aGlzLmNvbG9yLCAwKVxuICAgIGM0ID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlLCBXLCByYXlvbjIsIGNvdGUxLCB0aGlzLmNvbG9yLCAwKVxuICAgIG9iamV0cy5wdXNoKGMxLCBjMiwgYzMsIGM0KVxuICB9XG5cbiAgdGhpcy5zdmcgPSBmdW5jdGlvbiAoY29lZmYpIHtcbiAgICBsZXQgY29kZSA9ICcnXG4gICAgZm9yIChjb25zdCBvYmpldCBvZiBvYmpldHMpIHtcbiAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyBvYmpldC5zdmcoY29lZmYpXG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbiAgdGhpcy50aWt6ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBjb2RlID0gJydcbiAgICBmb3IgKGNvbnN0IG9iamV0IG9mIG9iamV0cykge1xuICAgICAgY29kZSArPSAnXFxuXFx0JyArIG9iamV0LnRpa3ooKVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3BoZXJlM2QgKGNlbnRyZSwgcmF5b24sIG5iX3BhcmFsbGVsZXMsIG5iX21lcmlkaWVucywgY29sb3IgPSAnYmxhY2snKSB7XG4gIHJldHVybiBuZXcgU3BoZXJlM2QoY2VudHJlLCByYXlvbiwgbmJfcGFyYWxsZWxlcywgbmJfbWVyaWRpZW5zLCBjb2xvcilcbn1cblxuLyoqXG4gICAgKiBMRSBDT05FXG4gICAgKlxuICAgICogQEF1dGV1ciBKZWFuLUNsYXVkZSBMaG90ZVxuICAgICpcbiAgICAqIGNlbnRyZWJhc2UgZXN0IGxlIGNlbnRyZSBkdSBkaXNxdWUgZGUgYmFzZVxuICAgICogc29tbWV0IGVzdCBsZSBzb21tZXQgZHUgY8O0bmVcbiAgICAqIG5vcm1hbCBlc3QgdW4gdmVjdGV1ciAzZCBub3JtYWwgYXUgcGxhbiBkdSBkaXNxdWUgKGlsIGTDqXRlcm1pbmUgYXZlYyByYXlvbiBkZSBxdWVsIGPDtHTDqSBzZSB0cm91dmUgbGEgcGFydGllIHZpc2libGUpXG4gICAgKlxuICAgICovXG5mdW5jdGlvbiBDb25lM2QgKGNlbnRyZWJhc2UsIHNvbW1ldCwgbm9ybWFsLCByYXlvbiwgZ2VuZXJhdHJpY2VzID0gMTgpIHtcbiAgT2JqZXRNYXRoYWxlYTJELmNhbGwodGhpcylcbiAgdGhpcy5zb21tZXQgPSBzb21tZXRcbiAgdGhpcy5jZW50cmViYXNlID0gY2VudHJlYmFzZVxuICB0aGlzLm5vcm1hbCA9IG5vcm1hbFxuICB0aGlzLnJheW9uID0gcmF5b25cbiAgY29uc3Qgb2JqZXRzID0gW107IGxldCBjMTsgbGV0IGMyOyBsZXQgczsgbGV0IGNvbG9yMTsgbGV0IGNvbG9yMlxuICBjb25zdCBwcm9kdmVjID0gdmVjdGV1cjNkKG1hdGguY3Jvc3Mobm9ybWFsLm1hdHJpY2UsIHJheW9uLm1hdHJpY2UpKVxuICBjb25zdCBwcm9kc2NhbCA9IG1hdGguZG90KHByb2R2ZWMubWF0cmljZSwgdmVjdGV1cjNkKDAsIDEsIDApLm1hdHJpY2UpXG4gIGxldCBjb3RlMSwgY290ZTJcbiAgaWYgKHByb2RzY2FsID4gMCkge1xuICAgIGNvdGUxID0gJ2NhY2jDqSdcbiAgICBjb2xvcjEgPSAnZ3JheSdcbiAgICBjb3RlMiA9ICd2aXNpYmxlJ1xuICAgIGNvbG9yMiA9ICdibGFjaydcbiAgfSBlbHNlIHtcbiAgICBjb3RlMiA9ICdjYWNow6knXG4gICAgY290ZTEgPSAndmlzaWJsZSdcbiAgICBjb2xvcjEgPSAnYmxhY2snXG4gICAgY29sb3IyID0gJ2dyYXknXG4gIH1cbiAgYzEgPSBkZW1pY2VyY2xlM2QodGhpcy5jZW50cmViYXNlLCB0aGlzLm5vcm1hbCwgdGhpcy5yYXlvbiwgY290ZTEsIGNvbG9yMSlcbiAgYzIgPSBkZW1pY2VyY2xlM2QodGhpcy5jZW50cmViYXNlLCB0aGlzLm5vcm1hbCwgdGhpcy5yYXlvbiwgY290ZTIsIGNvbG9yMilcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGMxLmxpc3RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBnZW5lcmF0cmljZXMgPT0gMCkge1xuICAgICAgcyA9IHNlZ21lbnQodGhpcy5zb21tZXQucDJkLCBjMS5saXN0ZVBvaW50c1tpXSlcbiAgICAgIGlmIChjb3RlMSA9PSAnY2FjaMOpJykge1xuICAgICAgICBzLnBvaW50aWxsZXMgPSAyXG4gICAgICAgIHMuY29sb3IgPSAnZ3JheSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuY29sb3IgPSAnYmxhY2snXG4gICAgICB9XG4gICAgICBvYmpldHMucHVzaChzKVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGMyLmxpc3RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBnZW5lcmF0cmljZXMgPT0gMCkge1xuICAgICAgcyA9IHNlZ21lbnQodGhpcy5zb21tZXQucDJkLCBjMi5saXN0ZVBvaW50c1tpXSlcbiAgICAgIGlmIChjb3RlMiA9PSAnY2FjaMOpJykge1xuICAgICAgICBzLnBvaW50aWxsZXMgPSAyXG4gICAgICAgIHMuY29sb3IgPSAnZ3JheSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuY29sb3IgPSAnYmxhY2snXG4gICAgICB9XG4gICAgICBvYmpldHMucHVzaChzKVxuICAgIH1cbiAgfVxuICBvYmpldHMucHVzaChjMSwgYzIpXG4gIHRoaXMuc3ZnID0gZnVuY3Rpb24gKGNvZWZmKSB7XG4gICAgbGV0IGNvZGUgPSAnJ1xuICAgIGZvciAoY29uc3Qgb2JqZXQgb2Ygb2JqZXRzKSB7XG4gICAgICBjb2RlICs9ICdcXG5cXHQnICsgb2JqZXQuc3ZnKGNvZWZmKVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG4gIHRoaXMudGlreiA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY29kZSA9ICcnXG4gICAgZm9yIChjb25zdCBvYmpldCBvZiBvYmpldHMpIHtcbiAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyBvYmpldC50aWt6KClcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmUzZCAoY2VudHJlLCBzb21tZXQsIG5vcm1hbCwgcmF5b24sIGdlbmVyYXRyaWNlcyA9IDE4KSB7XG4gIHJldHVybiBuZXcgQ29uZTNkKGNlbnRyZSwgc29tbWV0LCBub3JtYWwsIHJheW9uLCBnZW5lcmF0cmljZXMpXG59XG5cbi8qKlxuICAgKiBMRSBDWUxJTkRSRVxuICAgKlxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqIENyw6llIHVuIGN5bGluZHJlIGRlIHLDqXZvbHV0aW9uIGTDqWZpbml0IHBhciBsZXMgY2VudHJlcyBkZSBzZXMgMiBiYXNlc1xuICAgKiBQZXJtZXQgZW4gZmFpc2FudCB2YXJpZXIgbGVzIHJheW9ucyBkZXMgZGV1eCBiYXNlcyBkZSBjcsOpZXIgZGVzIHRyb25jcyBkZSBjw7RuZXNcbiAgICogQHBhcmFtIHtQb2ludDNkfSBjZW50cmViYXNlMVxuICAgKiBAcGFyYW0ge1BvaW50M2R9IGNlbnRyZWJhc2UyXG4gICAqIEBwYXJhbSB7VmVjdGV1cjNkfSBub3JtYWxcbiAgICogQHBhcmFtIHtWZWN0ZXVyM2R9IHJheW9uMVxuICAgKiBAcGFyYW0ge1ZlY3RldXIzZH0gcmF5b24yXG4gICAqL1xuZnVuY3Rpb24gQ3lsaW5kcmUzZCAoY2VudHJlYmFzZTEsIGNlbnRyZWJhc2UyLCBub3JtYWwsIHJheW9uMSwgcmF5b24yLCBjb2xvcikge1xuICBPYmpldE1hdGhhbGVhMkQuY2FsbCh0aGlzKVxuICB0aGlzLmNlbnRyZWJhc2UxID0gY2VudHJlYmFzZTFcbiAgdGhpcy5jZW50cmViYXNlMiA9IGNlbnRyZWJhc2UyXG4gIHRoaXMubm9ybWFsID0gbm9ybWFsXG4gIHRoaXMucmF5b24xID0gcmF5b24xXG4gIHRoaXMucmF5b24yID0gcmF5b24yXG4gIHRoaXMuY29sb3IgPSBjb2xvclxuICBjb25zdCBvYmpldHMgPSBbXTsgbGV0IGMxOyBsZXQgYzI7IGxldCBjMzsgbGV0IGM0OyBsZXQgczsgbGV0IGNvbG9yMTsgbGV0IGNvbG9yMlxuICBjb25zdCBwcm9kdmVjID0gdmVjdGV1cjNkKG1hdGguY3Jvc3ModGhpcy5ub3JtYWwubWF0cmljZSwgdGhpcy5yYXlvbjEubWF0cmljZSkpXG4gIGNvbnN0IHByb2RzY2FsID0gbWF0aC5kb3QocHJvZHZlYy5tYXRyaWNlLCB2ZWN0ZXVyM2QoMCwgMSwgMCkubWF0cmljZSlcbiAgbGV0IGNvdGUxLCBjb3RlMlxuICBpZiAocHJvZHNjYWwgPiAwKSB7XG4gICAgY290ZTEgPSAnY2FjaMOpJ1xuICAgIGNvbG9yMSA9IHRoaXMuY29sb3JcbiAgICBjb3RlMiA9ICd2aXNpYmxlJ1xuICAgIGNvbG9yMiA9IHRoaXMuY29sb3JcbiAgfSBlbHNlIHtcbiAgICBjb3RlMiA9ICdjYWNow6knXG4gICAgY290ZTEgPSAndmlzaWJsZSdcbiAgICBjb2xvcjEgPSB0aGlzLmNvbG9yXG4gICAgY29sb3IyID0gdGhpcy5jb2xvclxuICB9XG4gIGMxID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlYmFzZTEsIHRoaXMubm9ybWFsLCB0aGlzLnJheW9uMSwgY290ZTEsIGNvbG9yMSlcbiAgYzMgPSBkZW1pY2VyY2xlM2QodGhpcy5jZW50cmViYXNlMiwgdGhpcy5ub3JtYWwsIHRoaXMucmF5b24yLCBjb3RlMSwgY29sb3IxKVxuICBjMiA9IGRlbWljZXJjbGUzZCh0aGlzLmNlbnRyZWJhc2UxLCB0aGlzLm5vcm1hbCwgdGhpcy5yYXlvbjEsIGNvdGUyLCBjb2xvcjIpXG4gIGM0ID0gZGVtaWNlcmNsZTNkKHRoaXMuY2VudHJlYmFzZTIsIHRoaXMubm9ybWFsLCB0aGlzLnJheW9uMiwgY290ZTIsIGNvbG9yMilcbiAgYzMucG9pbnRpbGxlcyA9IGZhbHNlXG4gIGMzLmNvbG9yID0gdGhpcy5jb2xvclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGMxLmxpc3RlUG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcyA9IHNlZ21lbnQoYzMubGlzdGVQb2ludHNbaV0sIGMxLmxpc3RlUG9pbnRzW2ldKVxuICAgIGlmIChjb3RlMSA9PSAnY2FjaMOpJykge1xuICAgICAgcy5wb2ludGlsbGVzID0gMlxuICAgICAgcy5jb2xvciA9IHRoaXMuY29sb3JcbiAgICAgIHMub3BhY2l0ZSA9IDAuM1xuICAgIH0gZWxzZSB7XG4gICAgICBzLmNvbG9yID0gdGhpcy5jb2xvclxuICAgIH1cbiAgICBvYmpldHMucHVzaChzKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYzIubGlzdGVQb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzID0gc2VnbWVudChjNC5saXN0ZVBvaW50c1tpXSwgYzIubGlzdGVQb2ludHNbaV0pXG4gICAgaWYgKGNvdGUyID09ICdjYWNow6knKSB7XG4gICAgICBzLnBvaW50aWxsZXMgPSAyXG4gICAgICBzLmNvbG9yID0gdGhpcy5jb2xvclxuICAgICAgcy5vcGFjaXRlID0gMC4zXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuY29sb3IgPSB0aGlzLmNvbG9yXG4gICAgfVxuICAgIG9iamV0cy5wdXNoKHMpXG4gIH1cbiAgb2JqZXRzLnB1c2goYzEsIGMyLCBjMywgYzQpXG4gIHRoaXMuc3ZnID0gZnVuY3Rpb24gKGNvZWZmKSB7XG4gICAgbGV0IGNvZGUgPSAnJ1xuICAgIGZvciAoY29uc3Qgb2JqZXQgb2Ygb2JqZXRzKSB7XG4gICAgICBjb2RlICs9ICdcXG5cXHQnICsgb2JqZXQuc3ZnKGNvZWZmKVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG4gIHRoaXMudGlreiA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY29kZSA9ICcnXG4gICAgZm9yIChjb25zdCBvYmpldCBvZiBvYmpldHMpIHtcbiAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyBvYmpldC50aWt6KClcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGN5bGluZHJlM2QgKGNlbnRyZWJhc2UxLCBjZW50cmViYXNlMiwgbm9ybWFsLCByYXlvbiwgcmF5b24yLCBjb2xvciA9ICdibGFjaycpIHtcbiAgcmV0dXJuIG5ldyBDeWxpbmRyZTNkKGNlbnRyZWJhc2UxLCBjZW50cmViYXNlMiwgbm9ybWFsLCByYXlvbiwgcmF5b24yLCBjb2xvcilcbn1cblxuLyoqXG4gICAqIExFIFBSSVNNRVxuICAgKlxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqIENyw6llIHVuIHByaXNtZSDDoCBwYXJ0aXIgZHUgYmFzZSBQb2x5Z29uZTNkIGV0IGQndW4gdmVjdGV1cjNkIGQnZXh0cnVzaW9uIChvbiBwZXV0IGZhaXJlIGRlcyBwcmlzbWVzIGRyb2l0cyBvdSBub24gZHJvaXRzKVxuICAgKi9cbmNsYXNzIFByaXNtZTNkIHtcbiAgY29uc3RydWN0b3IgKGJhc2UsIHZlY3RldXIsIGNvbG9yKSB7XG4gICAgT2JqZXRNYXRoYWxlYTJELmNhbGwodGhpcylcblxuICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgIGJhc2UuY29sb3IgPSBjb2xvclxuICAgIHRoaXMuYmFzZTEgPSBiYXNlXG4gICAgdGhpcy5iYXNlMiA9IHRyYW5zbGF0aW9uM2QoYmFzZSwgdmVjdGV1cilcbiAgICB0aGlzLmJhc2UyLmNvbG9yID0gdGhpcy5iYXNlMS5jb2xvclxuICAgIHRoaXMuYXJldGVzID0gW11cbiAgICBjb25zdCBvYmpldHMgPSBbXTsgbGV0IHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmFzZTEubGlzdGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamV0cy5wdXNoKHRoaXMuYmFzZTEucDJkW2ldKVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmFzZTIubGlzdGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamV0cy5wdXNoKHRoaXMuYmFzZTIucDJkW2ldKVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmFzZTEubGlzdGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHMgPSBhcmV0ZTNkKHRoaXMuYmFzZTEubGlzdGVQb2ludHNbaV0sIHRoaXMuYmFzZTIubGlzdGVQb2ludHNbaV0sIHRoaXMuY29sb3IpXG4gICAgICBvYmpldHMucHVzaChzLnAyZClcbiAgICB9XG5cbiAgICB0aGlzLnN2ZyA9IGZ1bmN0aW9uIChjb2VmZikge1xuICAgICAgbGV0IGNvZGUgPSAnJ1xuICAgICAgZm9yIChjb25zdCBvYmpldCBvZiBvYmpldHMpIHtcbiAgICAgICAgY29kZSArPSAnXFxuXFx0JyArIG9iamV0LnN2Zyhjb2VmZilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICAgIHRoaXMudGlreiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBjb2RlID0gJydcbiAgICAgIGZvciAoY29uc3Qgb2JqZXQgb2Ygb2JqZXRzKSB7XG4gICAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyBvYmpldC50aWt6KClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmlzbWUzZCAoYmFzZSwgdmVjdGV1ciwgY29sb3IgPSAnYmxhY2snKSB7XG4gIHJldHVybiBuZXcgUHJpc21lM2QoYmFzZSwgdmVjdGV1ciwgY29sb3IpXG59XG5cbi8qKlxuICAgKiBMRSBjdWJlXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICogdXNhZ2UgOiBjdWJlKHgseSx6LGMsY29sb3IpIGNvbnN0cnVpdCBsZSBjdWJlIGQnYXLDqHRlIGMgZG9udCBsZSBzb21tZXQgZW4gYmFzIMOgIGdhdWNoZSBhIGxlcyBjb29yZG9ubsOpZXMgeCx5LHouXG4gICAqIGxlIGZhY2UgYXZhbnQgZXN0IGRhbnMgbGUgcGxhbiB4elxuICAgKlxuKi9cbmNsYXNzIEN1YmUzZCB7XG4gIGNvbnN0cnVjdG9yICh4LCB5LCB6LCBjLCBjb2xvciA9ICdibGFjaycpIHtcbiAgICBsZXQgZmFjZUFWLCBmYWNlRHIsIGZhY2VUT1BcbiAgICBjb25zdCBBID0gcG9pbnQzZCh4LCB5LCB6KVxuICAgIGNvbnN0IHZ4ID0gdmVjdGV1cjNkKGMsIDAsIDApXG4gICAgY29uc3QgdnkgPSB2ZWN0ZXVyM2QoMCwgYywgMClcbiAgICBjb25zdCB2eiA9IHZlY3RldXIzZCgwLCAwLCBjKVxuICAgIGNvbnN0IEIgPSB0cmFuc2xhdGlvbjNkKEEsIHZ4KVxuICAgIGNvbnN0IEMgPSB0cmFuc2xhdGlvbjNkKEIsIHZ6KVxuICAgIGNvbnN0IEQgPSB0cmFuc2xhdGlvbjNkKEEsIHZ6KVxuICAgIGNvbnN0IEUgPSB0cmFuc2xhdGlvbjNkKEEsIHZ5KVxuICAgIGNvbnN0IEYgPSB0cmFuc2xhdGlvbjNkKEUsIHZ4KVxuICAgIGNvbnN0IEcgPSB0cmFuc2xhdGlvbjNkKEYsIHZ6KVxuICAgIGNvbnN0IEggPSB0cmFuc2xhdGlvbjNkKEQsIHZ5KVxuICAgIGZhY2VBViA9IHBvbHlnb25lKFtBLnAyZCwgQi5wMmQsIEMucDJkLCBELnAyZF0sIGNvbG9yKVxuICAgIGZhY2VEciA9IHBvbHlnb25lKFtCLnAyZCwgRi5wMmQsIEcucDJkLCBDLnAyZF0sIGNvbG9yKVxuICAgIGZhY2VUT1AgPSBwb2x5Z29uZShbRC5wMmQsIEMucDJkLCBHLnAyZCwgSC5wMmRdLCBjb2xvcilcbiAgICBmYWNlQVYuY291bGV1ckRlUmVtcGxpc3NhZ2UgPSAnI0E5QTlBOSdcbiAgICBmYWNlVE9QLmNvdWxldXJEZVJlbXBsaXNzYWdlID0gJ3doaXRlJ1xuICAgIGZhY2VEci5jb3VsZXVyRGVSZW1wbGlzc2FnZSA9ICcjQTVDNDAwJ1xuICAgIHRoaXMuc3ZnID0gZnVuY3Rpb24gKGNvZWZmKSB7XG4gICAgICByZXR1cm4gZmFjZUFWLnN2Zyhjb2VmZikgKyAnXFxuJyArIGZhY2VUT1Auc3ZnKGNvZWZmKSArICdcXG4nICsgZmFjZURyLnN2Zyhjb2VmZilcbiAgICB9XG4gICAgdGhpcy50aWt6ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhY2VBVi50aWt6KCkgKyAnXFxuJyArIGZhY2VUT1AudGlreigpICsgJ1xcbicgKyBmYWNlRHIudGlreigpXG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3ViZTNkICh4LCB5LCB6LCBjKSB7XG4gIHJldHVybiBuZXcgQ3ViZTNkKHgsIHksIHosIGMpXG59XG5cbmNsYXNzIEN1YmUge1xuICBjb25zdHJ1Y3RvciAoeCwgeSwgeiwgYWxwaGEsIGJldGEsIGNvbG9yRCwgY29sb3JULCBjb2xvckcpIHtcbiAgICBPYmpldE1hdGhhbGVhMkQuY2FsbCh0aGlzKVxuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy56ID0gelxuICAgIHRoaXMuYWxwaGEgPSBhbHBoYVxuICAgIHRoaXMuYmV0YSA9IGJldGFcbiAgICB0aGlzLmNvbG9yRCA9IGNvbG9yRFxuICAgIHRoaXMuY29sb3JHID0gY29sb3JHXG4gICAgdGhpcy5jb2xvclQgPSBjb2xvclRcblxuICAgIHRoaXMubHN0UG9pbnRzID0gW11cbiAgICB0aGlzLmxzdFBvbHlnb25lID0gW11cbiAgICBmdW5jdGlvbiBwcm9qICh4LCB5LCB6LCBhbHBoYSwgYmV0YSkge1xuICAgICAgY29uc3QgY29zYSA9IE1hdGguY29zKGFscGhhICogTWF0aC5QSSAvIDE4MClcbiAgICAgIGNvbnN0IHNpbmEgPSBNYXRoLnNpbihhbHBoYSAqIE1hdGguUEkgLyAxODApXG4gICAgICBjb25zdCBjb3NiID0gTWF0aC5jb3MoYmV0YSAqIE1hdGguUEkgLyAxODApXG4gICAgICBjb25zdCBzaW5iID0gTWF0aC5zaW4oYmV0YSAqIE1hdGguUEkgLyAxODApXG4gICAgICByZXR1cm4gcG9pbnQoY29zYSAqIHggLSBzaW5hICogeSwgLXNpbmEgKiBzaW5iICogeCAtIGNvc2EgKiBzaW5iICogeSArIGNvc2IgKiB6KVxuICAgIH1cblxuICAgIHRoaXMubHN0UG9pbnRzLnB1c2gocHJvaih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLmFscGhhLCB0aGlzLmJldGEpKSAvLyBwb2ludCAwIGVuIGJhc1xuICAgIHRoaXMubHN0UG9pbnRzLnB1c2gocHJvaih0aGlzLnggKyAxLCB0aGlzLnksIHRoaXMueiwgdGhpcy5hbHBoYSwgdGhpcy5iZXRhKSkgLy8gcG9pbnQgMVxuICAgIHRoaXMubHN0UG9pbnRzLnB1c2gocHJvaih0aGlzLnggKyAxLCB0aGlzLnksIHRoaXMueiArIDEsIHRoaXMuYWxwaGEsIHRoaXMuYmV0YSkpIC8vIHBvaW50IDJcbiAgICB0aGlzLmxzdFBvaW50cy5wdXNoKHByb2oodGhpcy54LCB0aGlzLnksIHRoaXMueiArIDEsIHRoaXMuYWxwaGEsIHRoaXMuYmV0YSkpIC8vIHBvaW50IDNcbiAgICB0aGlzLmxzdFBvaW50cy5wdXNoKHByb2oodGhpcy54ICsgMSwgdGhpcy55ICsgMSwgdGhpcy56ICsgMSwgdGhpcy5hbHBoYSwgdGhpcy5iZXRhKSkgLy8gcG9pbnQgNFxuICAgIHRoaXMubHN0UG9pbnRzLnB1c2gocHJvaih0aGlzLngsIHRoaXMueSArIDEsIHRoaXMueiArIDEsIHRoaXMuYWxwaGEsIHRoaXMuYmV0YSkpIC8vIHBvaW50IDVcbiAgICB0aGlzLmxzdFBvaW50cy5wdXNoKHByb2oodGhpcy54LCB0aGlzLnkgKyAxLCB0aGlzLnosIHRoaXMuYWxwaGEsIHRoaXMuYmV0YSkpIC8vIHBvaW50IDZcbiAgICBsZXQgcFxuICAgIHAgPSBwb2x5Z29uZShbdGhpcy5sc3RQb2ludHNbMF0sIHRoaXMubHN0UG9pbnRzWzFdLCB0aGlzLmxzdFBvaW50c1syXSwgdGhpcy5sc3RQb2ludHNbM11dLCAnYmxhY2snKVxuICAgIHAub3BhY2l0ZURlUmVtcGxpc3NhZ2UgPSAxXG4gICAgcC5jb3VsZXVyRGVSZW1wbGlzc2FnZSA9IHRoaXMuY29sb3JEXG4gICAgdGhpcy5sc3RQb2x5Z29uZS5wdXNoKHApXG4gICAgcCA9IHBvbHlnb25lKFt0aGlzLmxzdFBvaW50c1syXSwgdGhpcy5sc3RQb2ludHNbNF0sIHRoaXMubHN0UG9pbnRzWzVdLCB0aGlzLmxzdFBvaW50c1szXV0sICdibGFjaycpXG4gICAgcC5jb3VsZXVyRGVSZW1wbGlzc2FnZSA9IHRoaXMuY29sb3JHXG4gICAgcC5vcGFjaXRlRGVSZW1wbGlzc2FnZSA9IDFcbiAgICB0aGlzLmxzdFBvbHlnb25lLnB1c2gocClcbiAgICBwID0gcG9seWdvbmUoW3RoaXMubHN0UG9pbnRzWzNdLCB0aGlzLmxzdFBvaW50c1s1XSwgdGhpcy5sc3RQb2ludHNbNl0sIHRoaXMubHN0UG9pbnRzWzBdXSwgJ2JsYWNrJylcbiAgICBwLmNvdWxldXJEZVJlbXBsaXNzYWdlID0gdGhpcy5jb2xvclRcbiAgICBwLm9wYWNpdGVEZVJlbXBsaXNzYWdlID0gMVxuICAgIHRoaXMubHN0UG9seWdvbmUucHVzaChwKVxuXG4gICAgdGhpcy5zdmcgPSBmdW5jdGlvbiAoY29lZmYpIHtcbiAgICAgIGxldCBjb2RlID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyB0aGlzLmxzdFBvbHlnb25lW2ldLnN2Zyhjb2VmZilcbiAgICAgIH1cbiAgICAgIGNvZGUgPSBgPGcgaWQ9XCIke3RoaXMuaWR9XCI+JHtjb2RlfTwvZz5gXG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cbiAgICB0aGlzLnRpa3ogPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgY29kZSA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBjb2RlICs9ICdcXG5cXHQnICsgdGhpcy5sc3RQb2x5Z29uZVtpXS50aWt6KClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICAgIHRoaXMuc3ZnbWwgPSBmdW5jdGlvbiAoY29lZmYsIGFtcCkge1xuICAgICAgbGV0IGNvZGUgPSAnJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY29kZSArPSAnXFxuXFx0JyArIHRoaXMubHN0UG9seWdvbmVbaV0uc3ZnbWwoY29lZmYsIGFtcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICAgIHRoaXMudGlrem1sID0gZnVuY3Rpb24gKGFtcCkge1xuICAgICAgbGV0IGNvZGUgPSAnJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgY29kZSArPSAnXFxuXFx0JyArIHRoaXMubHN0UG9seWdvbmVbaV0udGlrem1sKGFtcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3ViZSAoeCA9IDAsIHkgPSAwLCB6ID0gMCwgYWxwaGEgPSA0NSwgYmV0YSA9IC0zNSwgeyBjb2xvckQgPSAnZ3JlZW4nLCBjb2xvclQgPSAnd2hpdGUnLCBjb2xvckcgPSAnZ3JheScgfSA9IHt9KSB7XG4gIHJldHVybiBuZXcgQ3ViZSh4LCB5LCB6LCBhbHBoYSwgYmV0YSwgY29sb3JELCBjb2xvckcsIGNvbG9yVClcbn1cblxuLyoqXG4gICAqIExFIFBBVkVcbiAgICogQEF1dGV1ciBKZWFuLUNsYXVkZSBMaG90ZVxuICAgKiB1c2FnZSA6IHBhdmUoQSxCLEQsRSkgY29uc3RydWl0IGxlIHBhdsOpIEFCQ0RFRkdIIGRvbnQgbGVzIGFyw6p0ZXMgW0FCXSxbQURdIGV0IFtBRV0gc29udCBkw6lsaW1pdGVudCAzIGZhY2VzIGFkamFjZW50ZXMuXG4gICAqXG4qL1xuY2xhc3MgUGF2ZTNkIHtcbiAgY29uc3RydWN0b3IgKEEsIEIsIEQsIEUsIGNvbG9yKSB7XG4gICAgT2JqZXRNYXRoYWxlYTJELmNhbGwodGhpcylcbiAgICBjb25zdCB2MSA9IHZlY3RldXIzZChBLCBCKVxuICAgIGNvbnN0IHYyID0gdmVjdGV1cjNkKEEsIEUpXG4gICAgY29uc3QgdjMgPSB2ZWN0ZXVyM2QoQSwgRClcbiAgICBjb25zdCBDID0gdHJhbnNsYXRpb24zZChELCB2MSlcbiAgICBjb25zdCBIID0gdHJhbnNsYXRpb24zZChELCB2MilcbiAgICBjb25zdCBHID0gdHJhbnNsYXRpb24zZChDLCB2MilcbiAgICBjb25zdCBGID0gdHJhbnNsYXRpb24zZChCLCB2MilcbiAgICBFLnZpc2libGUgPSBmYWxzZVxuICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgIHRoaXMuYmFzZSA9IHBvbHlnb25lM2QoW0EsIEIsIEYsIEVdKVxuICAgIHRoaXMuaGF1dGV1ciA9IHYzXG4gICAgdGhpcy5hcmV0ZXMgPSBbYXJldGUzZChBLCBCLCBjb2xvciksIGFyZXRlM2QoQSwgRCwgY29sb3IpLCBhcmV0ZTNkKEEsIEUsIGNvbG9yKSwgYXJldGUzZChDLCBCLCBjb2xvciksIGFyZXRlM2QoRiwgQiwgY29sb3IpLCBhcmV0ZTNkKEMsIEQsIGNvbG9yKSwgYXJldGUzZChDLCBHLCBjb2xvciksIGFyZXRlM2QoRiwgRywgY29sb3IpLCBhcmV0ZTNkKEYsIEUsIGNvbG9yKSwgYXJldGUzZChILCBHLCBjb2xvciksIGFyZXRlM2QoSCwgRSwgY29sb3IpLCBhcmV0ZTNkKEgsIEQsIGNvbG9yKV1cbiAgICB0aGlzLnN2ZyA9IGZ1bmN0aW9uIChjb2VmZikge1xuICAgICAgbGV0IGNvZGUgPSAnJ1xuICAgICAgZm9yIChjb25zdCBhcmV0ZSBvZiBhcmV0ZXMpIHtcbiAgICAgICAgY29kZSArPSAnXFxuXFx0JyArIGFyZXRlLnAyZC5zdmcoY29lZmYpXG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cbiAgICB0aGlzLnRpa3ogPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgY29kZSA9ICcnXG4gICAgICBmb3IgKGNvbnN0IGFyZXRlIG9mIGFyZXRlcykge1xuICAgICAgICBjb2RlICs9ICdcXG5cXHQnICsgYXJldGUucDJkLnRpa3ooKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXZlM2QgKEEsIEIsIEMsIEUsIGNvbG9yID0gJ2JsYWNrJykge1xuICByZXR1cm4gbmV3IFBhdmUzZChBLCBCLCBDLCBFLCBjb2xvcilcbn1cblxuLypcbiUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlXG4lJSUlJSUlJSUlJSUlJSBUUkFOU0ZPUk1BVElPTlMlJSUlJSUlJSUlJVxuJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSVcbiovXG5cbi8qKlxuICAgKiBMQSBST1RBVElPTiBWRUNUT1JJRUxMRVxuICAgKlxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqIENldHRlIHJvdGF0aW9uIHNlIGRpc3Rpbmd1ZSBkZSBsYSByb3RhdGlvbiBkJ2F4ZSAoZCkgcGFyIGxlIGZhaXQgcXUnb24gdG91cm5lIGF1dG91ciBkJ3VuZSBkcm9pdGUgdmVjdG9yaWVsbGVcbiAgICogRWxsZSBzZXJ0IMOgIGZhaXJlIHRvdXJuZXIgZGVzIHZlY3RldXJzIGVzc2VudGllbGxlbWVudC5cbiAgICogU2kgb24gbCd1dGlsaXNlIHN1ciB1biBwb2ludCwgYWxvcnMgaWwgdG91cm5lcmEgYXV0b3VyIGQndW5lIGRyb2l0ZSBwYXNzYW50IHBhciBsJ29yaWdpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gcG9pbnQzRCBwb3VyIGwnaW5zdGFudCwgY2V0dGUgZm9uY3Rpb24gbmUgZmFpdCB0b3VybmVyIHF1J3VuIHBvaW50M2Qgb3UgdW4gdmVjdGV1cjNkXG4gICAqIEBwYXJhbSB7Kn0gdmVjdGV1cjNEIHZlY3RldXIgZGlyZWN0ZXVyIGRlIGwnYXhlIGRlIHJvdGF0aW9uIChsJ2F4ZSBwYXNzZSBwYXIgbCdvcmlnaW5lLCBwb3VyIHRvdXJuZXIgYXV0b3VyIGQndW5lIGRyb2l0ZSBwYXJ0aWN1bGnDqHJlIG9uIHV0aWxpc2Ugcm90YXRpb24zZCgpKVxuICAgKiBAcGFyYW0geyp9IGFuZ2xlIEFuZ2xlIGRlIHJvdGF0aW9uXG4gICAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0aW9uVjNkIChwb2ludDNELCB2ZWN0ZXVyM0QsIGFuZ2xlKSB7IC8vIHBvaW50ID0gY2UgcXUnb24gZmFpdCB0b3VybmVyIChQb2ludDNkKSA7IHZlY3RldXIgPSBkaXJlY3RldXIgZGUgbCdheGUgZGUgcm90YXRpb24gW3gseSx6XSBldCBhbmdsZSBkZSByb3RhdGlvbiBlbiBkZWdyw6lzXG4gIGxldCBtYXRyaWNlLCBWLCBwMlxuICBjb25zdCBub3JtZSA9IG1hdGgubm9ybSh2ZWN0ZXVyM0QubWF0cmljZSlcbiAgY29uc3QgdW5pdGFpcmUgPSBtYXRoLm11bHRpcGx5KHZlY3RldXIzRC5tYXRyaWNlLCAxIC8gbm9ybWUpXG4gIGNvbnN0IHUgPSB1bml0YWlyZS5fZGF0YVswXTsgY29uc3QgdiA9IHVuaXRhaXJlLl9kYXRhWzFdOyBjb25zdCB3ID0gdW5pdGFpcmUuX2RhdGFbMl1cbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlICogTWF0aC5QSSAvIDE4MCk7IGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSAqIE1hdGguUEkgLyAxODApXG4gIGNvbnN0IGsgPSAxIC0gY1xuICBtYXRyaWNlID0gbWF0aC5tYXRyaXgoW1t1ICogdSAqIGsgKyBjLCB1ICogdiAqIGsgLSB3ICogcywgdSAqIHcgKiBrICsgdiAqIHNdLCBbdSAqIHYgKiBrICsgdyAqIHMsIHYgKiB2ICogayArIGMsIHYgKiB3ICogayAtIHUgKiBzXSwgW3UgKiB3ICogayAtIHYgKiBzLCB2ICogdyAqIGsgKyB1ICogcywgdyAqIHcgKiBrICsgY11dKVxuICBpZiAocG9pbnQzRC5jb25zdHJ1Y3RvciA9PSBQb2ludDNkKSB7XG4gICAgViA9IG1hdGgubWF0cml4KFtwb2ludDNELngzZCwgcG9pbnQzRC55M2QsIHBvaW50M0QuejNkXSlcbiAgICBwMiA9IG1hdGgubXVsdGlwbHkobWF0cmljZSwgVilcbiAgICByZXR1cm4gcG9pbnQzZChwMi5fZGF0YVswXSwgcDIuX2RhdGFbMV0sIHAyLl9kYXRhWzJdKVxuICB9IGVsc2UgaWYgKHBvaW50M0QuY29uc3RydWN0b3IgPT0gVmVjdGV1cjNkKSB7XG4gICAgViA9IHBvaW50M0RcbiAgICBwMiA9IG1hdGgubXVsdGlwbHkobWF0cmljZSwgVi5tYXRyaWNlKVxuICAgIHJldHVybiB2ZWN0ZXVyM2QocDIuX2RhdGFbMF0sIHAyLl9kYXRhWzFdLCBwMi5fZGF0YVsyXSlcbiAgfVxufVxuXG4vKipcbiAgICogTEEgUk9UQVRJT04gRCdBWEUgVU5FIERST0lURVxuICAgKlxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnQzZH0gcG9pbnQzRCBQb3VyIGwnaW5zdGFudCBvbiBuZSBmYWl0IHRvdXJuZXIgcXUndW4gcG9pbnQzZFxuICAgKiBSZW1hcnF1ZSA6IMOnYSBuJ2EgYXVjdW4gc2VucyBkZSBmYWlyZSB0b3VybmVyIHVuIHZlY3RldXIgYXV0b3VyIGQndW5lIGRyb2l0ZSBwYXJ0aWN1bGnDqHJlLCBvbiB1dGlsaXNlIGxhIHJvdGF0aW9uIHZlY3RvcmllbGxlIHBvdXIgw6dhLlxuICAgKiBAcGFyYW0ge0Ryb2l0ZTNkfSBkcm9pdGUzRCBBeGUgZGUgcm90YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIGRlIHJvdGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBjb3VsZXVyIGR1IHBvbHlnb25lIGNyw6nDqS4gc2kgbm9uIHByw6ljaXPDqSBsYSBjb3VsZXVyIHNlcmEgY2VsbGUgZHUgcG9seWdvbmUgYXJndW1lbnRcbiAgICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRpb24zZCAocG9pbnQzRCwgZHJvaXRlM0QsIGFuZ2xlLCBjb2xvcikge1xuICBjb25zdCBkaXJlY3RldXIgPSBkcm9pdGUzRC5kaXJlY3RldXJcbiAgY29uc3Qgb3JpZ2luZSA9IGRyb2l0ZTNELm9yaWdpbmVcbiAgY29uc3QgcCA9IFtdXG4gIGlmIChwb2ludDNELmNvbnN0cnVjdG9yID09IFBvaW50M2QpIHtcbiAgICBjb25zdCBWID0gdmVjdGV1cjNkKG9yaWdpbmUsIHBvaW50M2QoMCwgMCwgMCkpXG4gICAgY29uc3QgVyA9IHZlY3RldXIzZChwb2ludDNkKDAsIDAsIDApLCBvcmlnaW5lKVxuICAgIGNvbnN0IE0gPSB0cmFuc2xhdGlvbjNkKHBvaW50M0QsIFYpXG4gICAgY29uc3QgTiA9IHJvdGF0aW9uVjNkKE0sIGRpcmVjdGV1ciwgYW5nbGUpXG4gICAgcmV0dXJuIHRyYW5zbGF0aW9uM2QoTiwgVylcbiAgfSBlbHNlIGlmIChwb2ludDNELmNvbnN0cnVjdG9yID09IFZlY3RldXIzZCkge1xuICAgIHJldHVybiByb3RhdGlvblYzZChwb2ludDNELCBkaXJlY3RldXIsIGFuZ2xlKVxuICB9IGVsc2UgaWYgKHBvaW50M0QuY29uc3RydWN0b3IgPT0gUG9seWdvbmUzZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnQzRC5saXN0ZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcC5wdXNoKHJvdGF0aW9uM2QocG9pbnQzRC5saXN0ZVBvaW50c1tpXSwgZHJvaXRlM0QsIGFuZ2xlKSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoY29sb3IpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHBvbHlnb25lM2QocCwgY29sb3IpXG4gICAgfSBlbHNlIHsgcmV0dXJuIHBvbHlnb25lM2QocCwgcG9pbnQzRC5jb2xvcikgfVxuICB9XG59XG5cbmZ1bmN0aW9uIFNlbnNEZVJvdGF0aW9uM2QgKGF4ZSwgcmF5b24sIGFuZ2xlLCBlcGFpc3NldXIsIGNvbG9yKSB7XG4gIE9iamV0TWF0aGFsZWEyRC5jYWxsKHRoaXMpXG4gIHRoaXMuZXBhaXNzZXVyID0gZXBhaXNzZXVyXG4gIHRoaXMuY29sb3IgPSBjb2xvclxuICBsZXQgTTsgbGV0IE47IGxldCBzOyBjb25zdCBvYmpldHMgPSBbXTsgbGV0IGQ7IGxldCBBOyBsZXQgQlxuICBNID0gdHJhbnNsYXRpb24zZChheGUub3JpZ2luZSwgcmF5b24pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYW5nbGU7IGkgKz0gNSkge1xuICAgIE4gPSByb3RhdGlvbjNkKE0sIGF4ZSwgNSlcbiAgICBzID0gc2VnbWVudChNLnAyZCwgTi5wMmQpXG4gICAgcy5jb2xvciA9IHRoaXMuY29sb3JcbiAgICBzLmVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyXG4gICAgb2JqZXRzLnB1c2gocylcbiAgICBNID0gTlxuICB9XG4gIE4gPSByb3RhdGlvbjNkKE0sIGF4ZSwgNSlcbiAgcyA9IHNlZ21lbnQoTS5wMmQsIE4ucDJkKVxuICBzLmNvbG9yID0gdGhpcy5jb2xvclxuICBzLmVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyXG4gIG9iamV0cy5wdXNoKHMpXG4gIGQgPSBkcm9pdGUzZChOLCBheGUuZGlyZWN0ZXVyKVxuICBBID0gcm90YXRpb24zZChNLCBkLCAzMClcbiAgQiA9IHJvdGF0aW9uM2QoTSwgZCwgLTMwKVxuICBzID0gc2VnbWVudChOLnAyZCwgQS5wMmQpXG4gIHMuY29sb3IgPSB0aGlzLmNvbG9yXG4gIHMuZXBhaXNzZXVyID0gdGhpcy5lcGFpc3NldXJcbiAgb2JqZXRzLnB1c2gocylcbiAgcyA9IHNlZ21lbnQoTi5wMmQsIEIucDJkKVxuICBzLmNvbG9yID0gdGhpcy5jb2xvclxuICBzLmVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyXG4gIG9iamV0cy5wdXNoKHMpXG4gIHRoaXMuc3ZnID0gZnVuY3Rpb24gKGNvZWZmKSB7XG4gICAgbGV0IGNvZGUgPSAnJ1xuICAgIGZvciAoY29uc3Qgb2JqZXQgb2Ygb2JqZXRzKSB7XG4gICAgICBjb2RlICs9ICdcXG5cXHQnICsgb2JqZXQuc3ZnKGNvZWZmKVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG4gIHRoaXMudGlreiA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY29kZSA9ICcnXG4gICAgZm9yIChjb25zdCBvYmpldCBvZiBvYmpldHMpIHtcbiAgICAgIGNvZGUgKz0gJ1xcblxcdCcgKyBvYmpldC50aWt6KClcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbnNEZVJvdGF0aW9uM2QgKGF4ZSwgcmF5b24sIGFuZ2xlLCBlcGFpc3NldXIsIGNvbG9yKSB7XG4gIHJldHVybiBuZXcgU2Vuc0RlUm90YXRpb24zZChheGUsIHJheW9uLCBhbmdsZSwgZXBhaXNzZXVyLCBjb2xvcilcbn1cblxuLyoqXG4gICAqIExBIFRSQU5TTEFUSU9OXG4gICAqXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICogQHBhcmFtIHtQb2ludDNkfSBwb2ludDNEIFBvdXIgbCdpbnN0YW50IG9uIG5lIHRyYW5zbGF0ZSBxdSd1biBwb2ludDNkIG91IHVuIHBvbHlnb25lM2RcbiAgICogQHBhcmFtIHtWZWN0ZXVyM2R9IHZlY3RldXIzRFxuICAgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGlvbjNkIChwb2ludDNELCB2ZWN0ZXVyM0QpIHtcbiAgaWYgKHBvaW50M0QuY29uc3RydWN0b3IgPT0gUG9pbnQzZCkge1xuICAgIGNvbnN0IHggPSBwb2ludDNELngzZCArIHZlY3RldXIzRC54M2RcbiAgICBjb25zdCB5ID0gcG9pbnQzRC55M2QgKyB2ZWN0ZXVyM0QueTNkXG4gICAgY29uc3QgeiA9IHBvaW50M0QuejNkICsgdmVjdGV1cjNELnozZFxuICAgIHJldHVybiBwb2ludDNkKHgsIHksIHopXG4gIH0gZWxzZSBpZiAocG9pbnQzRC5jb25zdHJ1Y3RvciA9PSBQb2x5Z29uZTNkKSB7XG4gICAgY29uc3QgcCA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludDNELmxpc3RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwLnB1c2godHJhbnNsYXRpb24zZChwb2ludDNELmxpc3RlUG9pbnRzW2ldLCB2ZWN0ZXVyM0QpKVxuICAgIH1cbiAgICByZXR1cm4gcG9seWdvbmUzZChwLCBwb2ludDNELmNvbG9yKVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaG9tb3RoZXRpZTNkIChwb2ludDNELCBjZW50cmUsIHJhcHBvcnQsIGNvbG9yKSB7XG4gIGxldCBWXG4gIGNvbnN0IHAgPSBbXVxuICBpZiAocG9pbnQzRC5jb25zdHJ1Y3RvciA9PSBQb2ludDNkKSB7XG4gICAgViA9IHZlY3RldXIzZChjZW50cmUsIHBvaW50M0QpXG4gICAgVi54M2QgKj0gcmFwcG9ydFxuICAgIFYueTNkICo9IHJhcHBvcnRcbiAgICBWLnkzZCAqPSByYXBwb3J0XG4gICAgcmV0dXJuIHRyYW5zbGF0aW9uM2QoY2VudHJlLCBWKVxuICB9IGVsc2UgaWYgKHBvaW50M0QuY29uc3RydWN0b3IgPT0gVmVjdGV1cjNkKSB7XG4gICAgViA9IHBvaW50M0RcbiAgICBWLngzZCAqPSByYXBwb3J0XG4gICAgVi55M2QgKj0gcmFwcG9ydFxuICAgIFYueTNkICo9IHJhcHBvcnRcbiAgICByZXR1cm4gVlxuICB9IGVsc2UgaWYgKHBvaW50M0QuY29uc3RydWN0b3IgPT0gUG9seWdvbmUzZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnQzRC5saXN0ZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcC5wdXNoKGhvbW90aGV0aWUzZChwb2ludDNELmxpc3RlUG9pbnRzW2ldLCBjZW50cmUsIHJhcHBvcnQsIGNvbG9yKSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoY29sb3IpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHBvbHlnb25lM2QocCwgY29sb3IpXG4gICAgfSBlbHNlIHsgcmV0dXJuIHBvbHlnb25lM2QocCwgcG9pbnQzRC5jb2xvcikgfVxuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBQ0E7QUE2QkE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXJDQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUF6RUE7QUFDQTtBQXlFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/modules/3d.js\n");

/***/ })

}]);