{"version":3,"sources":["webpack://mathalea/./src/js/exercices/ClasseExercice.js","webpack://mathalea/./src/js/modules/3d.js"],"names":["Exercice","this","titre","consigne","consigneCorrection","listeQuestions","listeCorrections","introduction","contenu","contenuCorrection","nbQuestions","nbCols","nbColsCorr","spacing","spacingCorr","beamer","besoinFormulaireNumerique","besoinFormulaireTexte","besoinFormulaireCaseACocher","consigneModifiable","nbQuestionsModifiable","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","correctionDetailleeDisponible","correctionDetaillee","video","boutonAide","tailleDiaporama","pasDeVersionLatex","qcm","qcmDisponible","modeQcm","mg32Editable","nouvelleVersion","numeroExercice","listePackages","math","matrix","multiply","norm","cross","dot","numId","ObjetMathalea2D","positionLabel","isVisible","color","style","styleTikz","epaisseur","opacite","pointilles","id","mathalea","objets2D","push","Point3d","constructor","x3d","y3d","z3d","visible","label","alpha","anglePerspective","Math","PI","rapport","coeffPerspective","MT","cos","sin","V","W","p2d","point","_data","point3d","Vecteur3d","args","length","matrice","vecteur","representant","A","B","translation3d","vecteur3d","Arete3d","point1","point2","extremite1","extremite2","segment","arete3d","p1","p2","Droite3d","point3D","vecteur3D","directeur","origine","M","droite","droite3d","demicercle3d","centre","normal","rayon","cote","angledepart","demiCercle","signe","listepoints","d","rotation3d","i","polyline","cercle3d","C","polygone","Polygone3d","Array","isArray","listePoints","segments3d","segments","aretes","polygone3d","Sphere3d","nb_paralleles","nb_meridiens","call","objets","c1","c2","c3","c4","D","prodvec","cote1","cote2","rayon2","R","rayon3","k","rotationV3d","svg","coeff","code","objet","tikz","sphere3d","Cone3d","centrebase","sommet","generatrices","s","color1","color2","cone3d","Cylindre3d","centrebase1","centrebase2","rayon1","cylindre3d","Cube","x","y","z","beta","colorD","colorT","colorG","proj","cosa","sina","cosb","sinb","p","lstPoints","lstPolygone","opaciteDeRemplissage","couleurDeRemplissage","svgml","amp","tikzml","cube","angle","norme","unitaire","u","v","w","c","droite3D","SensDeRotation3d","axe","N","sensDeRotation3d"],"mappings":"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","file":"js/204.16cca01fb8d112a813e1.js","sourcesContent":["/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nexport default function Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = ''\n  this.consigne = ''\n  this.consigneCorrection = ''\n  this.listeQuestions = []\n  this.listeCorrections = []\n  this.introduction = ''\n  this.contenu = ''\n  this.contenuCorrection = ''\n  this.nbQuestions = 10\n  this.nbCols = 2\n  this.nbColsCorr = 2\n  this.spacing = 1\n  this.spacingCorr = 1\n  this.beamer = false\n\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte];\n  this.consigneModifiable = true\n  this.nbQuestionsModifiable = true\n  this.nbColsModifiable = true\n  this.nbColsCorrModifiable = true\n  this.spacingModifiable = true\n  this.spacingCorrModifiable = true\n  this.correctionDetailleeDisponible = false\n  this.correctionDetaillee = true\n  this.video = ''\n  this.boutonAide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pasDeVersionLatex = false\n  this.qcm = false // Pour les exercices de type QCM : contient un tableau.\n  this.qcmDisponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n  this.modeQcm = false // Pour choisir la version QCM ou la version classique (false = version classique)\n\n  this.mg32Editable = false // pas d'interface par défaut pour les figures MG32\n  this.nouvelleVersion = function (numeroExercice) {}\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n","/* global mathalea */\nimport { point, vecteur, droite, segment, polyline, polygone } from './2d.js'\nimport { matrix, multiply, norm, cross, dot } from 'mathjs'\nconst math = { matrix: matrix, multiply: multiply, norm: norm, cross: cross, dot: dot }\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @Auteur Rémi Angot\n */\nlet numId = 0\nfunction ObjetMathalea2D () {\n  this.positionLabel = 'above'\n  this.isVisible = true\n  this.color = 'black'\n  this.style = '' // stroke-dasharray=\"4 3\" pour des hachures //stroke-width=\"2\" pour un trait plus épais\n  this.styleTikz = ''\n  this.epaisseur = 1\n  this.opacite = 1\n  this.pointilles = false\n  this.id = numId\n  numId++\n  //   mesObjets.push(this);\n  mathalea.objets2D.push(this)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * LE POINT\n *\n* @Auteur Jean-Claude Lhote\n* Point de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n* le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n*/\nclass Point3d {\n  constructor (x3d, y3d, z3d, visible, label) {\n    const alpha = mathalea.anglePerspective * Math.PI / 180\n    const rapport = mathalea.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    this.x3d = x3d\n    this.y3d = y3d\n    this.z3d = z3d\n    this.visible = visible\n    this.label = label\n    const V = math.matrix([this.x3d, this.y3d, this.z3d])\n    const W = math.multiply(MT, V)\n    this.p2d = point(W._data[0], W._data[1], this.label)\n  }\n}\nexport function point3d (x3d, y3d, z3d = 0, visible = true, label = '') {\n  return new Point3d(x3d, y3d, z3d, visible, label)\n}\n\n/**\n   * LE VECTEUR\n   *\n   * @Auteur Jean-Claude Lhote\n   * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n   * On les utilise dans tous les objets complexeimport Additionner_soustraires_decimaux from '../exercices/6e/6C20';\ns et dans toutes les transformations.import Nature_polygone from './../exercices/2e/2G12';\nimport Exercice_fractions_decomposer from './../exercices/6e/6N20';\n\n   * Ils servent notament à définir la direction des plans.\n   *\n   * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n   * A et B sont deux objets de type Point3d\n   * x,y et z sont trois nombres\n   * la commande math.matrix([x,y,z]) crée une matrice colonne.\n   *\n   * L'objet créé est de type Vecteur3d\n   * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n   * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n   */\nclass Vecteur3d {\n  constructor (...args) {\n    const alpha = mathalea.anglePerspective * Math.PI / 180\n    const rapport = mathalea.coeffPerspective\n    const MT = math.matrix([[1, rapport * Math.cos(alpha), 0], [0, rapport * Math.sin(alpha), 1]])\n    if (args.length == 2) {\n      this.x3d = args[1].x3d - args[0].x3d\n      this.y3d = args[1].y3d - args[0].y3d\n      this.z3d = args[1].z3d - args[0].z3d\n    } else {\n      if (typeof (args[0]) === 'number') {\n        this.x3d = args[0]\n        this.y3d = args[1]\n        this.z3d = args[2]\n      } else if (args.length == 1) {\n        this.x3d = args[0]._data[0]\n        this.y3d = args[0]._data[1]\n        this.z3d = args[0]._data[2]\n      }\n    }\n    this.matrice = math.matrix([this.x3d, this.y3d, this.z3d])\n    const W = math.multiply(MT, this.matrice)\n    this.p2d = vecteur(W._data[0], W._data[1])\n    this.representant = function (A) {\n      const B = translation3d(A, this)\n      return vecteur(A.p2d, B.p2d).representant(A.p2d)\n    }\n  }\n}\n\nexport function vecteur3d (...args) { // A,B deux Point3d ou x,y,z les composantes du vecteur\n  return new Vecteur3d(...args)\n}\n\n/**\n   * L'ARETE\n   * @Auteur Jean-Claude lhote\n   *\n   *\n   *\n   */\nclass Arete3d {\n  constructor (point1, point2, color) {\n    this.extremite1 = point1\n    this.extremite2 = point2\n    this.color = color\n    if (!point1.visible || !point2.visible) {\n      this.visible = false\n    } else {\n      this.visible = true\n    }\n    this.p2d = segment(point1.p2d, point2.p2d, color)\n    if (!this.visible) {\n      this.p2d.pointilles = 2\n    } else {\n      this.p2d.pointilles = false\n    }\n  }\n}\nexport function arete3d (p1, p2, color = 'black') {\n  return new Arete3d(p1, p2, color)\n}\n\n/**\n   * LA DROITE\n   *\n   * @Auteur Jean-claude Lhote\n   * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n   * Droite de l'espace définie par 2 points droite3d(A,B)\n   * Les droites servent principalement à définir des axes de rotation dans l'espace\n   */\nclass Droite3d {\n  constructor (point3D, vecteur3D) {\n    if (vecteur3D.constructor == Vecteur3d) {\n      this.directeur = vecteur3D\n    } else if (vecteur3D.constructor == Point3d) {\n      this.directeur = vecteur3d(point3D, vecteur3D)\n    }\n    this.origine = point3D\n    const M = translation3d(this.origine, this.directeur)\n    this.point = M\n    this.p2d = droite(this.origine.p2d, M.p2d) // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n    this.p2d.isVisible = false\n  }\n}\n\nexport function droite3d (point3D, vecteur3D) {\n  return new Droite3d(point3D, vecteur3D)\n}\n\n/**\n * LE DEMI-CERCLE\n *\n *@Auteur Jean-Claude Lhote\n * Le nom est trompeur, il s'agit le plus souvent d'une demi-ellipse représentant un cercle projeté\n * Utilisé pour représenter un cercle dont une moitié est visible mais pas l'autre.\n *\n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible' et déterminera dans quel sens on crée le demi-cercle.\n * Si cote='caché' alors on tourne dans le sens direct et le tracé est en pointillés\n * Si cote='visible' alors on tourne dans le sens indirect et le tracé est plein.\n *\n */\nexport function demicercle3d (centre, normal, rayon, cote, color, angledepart = mathalea.anglePerspective) {\n  let demiCercle; let signe; const M = []; const listepoints = []\n  if (cote == 'caché') {\n    signe = 1\n  } else {\n    signe = -1\n  }\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, angledepart))\n  listepoints.push(M[0].p2d)\n\n  for (let i = 1; i < 19; i++) {\n    M.push(rotation3d(M[i - 1], d, 10 * signe))\n    listepoints.push(M[i].p2d)\n  }\n  demiCercle = polyline(listepoints, color)\n  if (cote == 'caché') {\n    demiCercle.pointilles = 2\n    demiCercle.opacite = 0.3\n  }\n  return demiCercle\n}\n\n/**\n    * LE CERCLE\n    *\n    * @Auteur Jean-Claude Lhote\n    *\n    * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n    * visible est un booléen\n    *\n    */\nexport function cercle3d (centre, normal, rayon, visible = true, color = 'black') {\n  let C; const M = []; const listepoints = []\n  const d = droite3d(centre, normal)\n  M.push(rotation3d(translation3d(centre, rayon), d, mathalea.anglePerspective))\n  listepoints.push(M[0].p2d)\n  for (let i = 1; i < 37; i++) {\n    M.push(rotation3d(M[i - 1], d, 10))\n    listepoints.push(M[i].p2d)\n  }\n  C = polygone(listepoints, color)\n  if (!visible) {\n    C.pointilles = 2\n  }\n  return C\n}\n\n/**\n   * LE POLYGONE\n   *\n   * @Auteur Jean-Claude Lhote\n   * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n   */\nclass Polygone3d {\n  constructor (...args) {\n    if (Array.isArray(args[0])) {\n      // Si le premier argument est un tableau\n      this.listePoints = args[0]\n      if (args[1]) {\n        this.color = args[1]\n      }\n    } else {\n      this.listePoints = args\n      this.color = 'black'\n    }\n    const segments3d = []; let A; const segments = []\n    A = this.listePoints[0]\n    for (let i = 1; i < this.listePoints.length; i++) {\n      segments3d.push(arete3d(A, this.listePoints[i], this.color))\n      segments.push(segments3d[i - 1].p2d)\n      A = this.listePoints[i]\n    }\n    segments3d.push(arete3d(A, this.listePoints[0], this.color))\n    segments.push(segments3d[this.listePoints.length - 1].p2d)\n    this.aretes = segments3d\n    this.p2d = segments\n  }\n}\n\nexport function polygone3d (...args) {\n  return new Polygone3d(...args)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE COMPLEXES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA SPHERE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n   * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n   * @param {Point3d} centre\n   * @param {Number} rayon\n   * @param {Number} nb_paralleles\n   * @param {Number} nb_meridiens\n   * @param {string} color\n   */\nfunction Sphere3d (centre, rayon, nb_paralleles, nb_meridiens, color) {\n  ObjetMathalea2D.call(this)\n  this.centre = centre\n  this.rayon = vecteur3d(rayon, 0, 0)\n  this.normal = vecteur3d(0, 0, 1)\n  this.color = color\n  this.nb_meridiens = nb_meridiens\n  this.nb_paralleles = nb_paralleles\n  const objets = []; let c1; let c2; let c3; let c4; let C; let D\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon.matrice))\n  let cote1, cote2, rayon2, R\n  rayon2 = vecteur3d(math.cross(this.rayon.matrice, math.multiply(prodvec.matrice, 1 / math.norm(prodvec.matrice))))\n  R = rayon\n  cote1 = 'caché'\n  cote2 = 'visible'\n  // objets.push(cercle3d(this.centre,rotationV3d(prodvec,this.normal,mathalea.anglePerspective),rotationV3d(this.rayon,this.normal,mathalea.anglePerspective),true,this.color))\n  for (let k = 0, rayon3; k < 1; k += 1 / (this.nb_paralleles + 1)) {\n    C = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(k * Math.PI / 2))\n    D = point3d(centre.x3d, centre.y3d, centre.z3d + R * Math.sin(-k * Math.PI / 2))\n    rayon3 = vecteur3d(R * Math.cos(k * Math.PI / 2), 0, 0)\n    c1 = demicercle3d(C, this.normal, rayon3, cote1, this.color, mathalea.anglePerspective)\n    c2 = demicercle3d(C, this.normal, rayon3, cote2, this.color, mathalea.anglePerspective)\n    c3 = demicercle3d(D, this.normal, rayon3, cote1, this.color, mathalea.anglePerspective)\n    c4 = demicercle3d(D, this.normal, rayon3, cote2, this.color, mathalea.anglePerspective)\n    objets.push(c1, c2, c3, c4)\n  }\n  for (let k = 0, V, W; k < 1; k += 1 / this.nb_meridiens) {\n    V = rotationV3d(prodvec, this.normal, 90 + mathalea.anglePerspective + k * 90)\n    W = rotationV3d(prodvec, this.normal, 90 + mathalea.anglePerspective - (k + 1 / this.nb_meridiens) * 90)\n    c1 = demicercle3d(this.centre, V, rayon2, cote2, this.color, 0)\n    c2 = demicercle3d(this.centre, V, rayon2, cote1, this.color, 0)\n    c3 = demicercle3d(this.centre, W, rayon2, cote2, this.color, 0)\n    c4 = demicercle3d(this.centre, W, rayon2, cote1, this.color, 0)\n    objets.push(c1, c2, c3, c4)\n  }\n\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sphere3d (centre, rayon, nb_paralleles, nb_meridiens, color = 'black') {\n  return new Sphere3d(centre, rayon, nb_paralleles, nb_meridiens, color)\n}\n\n/**\n    * LE CONE\n    *\n    * @Auteur Jean-Claude Lhote\n    *\n    * centrebase est le centre du disque de base\n    * sommet est le sommet du cône\n    * normal est un vecteur 3d normal au plan du disque (il détermine avec rayon de quel côté se trouve la partie visible)\n    *\n    */\nfunction Cone3d (centrebase, sommet, normal, rayon, generatrices = 18) {\n  ObjetMathalea2D.call(this)\n  this.sommet = sommet\n  this.centrebase = centrebase\n  this.normal = normal\n  this.rayon = rayon\n  const objets = []; let c1; let c2; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(normal.matrice, rayon.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = 'gray'\n    cote2 = 'visible'\n    color2 = 'black'\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = 'black'\n    color2 = 'gray'\n  }\n  c1 = demicercle3d(this.centrebase, this.normal, this.rayon, cote1, color1)\n  c2 = demicercle3d(this.centrebase, this.normal, this.rayon, cote2, color2)\n\n  for (let i = 0; i < c1.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = segment(this.sommet.p2d, c1.listePoints[i])\n      if (cote1 == 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  for (let i = 0; i < c2.listePoints.length; i++) {\n    if (i % generatrices == 0) {\n      s = segment(this.sommet.p2d, c2.listePoints[i])\n      if (cote2 == 'caché') {\n        s.pointilles = 2\n        s.color = 'gray'\n      } else {\n        s.color = 'black'\n      }\n      objets.push(s)\n    }\n  }\n  objets.push(c1, c2)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cone3d (centre, sommet, normal, rayon, generatrices = 18) {\n  return new Cone3d(centre, sommet, normal, rayon, generatrices)\n}\n\n/**\n   * LE CYLINDRE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Crée un cylindre de révolution définit par les centres de ses 2 bases\n   * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes\n   * @param {Point3d} centrebase1\n   * @param {Point3d} centrebase2\n   * @param {Vecteur3d} normal\n   * @param {Vecteur3d} rayon1\n   * @param {Vecteur3d} rayon2\n   */\nfunction Cylindre3d (centrebase1, centrebase2, normal, rayon1, rayon2, color) {\n  ObjetMathalea2D.call(this)\n  this.centrebase1 = centrebase1\n  this.centrebase2 = centrebase2\n  this.normal = normal\n  this.rayon1 = rayon1\n  this.rayon2 = rayon2\n  this.color = color\n  const objets = []; let c1; let c2; let c3; let c4; let s; let color1; let color2\n  const prodvec = vecteur3d(math.cross(this.normal.matrice, this.rayon1.matrice))\n  const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n  let cote1, cote2\n  if (prodscal > 0) {\n    cote1 = 'caché'\n    color1 = this.color\n    cote2 = 'visible'\n    color2 = this.color\n  } else {\n    cote2 = 'caché'\n    cote1 = 'visible'\n    color1 = this.color\n    color2 = this.color\n  }\n  c1 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote1, color1)\n  c3 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote1, color1)\n  c2 = demicercle3d(this.centrebase1, this.normal, this.rayon1, cote2, color2)\n  c4 = demicercle3d(this.centrebase2, this.normal, this.rayon2, cote2, color2)\n  c3.pointilles = false\n  c3.color = this.color\n  for (let i = 0; i < c1.listePoints.length; i += 2) {\n    s = segment(c3.listePoints[i], c1.listePoints[i])\n    if (cote1 == 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  for (let i = 0; i < c2.listePoints.length; i += 2) {\n    s = segment(c4.listePoints[i], c2.listePoints[i])\n    if (cote2 == 'caché') {\n      s.pointilles = 2\n      s.color = this.color\n      s.opacite = 0.3\n    } else {\n      s.color = this.color\n    }\n    objets.push(s)\n  }\n  objets.push(c1, c2, c3, c4)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function cylindre3d (centrebase1, centrebase2, normal, rayon, rayon2, color = 'black') {\n  return new Cylindre3d(centrebase1, centrebase2, normal, rayon, rayon2, color)\n}\n\n/**\n   * LE PRISME\n   *\n   * @Auteur Jean-Claude Lhote\n   * Crée un prisme à partir du base Polygone3d et d'un vecteur3d d'extrusion (on peut faire des prismes droits ou non droits)\n   */\nclass Prisme3d {\n  constructor (base, vecteur, color) {\n    ObjetMathalea2D.call(this)\n\n    this.color = color\n    base.color = color\n    this.base1 = base\n    this.base2 = translation3d(base, vecteur)\n    this.base2.color = this.base1.color\n    this.aretes = []\n    const objets = []; let s\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      objets.push(this.base1.p2d[i])\n    }\n    for (let i = 0; i < this.base2.listePoints.length; i++) {\n      objets.push(this.base2.p2d[i])\n    }\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      s = arete3d(this.base1.listePoints[i], this.base2.listePoints[i], this.color)\n      objets.push(s.p2d)\n    }\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const objet of objets) {\n        code += '\\n\\t' + objet.tikz()\n      }\n      return code\n    }\n  }\n}\n\nexport function prisme3d (base, vecteur, color = 'black') {\n  return new Prisme3d(base, vecteur, color)\n}\n\n/**\n   * LE cube\n   * @Auteur Jean-Claude Lhote\n   * usage : cube(x,y,z,c,color) construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z.\n   * le face avant est dans le plan xz\n   *\n*/\nclass Cube3d {\n  constructor (x, y, z, c, color = 'black') {\n    let faceAV, faceDr, faceTOP\n    const A = point3d(x, y, z)\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n    const B = translation3d(A, vx)\n    const C = translation3d(B, vz)\n    const D = translation3d(A, vz)\n    const E = translation3d(A, vy)\n    const F = translation3d(E, vx)\n    const G = translation3d(F, vz)\n    const H = translation3d(D, vy)\n    faceAV = polygone([A.p2d, B.p2d, C.p2d, D.p2d], color)\n    faceDr = polygone([B.p2d, F.p2d, G.p2d, C.p2d], color)\n    faceTOP = polygone([D.p2d, C.p2d, G.p2d, H.p2d], color)\n    faceAV.couleurDeRemplissage = '#A9A9A9'\n    faceTOP.couleurDeRemplissage = 'white'\n    faceDr.couleurDeRemplissage = '#A5C400'\n    this.svg = function (coeff) {\n      return faceAV.svg(coeff) + '\\n' + faceTOP.svg(coeff) + '\\n' + faceDr.svg(coeff)\n    }\n    this.tikz = function () {\n      return faceAV.tikz() + '\\n' + faceTOP.tikz() + '\\n' + faceDr.tikz()\n    }\n  }\n}\nexport function cube3d (x, y, z, c) {\n  return new Cube3d(x, y, z, c)\n}\n\nclass Cube {\n  constructor (x, y, z, alpha, beta, colorD, colorT, colorG) {\n    ObjetMathalea2D.call(this)\n    this.x = x\n    this.y = y\n    this.z = z\n    this.alpha = alpha\n    this.beta = beta\n    this.colorD = colorD\n    this.colorG = colorG\n    this.colorT = colorT\n\n    this.lstPoints = []\n    this.lstPolygone = []\n    function proj (x, y, z, alpha, beta) {\n      const cosa = Math.cos(alpha * Math.PI / 180)\n      const sina = Math.sin(alpha * Math.PI / 180)\n      const cosb = Math.cos(beta * Math.PI / 180)\n      const sinb = Math.sin(beta * Math.PI / 180)\n      return point(cosa * x - sina * y, -sina * sinb * x - cosa * sinb * y + cosb * z)\n    }\n\n    this.lstPoints.push(proj(this.x, this.y, this.z, this.alpha, this.beta)) // point 0 en bas\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z, this.alpha, this.beta)) // point 1\n    this.lstPoints.push(proj(this.x + 1, this.y, this.z + 1, this.alpha, this.beta)) // point 2\n    this.lstPoints.push(proj(this.x, this.y, this.z + 1, this.alpha, this.beta)) // point 3\n    this.lstPoints.push(proj(this.x + 1, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 4\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z + 1, this.alpha, this.beta)) // point 5\n    this.lstPoints.push(proj(this.x, this.y + 1, this.z, this.alpha, this.beta)) // point 6\n    let p\n    p = polygone([this.lstPoints[0], this.lstPoints[1], this.lstPoints[2], this.lstPoints[3]], 'black')\n    p.opaciteDeRemplissage = 1\n    p.couleurDeRemplissage = this.colorD\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[2], this.lstPoints[4], this.lstPoints[5], this.lstPoints[3]], 'black')\n    p.couleurDeRemplissage = this.colorG\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n    p = polygone([this.lstPoints[3], this.lstPoints[5], this.lstPoints[6], this.lstPoints[0]], 'black')\n    p.couleurDeRemplissage = this.colorT\n    p.opaciteDeRemplissage = 1\n    this.lstPolygone.push(p)\n\n    this.svg = function (coeff) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svg(coeff)\n      }\n      code = `<g id=\"${this.id}\">${code}</g>`\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikz()\n      }\n      return code\n    }\n    this.svgml = function (coeff, amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].svgml(coeff, amp)\n      }\n      return code\n    }\n    this.tikzml = function (amp) {\n      let code = ''\n      for (let i = 0; i < 3; i++) {\n        code += '\\n\\t' + this.lstPolygone[i].tikzml(amp)\n      }\n      return code\n    }\n  }\n}\nexport function cube (x = 0, y = 0, z = 0, alpha = 45, beta = -35, { colorD = 'green', colorT = 'white', colorG = 'gray' } = {}) {\n  return new Cube(x, y, z, alpha, beta, colorD, colorG, colorT)\n}\n\n/**\n   * LE PAVE\n   * @Auteur Jean-Claude Lhote\n   * usage : pave(A,B,D,E) construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] sont délimitent 3 faces adjacentes.\n   *\n*/\nclass Pave3d {\n  constructor (A, B, D, E, color) {\n    ObjetMathalea2D.call(this)\n    const v1 = vecteur3d(A, B)\n    const v2 = vecteur3d(A, E)\n    const v3 = vecteur3d(A, D)\n    const C = translation3d(D, v1)\n    const H = translation3d(D, v2)\n    const G = translation3d(C, v2)\n    const F = translation3d(B, v2)\n    E.visible = false\n    this.color = color\n    this.base = polygone3d([A, B, F, E])\n    this.hauteur = v3\n    this.aretes = [arete3d(A, B, color), arete3d(A, D, color), arete3d(A, E, color), arete3d(C, B, color), arete3d(F, B, color), arete3d(C, D, color), arete3d(C, G, color), arete3d(F, G, color), arete3d(F, E, color), arete3d(H, G, color), arete3d(H, E, color), arete3d(H, D, color)]\n    this.svg = function (coeff) {\n      let code = ''\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      for (const arete of aretes) {\n        code += '\\n\\t' + arete.p2d.tikz()\n      }\n      return code\n    }\n  }\n}\nexport function pave3d (A, B, C, E, color = 'black') {\n  return new Pave3d(A, B, C, E, color)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n   * LA ROTATION VECTORIELLE\n   *\n   * @Auteur Jean-Claude Lhote\n   * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n   * Elle sert à faire tourner des vecteurs essentiellement.\n   * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n   *\n   * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n   * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n   * @param {*} angle Angle de rotation\n   */\nexport function rotationV3d (point3D, vecteur3D, angle) { // point = ce qu'on fait tourner (Point3d) ; vecteur = directeur de l'axe de rotation [x,y,z] et angle de rotation en degrés\n  let matrice, V, p2\n  const norme = math.norm(vecteur3D.matrice)\n  const unitaire = math.multiply(vecteur3D.matrice, 1 / norme)\n  const u = unitaire._data[0]; const v = unitaire._data[1]; const w = unitaire._data[2]\n  const c = Math.cos(angle * Math.PI / 180); const s = Math.sin(angle * Math.PI / 180)\n  const k = 1 - c\n  matrice = math.matrix([[u * u * k + c, u * v * k - w * s, u * w * k + v * s], [u * v * k + w * s, v * v * k + c, v * w * k - u * s], [u * w * k - v * s, v * w * k + u * s, w * w * k + c]])\n  if (point3D.constructor == Point3d) {\n    V = math.matrix([point3D.x3d, point3D.y3d, point3D.z3d])\n    p2 = math.multiply(matrice, V)\n    return point3d(p2._data[0], p2._data[1], p2._data[2])\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D\n    p2 = math.multiply(matrice, V.matrice)\n    return vecteur3d(p2._data[0], p2._data[1], p2._data[2])\n  }\n}\n\n/**\n   * LA ROTATION D'AXE UNE DROITE\n   *\n   * @Auteur Jean-Claude Lhote\n   *\n   * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n   * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n   * @param {Droite3d} droite3D Axe de rotation\n   * @param {Number} angle Angle de rotation\n   * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n   */\nexport function rotation3d (point3D, droite3D, angle, color) {\n  const directeur = droite3D.directeur\n  const origine = droite3D.origine\n  const p = []\n  if (point3D.constructor == Point3d) {\n    const V = vecteur3d(origine, point3d(0, 0, 0))\n    const W = vecteur3d(point3d(0, 0, 0), origine)\n    const M = translation3d(point3D, V)\n    const N = rotationV3d(M, directeur, angle)\n    return translation3d(N, W)\n  } else if (point3D.constructor == Vecteur3d) {\n    return rotationV3d(point3D, directeur, angle)\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(rotation3d(point3D.listePoints[i], droite3D, angle))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n\nfunction SensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  ObjetMathalea2D.call(this)\n  this.epaisseur = epaisseur\n  this.color = color\n  let M; let N; let s; const objets = []; let d; let A; let B\n  M = translation3d(axe.origine, rayon)\n  for (let i = 0; i < angle; i += 5) {\n    N = rotation3d(M, axe, 5)\n    s = segment(M.p2d, N.p2d)\n    s.color = this.color\n    s.epaisseur = this.epaisseur\n    objets.push(s)\n    M = N\n  }\n  N = rotation3d(M, axe, 5)\n  s = segment(M.p2d, N.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  d = droite3d(N, axe.directeur)\n  A = rotation3d(M, d, 30)\n  B = rotation3d(M, d, -30)\n  s = segment(N.p2d, A.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  s = segment(N.p2d, B.p2d)\n  s.color = this.color\n  s.epaisseur = this.epaisseur\n  objets.push(s)\n  this.svg = function (coeff) {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n  this.tikz = function () {\n    let code = ''\n    for (const objet of objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\nexport function sensDeRotation3d (axe, rayon, angle, epaisseur, color) {\n  return new SensDeRotation3d(axe, rayon, angle, epaisseur, color)\n}\n\n/**\n   * LA TRANSLATION\n   *\n   * @Auteur Jean-Claude Lhote\n   * @param {Point3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n   * @param {Vecteur3d} vecteur3D\n   */\nexport function translation3d (point3D, vecteur3D) {\n  if (point3D.constructor == Point3d) {\n    const x = point3D.x3d + vecteur3D.x3d\n    const y = point3D.y3d + vecteur3D.y3d\n    const z = point3D.z3d + vecteur3D.z3d\n    return point3d(x, y, z)\n  } else if (point3D.constructor == Polygone3d) {\n    const p = []\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(translation3d(point3D.listePoints[i], vecteur3D))\n    }\n    return polygone3d(p, point3D.color)\n  }\n}\nexport function homothetie3d (point3D, centre, rapport, color) {\n  let V\n  const p = []\n  if (point3D.constructor == Point3d) {\n    V = vecteur3d(centre, point3D)\n    V.x3d *= rapport\n    V.y3d *= rapport\n    V.y3d *= rapport\n    return translation3d(centre, V)\n  } else if (point3D.constructor == Vecteur3d) {\n    V = point3D\n    V.x3d *= rapport\n    V.y3d *= rapport\n    V.y3d *= rapport\n    return V\n  } else if (point3D.constructor == Polygone3d) {\n    for (let i = 0; i < point3D.listePoints.length; i++) {\n      p.push(homothetie3d(point3D.listePoints[i], centre, rapport, color))\n    }\n    if (typeof (color) !== 'undefined') {\n      return polygone3d(p, color)\n    } else { return polygone3d(p, point3D.color) }\n  }\n}\n"],"sourceRoot":""}