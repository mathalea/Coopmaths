/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmathalea"] = self["webpackChunkmathalea"] || []).push([["src_js_exercices_6e_6Algo11_js"],{

/***/ "./src/js/exercices/6e/6Algo11.js":
/*!****************************************!*\
  !*** ./src/js/exercices/6e/6Algo11.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"titre\": () => (/* binding */ titre),\n/* harmony export */   \"default\": () => (/* binding */ Note_la_couleur)\n/* harmony export */ });\n/* harmony import */ var _ClasseExercice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ClasseExercice.js */ \"./src/js/exercices/ClasseExercice.js\");\n/* harmony import */ var _modules_outils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../modules/outils.js */ \"./src/js/modules/outils.js\");\n/* harmony import */ var _modules_2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../modules/2d.js */ \"./src/js/modules/2d.js\");\n/* eslint-disable camelcase */\n/* globals mathalea */\n\n\n\nconst titre = 'Note la couleur'\n\n/**\n * Note_la_couleur() Exercice inspiré de l'activité débranchée de Jean-Yves Labouche Note La Couleur\n * https://www.monclasseurdemaths.fr/profs/algorithmique-scratch/note-la-couleur/\n * Ref : 6Algo11\n * Publié le 11/04/2021\n * @Auteur Jean-Claude Lhote\n * A faire : ajouter d'autres niveaux avec des boucles, des instructions conditionnelles, des blocs définis...\n * Ajouter un pion et la correction animée.\n */\n\n/**\n * Classe NoteLaCouleur (objet Pion)\n * this.plateau est le tableau des couleurs de cases.\n * this.currentPos est {x,y} les coordonnées courantes du pion\n * this.currentOrientation est l'orientation courante du pion\n * this.codeScratch est le programme en code Latex du pion.\n * this.currentIndex est l'index qui parcourt le codeScratch...\n * this.nlc() retourne la couleur de la case sur laquelle est le pion\n * this.tesCoords(x,y) est une méthode qui dit si le point de coordonnées (x,y) est bien dans le plateau de jeu.\n * this.testInstruction(code) est une méthode qui dit si une instruction est valide (ne sort pas) et retourne un tableau\n * this.testSequence([...code]) est une méthode qui retourne true si la séquence d'instructions est valide.\n */\nclass NoteLaCouleur {\n  constructor (x = 15, y = 15, orientation = 90) {\n    this.plateau = [['Noir', 'Jaune', 'Bleu', 'Vert', 'Orange', 'Rouge', 'Orange', 'Noir', 'Jaune', 'Gris', 'Vert', 'Rose', 'Noir', 'Jaune'],\n      ['Rouge', 'Bleu', 'Orange', 'Jaune', 'Rose', 'Gris', 'Jaune', 'Rose', 'Gris', 'Jaune', 'Bleu', 'Rouge', 'Gris', 'Rouge'],\n      ['Rose', 'Vert', 'Gris', 'Rouge', 'Noir', 'Bleu', 'Vert', 'Noir', 'Vert', 'Bleu', 'Rose', 'Gris', 'Vert', 'Orange'],\n      ['Vert', 'Bleu', 'Rose', 'Vert', 'Bleu', 'Orange', 'Gris', 'Rouge', 'Orange', 'Jaune', 'Gris', 'Rouge', 'Rose', 'Bleu'],\n      ['Noir', 'Orange', 'Rouge', 'Orange', 'Jaune', 'Rouge', 'Blanc', 'Blanc', 'Noir', 'Gris', 'Orange', 'Noir', 'Jaune', 'Rose'],\n      ['Rose', 'Gris', 'Noir', 'Bleu', 'Vert', 'Bleu', 'Blanc', 'Blanc', 'Rouge', 'Bleu', 'Gris', 'Vert', 'Rouge', 'Noir'],\n      ['Noir', 'Rouge', 'Rose', 'Vert', 'Orange', 'Rose', 'Noir', 'Orange', 'Vert', 'Jaune', 'Rose', 'Noir', 'Rose', 'Vert'],\n      ['Orange', 'Gris', 'Rouge', 'Jaune', 'Noir', 'Vert', 'Rouge', 'Rose', 'Noir', 'Bleu', 'Vert', 'Jaune', 'Orange', 'Gris'],\n      ['Bleu', 'Jaune', 'Orange', 'Vert', 'Gris', 'Jaune', 'Gris', 'Orange', 'Gris', 'Rose', 'Bleu', 'Rouge', 'Bleu', 'Orange'],\n      ['Rose', 'Bleu', 'Jaune', 'Rose', 'Orange', 'Rouge', 'Bleu', 'Noir', 'Jaune', 'Gris', 'Vert', 'Jaune', 'Noir', 'Rouge']]\n    this.currentPos = { x: x, y: y }\n    this.currentOrientation = orientation\n    this.codeScratch = ''\n    this.currentIndex = 0\n    this.nlc = function () {\n      return this.plateau[Math.ceil((135 - this.currentPos.y) / 30)][Math.ceil((195 + this.currentPos.x) / 30)]\n    }\n    this.testCoords = function (x, y) {\n      if ((x < -195) || (x > 195) || (y < -135) || (y > 135)) return false\n      return true\n    }\n    /**\n       * méthode pour tester une instruction : retourne un tableau dont le premier élément indique si l'instruction est valide.\n       * c'est à dire qu'elle n'entraine pas une sortie de plateau.\n       * true -> l'instruction maintient le lutin sur le plateau\n       * false -> l'instruction le fait sortir du plateau\n       * Les autres éléments du tableau sont dans cet ordre :\n       * - les positions x et y du pion après l'instruction\n       * - son orientation après l'instruction\n       * - le code Latex de l'instruction\n       */\n    this.testInstruction = function (code, lutin) {\n      const avancepion = function (d, x, y, s) {\n        switch (s) {\n          case 0:\n          case 360:\n            y += d\n            break\n          case 90:\n          case -270:\n            x += d\n            break\n          case 180:\n          case -180:\n            y -= d\n            break\n          case 270:\n          case -90:\n            x -= d\n            break\n        }\n        return [x, y]\n      }\n      let x = this.currentPos.x\n      let y = this.currentPos.y\n      let orientation = this.currentOrientation\n      let latex\n      switch (code) {\n        case 'AV30':\n          [x, y] = avancepion(30, x, y, orientation)\n          latex = '\\\\blockmove{avancer de \\\\ovalnum{30} pas}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.avance)(30, lutin)\n          }\n          break\n        case 'AV60':\n          [x, y] = avancepion(60, x, y, orientation)\n          latex = '\\\\blockmove{avancer de \\\\ovalnum{60} pas}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.avance)(60, lutin)\n          }\n          break\n        case 'AV90':\n          [x, y] = avancepion(90, x, y, orientation)\n          latex = '\\\\blockmove{avancer de \\\\ovalnum{90} pas}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.avance)(90, lutin)\n          }\n          break\n        case 'AV120':\n          [x, y] = avancepion(120, x, y, orientation)\n          latex = '\\\\blockmove{avancer de \\\\ovalnum{120} pas}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.avance)(120, lutin)\n          }\n          break\n\n        case 'TD90':\n          if (orientation === 180) orientation = -90\n          else orientation += 90\n          latex = '\\\\blockmove{tourner \\\\turnright{} de \\\\ovalnum{90} degrés}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.tournerD)(90, lutin)\n          }\n          break\n        case 'TG90':\n          if (orientation === -90) orientation = 180\n          else orientation -= 90\n          latex = '\\\\blockmove{tourner \\\\turnleft{} de \\\\ovalnum{90} degrés}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.tournerG)(90, lutin)\n          }\n          break\n        case 'TD180':\n        case 'TG180':\n          if (orientation === 0) orientation = 180\n          else if (orientation === -90) orientation = 90\n          else if (orientation === 90) orientation = -90\n          else orientation = 0\n          latex = '\\\\blockmove{tourner \\\\turnright{} de \\\\ovalnum{180} degrés}'\n          if (lutin !== undefined) {\n            (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.tournerD)(180, lutin)\n          }\n          break\n        case 'NLC':\n          latex = '\\\\blocklist{Note la couleur}'\n          break\n      }\n      if (this.testCoords(x, y)) {\n        return [true, x, y, orientation, latex, lutin]\n      } else return [false, this.currentPos.x, this.currentPos.y, this.currentOrientation, latex, lutin]\n    }\n\n    /**\n        * méthode pour tester une séquence : retourne\n        *\n        * [true,x,y,orientation] si la séquence reste dans le jeu\n        * [false,x,y,orientation] en cas de sortie de plateau.\n        */\n    this.testSequence = function (codes) {\n      let sorti = false\n      let test\n      const pionfantome = new NoteLaCouleur()\n      pionfantome.currentPos.x = this.currentPos.x\n      pionfantome.currentPos.y = this.currentPos.y\n      pionfantome.currentOrientation = this.currentOrientation\n      for (let i = 0; i < codes.length; i++) {\n        test = pionfantome.testInstruction(codes[i])\n        if (!test[0]) { // si le lutin est sorti du plateau pendant l'instruction\n          sorti = true\n          break\n        } else {\n          pionfantome.currentPos.x = test[1]\n          pionfantome.currentPos.y = test[2]\n          pionfantome.currentOrientation = test[3]\n        }\n      }\n      // si il est sorti, alors la séquence est false, sinon, elle est true.\n      return [!sorti, pionfantome.currentPos.x, pionfantome.currentPos.y, pionfantome.currentOrientation]\n    }\n    /**\n     *\n     * @param {number} repetitions\n     * @param {la séquence d'instructions à répéter} codes\n     * @returns true si la boucle n'a à aucun moment fait sortir le lutin du plateau, false sinon\n     */\n    this.testBoucle = function (repetitions, codes) {\n      let sortiboucle = false\n      let test\n      const pionfantome = new NoteLaCouleur()\n      pionfantome.currentPos.x = this.currentPos.x\n      pionfantome.currentPos.y = this.currentPos.y\n      pionfantome.currentOrientation = this.currentOrientation\n      for (let i = 0; i < repetitions; i++) {\n        test = pionfantome.testSequence(codes)\n        if (!test[0]) { // si le lutin est sorti pendant la séquence alors la boucle n'est pas valide.\n          sortiboucle = true\n          break\n        } else { // il n'est pas sorti, on continue le test à partir de la nouvelle position\n          pionfantome.currentPos.x = test[1]\n          pionfantome.currentPos.y = test[2]\n          pionfantome.currentOrientation = test[3]\n        }\n      }\n      // Si il est sorti, alors on retourne false en premier argument, sinon, on retourne true.\n      return [!sortiboucle, pionfantome.currentPos.x, pionfantome.currentPos.y, pionfantome.currentOrientation]\n    }\n  }\n}\n/**\n * Fonction exercice.\n */\nfunction Note_la_couleur () {\n  'use strict'\n  _ClasseExercice_js__WEBPACK_IMPORTED_MODULE_0__.default.call(this)\n  this.titre = titre\n  this.nb_questions = 1\n  this.nb_questions_modifiable = true\n  this.nb_cols = 1\n  this.nb_cols_corr = 1\n  this.pas_de_version_LaTeX = false\n  this.pas_de_version_HMTL = false\n  this.type_exercice = 'Scratch'\n  this.liste_packages = 'scratch3'\n  this.sup = true\n  this.sup2 = 1\n  this.sup3 = 4\n\n  this.nouvelle_version = function (numero_de_l_exercice) {\n    this.liste_questions = []\n    this.liste_corrections = []\n    let j, test\n    let objets_enonce, objets_correction\n    const params_correction = { xmin: -22.5, ymin: -17.25, xmax: 22.5, ymax: 17.25, pixelsParCm: 20, scale: 1 }\n\n    let commandes_disponibles; const sequences_disponibles = []; let sequence; let result; let nb_couleurs; let instruction; let couleurs; let liste_instructions\n\n    let lutin, lutindepart\n    let angledepart\n    let xdepart\n    let ydepart\n    mathalea.unitesLutinParCm = 20 * 30 / 52\n    mathalea.pixelsParCm = 20\n    let pion\n    if (this.sup) {\n      objets_correction = [(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.fond_ecran)('assets/images/nlc_an.png', -450, -345, 900, 690)]\n      objets_enonce = [(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.fond_ecran)('assets/images/nlc_an.png', -450, -345, 900, 690)]\n    } else {\n      objets_correction = [(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.fond_ecran)('assets/images/nlc_sn.png', -450, -345, 900, 690)]\n      objets_enonce = [(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.fond_ecran)('assets/images/nlc_sn.png', -450, -345, 900, 690)]\n    }\n    let texte = ''\n    let texte_corr = ''\n    let compteur = 0\n    let retour_a_la_case_depart\n    let compteur_essais_boucle\n    let compteur_essais_sequence\n    switch (parseInt(this.sup2)) {\n      case 1: {\n        commandes_disponibles = [['AV30', 'AV30', 'AV60', 'AV60', 'AV90', 'AV120'], ['TD90', 'TD90', 'TG90', 'TG90', 'TD90', 'TG90', 'TG180']]\n        for (let m = 0, ins1; m < 6; m++) {\n          for (let n = 0, ins2; n < 7; n++) {\n            ins1 = commandes_disponibles[0][m]\n            ins2 = commandes_disponibles[1][n]\n            sequences_disponibles.push([ins1, ins2, 'NLC'], [ins2, ins1, 'NLC'])\n          }\n        }\n        retour_a_la_case_depart = true\n        while (retour_a_la_case_depart) {\n          objets_enonce.length = 1\n          lutin = (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.creerLutin)()\n          angledepart = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)([90, 0, -90, 180])\n          xdepart = -195 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(4, 9) * 30\n          ydepart = -135 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(3, 6) * 30\n          pion = new NoteLaCouleur(xdepart, ydepart, angledepart)\n          lutin.color = 'green'\n          lutin.epaisseur = 3\n          lutin.pointilles = 2\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.allerA)(xdepart, ydepart, lutin)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.orienter)((0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.angleScratchTo2d)(angledepart), lutin)\n          lutindepart = (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.clone)(lutin)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.baisseCrayon)(lutindepart)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.allerA)(xdepart, ydepart, lutindepart)\n          objets_enonce.push(lutindepart)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.baisseCrayon)(lutin)\n          compteur++\n          if (compteur > 5) break\n          pion.codeScratch = ''\n          couleurs = []\n          nb_couleurs = parseInt(this.sup3)\n          liste_instructions = []\n          j = 0\n          compteur_essais_sequence = 0\n          pion.codeScratch = '\\\\begin{scratch}[print,fill,blocks]\\n \\\\blockinit{quand \\\\greenflag est cliqué}\\n '\n          pion.codeScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${xdepart}} y: \\\\ovalnum{${ydepart}}}\\n \\\\blockmove{s'orienter à \\\\ovalnum{${angledepart}}}\\n`\n          pion.currentIndex += pion.codeScratch.length\n          while (nb_couleurs > j && compteur_essais_sequence < 10) {\n            compteur_essais_sequence = 0\n            sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n            test = pion.testSequence(sequence)\n            while (!test[0] && compteur_essais_sequence < 10) {\n              compteur_essais_sequence++\n              sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n              test = pion.testSequence(sequence)\n            }\n            if (compteur_essais_sequence < 10) {\n              retour_a_la_case_depart = false\n              for (let i = 0; i < sequence.length; i++) {\n                instruction = sequence[i]\n                result = pion.testInstruction(instruction, lutin)\n                if (instruction === 'NLC') {\n                  liste_instructions.push(instruction)\n                  couleurs.push(pion.nlc())\n                  j++\n                  pion.codeScratch += result[4] + '\\n'\n                  pion.currentIndex += result[4].length + 1\n                  lutin = result[5]\n                  ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.attendre)(5, lutin)\n                } else {\n                  liste_instructions.push(instruction)\n                  pion.currentPos.x = result[1]\n                  pion.currentPos.y = result[2]\n                  pion.currentOrientation = result[3]\n                  pion.codeScratch += result[4] + '\\n'\n                  pion.currentIndex += result[4].length + 1\n                  lutin = result[5]\n                }\n              }\n            } else {\n              angledepart = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)([90, 0, -90, 180])\n              xdepart = -195 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(4, 9) * 30\n              ydepart = -135 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(3, 6) * 30\n            }\n          }\n        }\n\n        break\n      }\n      case 2: { // programmes à boucles\n        commandes_disponibles = [['AV30', 'AV60', 'AV90'], ['TD90', 'TG90', 'TD90', 'TG180']]\n        for (let m = 0, ins1; m < 3; m++) {\n          for (let n = 0, ins2; n < 4; n++) {\n            for (let p = 0, ins3; p < 3; p++) {\n              for (let q = 0, ins4; q < 4; q++) {\n                ins1 = commandes_disponibles[0][m]\n                ins2 = commandes_disponibles[1][n]\n                ins3 = commandes_disponibles[0][p]\n                ins4 = commandes_disponibles[1][q]\n                sequences_disponibles.push([ins1, ins2, 'NLC', ins3, ins4], [ins2, ins1, 'NLC', ins3, ins4], [ins1, ins2, 'NLC', ins4, ins3], [ins2, ins1, 'NLC', ins4, ins3],\n                  [ins1, ins2, ins3, 'NLC', ins4], [ins2, ins1, ins4, ins3, 'NLC'], [ins1, 'NLC', ins2, ins3, ins4], [ins2, 'NLC', ins1, ins4, ins3])\n              }\n            }\n          }\n        }\n\n        retour_a_la_case_depart = true\n        couleurs = []\n        nb_couleurs = parseInt(this.sup3)\n        liste_instructions = []\n        const repetitions = nb_couleurs - 1\n        while (retour_a_la_case_depart) {\n          objets_enonce.length = 1\n          lutin = (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.creerLutin)()\n          angledepart = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)([90, 0, -90, 180])\n          xdepart = -195 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(4, 9) * 30\n          ydepart = -135 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(3, 6) * 30\n          pion = new NoteLaCouleur(xdepart, ydepart, angledepart)\n          pion.codeScratch = ''\n          lutin.color = 'green'\n          lutin.epaisseur = 3\n          lutin.pointilles = 2\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.allerA)(xdepart, ydepart, lutin)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.orienter)((0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.angleScratchTo2d)(angledepart), lutin)\n          lutindepart = (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.clone)(lutin)\n          objets_enonce.push(lutindepart)\n          ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.baisseCrayon)(lutin)\n          compteur++\n          if (compteur > 5) break // 5 tentatives infructueuses -> On sort de la boucle.\n          compteur_essais_boucle = 0\n          pion.codeScratch = '\\\\begin{scratch}[print,fill,blocks]\\n \\\\blockinit{quand \\\\greenflag est cliqué}\\n '\n          pion.codeScratch += `\\\\blockmove{aller à x: \\\\ovalnum{${xdepart}} y: \\\\ovalnum{${ydepart}}}\\n \\\\blockmove{s'orienter à \\\\ovalnum{${angledepart}}}\\n`\n          pion.currentIndex += pion.codeScratch.length\n          // On choisit le code à l'intérieur de la boucle\n          sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n          test = pion.testBoucle(repetitions, sequence)\n          while (!test[0] && compteur_essais_boucle < 5) { // On tente 5 boucles à cette position, après on change de position.\n            compteur_essais_boucle++\n            sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n            test = pion.testBoucle(repetitions, sequence)\n          }\n          if (compteur_essais_boucle < 5) {\n            retour_a_la_case_depart = false\n            pion.codeScratch += `\\\\blockrepeat{répéter \\\\ovalnum{${repetitions}} fois}{\\n`\n            liste_instructions.push('début de boucle')\n            for (let i = 0; i < sequence.length; i++) {\n              instruction = sequence[i]\n              result = pion.testInstruction(instruction, lutin)\n              if (instruction === 'NLC') {\n                liste_instructions.push(instruction)\n                couleurs.push(pion.nlc())\n                pion.codeScratch += result[4] + '\\n'\n                pion.currentIndex += result[4].length + 1\n                lutin = result[5]\n                ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.attendre)(5, lutin)\n              } else {\n                liste_instructions.push(instruction)\n                pion.currentPos.x = result[1]\n                pion.currentPos.y = result[2]\n                pion.currentOrientation = result[3]\n                pion.codeScratch += result[4] + '\\n'\n                pion.currentIndex += result[4].length + 1\n                lutin = result[5]\n              }\n            }\n            liste_instructions.push('fin de boucle')\n            pion.codeScratch += '} \\n'\n            // on recommence n-1 fois pour faire avancer le pion et le lutin\n            for (let j = 1; j < repetitions; j++) {\n              for (let i = 0; i < sequence.length; i++) {\n                instruction = sequence[i]\n                result = pion.testInstruction(instruction, lutin)\n                if (instruction === 'NLC') {\n                  couleurs.push(pion.nlc())\n                  lutin = result[5]\n                  ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.attendre)(5, lutin)\n                } else {\n                  pion.currentPos.x = result[1]\n                  pion.currentPos.y = result[2]\n                  pion.currentOrientation = result[3]\n                  lutin = result[5]\n                }\n              }\n            }\n            sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n            test = pion.testSequence(sequence)\n            while (!test[0]) {\n              sequence = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)(sequences_disponibles)\n              test = pion.testSequence(sequence)\n            }\n            for (let i = 0; i < sequence.length; i++) {\n              instruction = sequence[i]\n              result = pion.testInstruction(instruction, lutin)\n              if (instruction === 'NLC') {\n                liste_instructions.push(instruction)\n\n                couleurs.push(pion.nlc())\n                pion.codeScratch += result[4] + '\\n'\n                pion.currentIndex += result[4].length + 1\n                lutin = result[5]\n                ;(0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.attendre)(5, lutin)\n              } else {\n                liste_instructions.push(instruction)\n                pion.currentPos.x = result[1]\n                pion.currentPos.y = result[2]\n                pion.currentOrientation = result[3]\n                pion.codeScratch += result[4] + '\\n'\n                pion.currentIndex += result[4].length + 1\n                lutin = result[5]\n              }\n            }\n          } else {\n            angledepart = (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.choice)([90, 0, -90, 180])\n            xdepart = -195 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(4, 9) * 30\n            ydepart = -135 + (0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(3, 6) * 30\n          }\n        }\n        break\n      }\n      case 3:\n\n        break\n\n      case 4:\n\n        break\n    }\n    //  objets_enonce.push ();\n    // objets_correction.push();\n\n    //      params_enonce = { xmin:-10, ymin: -10, xmax: 10, ymax: 10, pixelsParCm: 20, scale: 1, mainlevee: false};\n    //    texte += mathalea2d(params_enonce, objets_enonce);\n    //  texte_corr += mathalea2d(params_correction, objets_correction);\n    pion.codeScratch += '\\\\end{scratch}'\n    texte = `Cet exercice est tiré de l'excellente activité débranchée ${(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.modal_url)(numero_de_l_exercice, 'https://www.monclasseurdemaths.fr/profs/algorithmique-scratch/note-la-couleur/', 'Note la couleur', 'info circle')} de Jean-Yves Labouche.<br>`\n    texte += 'Il a été conçu pour étendre les possibilités de fiches proposées.<br>'\n    texte += `N'hésitez pas à vous rendre sur le site ${(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.modal_url)(numero_de_l_exercice + 1, 'https://www.monclasseurdemaths.fr', 'Mon classeur de Maths.fr', 'info circle')} de Jean-Yves pour y découvrir la multitude de ressources qu'il propose.<br>`\n    texte += `Pour jouer, regarder les règles du jeu${(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.modal_pdf)(numero_de_l_exercice + 2, '../../pdf/reglesnlc.pdf', 'Règles du jeu', 'Règles - PDF', 'file pdf')} .<br>`\n    texte += 'Exécuter le programme et trouver la succession de couleur.<br>'\n    texte += '<table><tr><td>' +\n      (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.scratchblock)(pion.codeScratch) +\n      '</td><td>' +\n      (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.mathalea2d)(params_correction, objets_enonce) +\n      '</td></tr></table>'\n    texte_corr = 'On obtient la série de couleurs suivante :<br> '\n    texte_corr += `${(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.texte_gras)(couleurs[0])} `\n    for (let i = 1; i < couleurs.length; i++) {\n      texte_corr += `- ${(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.texte_gras)(couleurs[i])} `\n    }\n    texte_corr += '<br><br>' + (0,_modules_2d_js__WEBPACK_IMPORTED_MODULE_2__.mathalea2d)(params_correction, objets_correction, lutin)\n    this.liste_questions.push(texte)\n    this.liste_corrections.push(texte_corr)\n    ;(0,_modules_outils_js__WEBPACK_IMPORTED_MODULE_1__.liste_de_question_to_contenu_sans_numero)(this)\n  }\n  this.besoin_formulaire_case_a_cocher = ['Plateau avec numéros', true]\n  this.besoin_formulaire2_numerique = ['Type de programme', 2, '1 : Avancer et tourner\\n2 : Boucles']\n  this.besoin_formulaire3_numerique = ['Nombre de couleurs (Maximmum 6)', 6]\n}\n\n\n//# sourceURL=webpack://mathalea/./src/js/exercices/6e/6Algo11.js?");

/***/ }),

/***/ "./src/js/exercices/ClasseExercice.js":
/*!********************************************!*\
  !*** ./src/js/exercices/ClasseExercice.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Exercice)\n/* harmony export */ });\n/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nfunction Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = '';\n  this.consigne = '';\n  this.consigne_correction = '';\n  this.liste_questions = []\n  this.liste_corrections = []\n  this.introduction = '';\n  this.contenu = '';\n  this.contenu_correction = '';\n  this.nb_questions = 10\n  this.nb_cols = 2\n  this.nb_cols_corr = 2\n  this.spacing = 1\n  this.spacing_corr = 1\n  this.beamer = false\n\n  this.besoin_formulaire_numerique = false // Sinon this.besoin_formulaire_numerique = [texte,max,tooltip facultatif];\n  this.besoin_formulaire_texte = false // Sinon this.besoin_formulaire_texte = [texte,tooltip];\n  this.besoin_formulaire_case_a_cocher = false // Sinon this.besoin_formulaire_case_a_cocher = [texte];\n  this.consigne_modifiable = true\n  this.nb_questions_modifiable = true\n  this.nb_cols_modifiable = true\n  this.nb_cols_corr_modifiable = true\n  this.spacing_modifiable = true\n  this.spacing_corr_modifiable = true\n  this.correction_detaillee_disponible = false\n  this.correction_detaillee = true\n  this.video = ''\n  this.bouton_aide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.bouton_aide = modal_texte_court(numero_de_l_exercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.bouton_aide = modal_texte_long(numero_de_l_exercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.bouton_aide = modal_youtube(numero_de_l_exercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.bouton_aide = modal_pdf(numero_de_l_exercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pas_de_version_LaTeX = false\n  this.QCM = false // Pour les exercices de type QCM : contient un tableau.\n  this.QCM_disponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.ModeQCM\n  this.ModeQCM = false // Pour choisir la version QCM ou la version classique (false = version classique)\n\n  this.MG32editable = false //pas d'interface par défaut pour les figures MG32\n  this.nouvelle_version = function (numero_de_l_exercice) {}\n  this.liste_packages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  //this.type_exercice = \"MG32\";\n  //this.taille_div_MG32 = [500, 450];\n  //this.type_exercice = \"Scratch\"\n  // this.QCM=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n\n\n//# sourceURL=webpack://mathalea/./src/js/exercices/ClasseExercice.js?");

/***/ })

}]);