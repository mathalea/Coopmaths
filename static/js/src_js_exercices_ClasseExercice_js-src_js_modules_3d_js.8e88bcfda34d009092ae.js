/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmathalea"] = self["webpackChunkmathalea"] || []).push([["src_js_exercices_ClasseExercice_js-src_js_modules_3d_js"],{

/***/ "./src/js/exercices/ClasseExercice.js":
/*!********************************************!*\
  !*** ./src/js/exercices/ClasseExercice.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Exercice)\n/* harmony export */ });\n/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nfunction Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = '';\n  this.consigne = '';\n  this.consigne_correction = '';\n  this.liste_questions = []\n  this.liste_corrections = []\n  this.introduction = '';\n  this.contenu = '';\n  this.contenu_correction = '';\n  this.nb_questions = 10\n  this.nb_cols = 2\n  this.nb_cols_corr = 2\n  this.spacing = 1\n  this.spacing_corr = 1\n  this.beamer = false\n\n  this.besoin_formulaire_numerique = false // Sinon this.besoin_formulaire_numerique = [texte,max,tooltip facultatif];\n  this.besoin_formulaire_texte = false // Sinon this.besoin_formulaire_texte = [texte,tooltip];\n  this.besoin_formulaire_case_a_cocher = false // Sinon this.besoin_formulaire_case_a_cocher = [texte];\n  this.consigne_modifiable = true\n  this.nb_questions_modifiable = true\n  this.nb_cols_modifiable = true\n  this.nb_cols_corr_modifiable = true\n  this.spacing_modifiable = true\n  this.spacing_corr_modifiable = true\n  this.correction_detaillee_disponible = false\n  this.correction_detaillee = true\n  this.video = ''\n  this.bouton_aide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.bouton_aide = modal_texte_court(numero_de_l_exercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.bouton_aide = modal_texte_long(numero_de_l_exercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.bouton_aide = modal_youtube(numero_de_l_exercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.bouton_aide = modal_pdf(numero_de_l_exercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pas_de_version_LaTeX = false\n  this.QCM = false // Pour les exercices de type QCM : contient un tableau.\n  this.QCM_disponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.ModeQCM\n  this.ModeQCM = false // Pour choisir la version QCM ou la version classique (false = version classique)\n\n  this.MG32editable = false //pas d'interface par défaut pour les figures MG32\n  this.nouvelle_version = function (numero_de_l_exercice) {}\n  this.liste_packages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  //this.type_exercice = \"MG32\";\n  //this.taille_div_MG32 = [500, 450];\n  //this.type_exercice = \"Scratch\"\n  // this.QCM=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n\n\n//# sourceURL=webpack://mathalea/./src/js/exercices/ClasseExercice.js?");

/***/ }),

/***/ "./src/js/modules/3d.js":
/*!******************************!*\
  !*** ./src/js/modules/3d.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"point3d\": () => (/* binding */ point3d),\n/* harmony export */   \"vecteur3d\": () => (/* binding */ vecteur3d),\n/* harmony export */   \"arete3d\": () => (/* binding */ arete3d),\n/* harmony export */   \"droite3d\": () => (/* binding */ droite3d),\n/* harmony export */   \"demicercle3d\": () => (/* binding */ demicercle3d),\n/* harmony export */   \"cercle3d\": () => (/* binding */ cercle3d),\n/* harmony export */   \"polygone3d\": () => (/* binding */ polygone3d),\n/* harmony export */   \"sphere3d\": () => (/* binding */ sphere3d),\n/* harmony export */   \"cone3d\": () => (/* binding */ cone3d),\n/* harmony export */   \"cylindre3d\": () => (/* binding */ cylindre3d),\n/* harmony export */   \"prisme3d\": () => (/* binding */ prisme3d),\n/* harmony export */   \"cube3d\": () => (/* binding */ cube3d),\n/* harmony export */   \"cube\": () => (/* binding */ cube),\n/* harmony export */   \"pave3d\": () => (/* binding */ pave3d),\n/* harmony export */   \"rotationV3d\": () => (/* binding */ rotationV3d),\n/* harmony export */   \"rotation3d\": () => (/* binding */ rotation3d),\n/* harmony export */   \"sens_de_rotation3d\": () => (/* binding */ sens_de_rotation3d),\n/* harmony export */   \"translation3d\": () => (/* binding */ translation3d),\n/* harmony export */   \"homothetie3d\": () => (/* binding */ homothetie3d)\n/* harmony export */ });\n/* harmony import */ var _2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./2d.js */ \"./src/js/modules/2d.js\");\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJET PARENT %%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/*\n * Classe parente de tous les objets de MathALEA2D\n *\n * @Auteur Rémi Angot\n */\nlet numId = 0\nfunction ObjetMathalea2D() {\n    this.positionLabel = \"above\";\n    this.isVisible = true;\n    this.color = \"black\";\n    this.style = \"\"; //stroke-dasharray=\"4 3\" pour des hachures //stroke-width=\"2\" pour un trait plus épais\n    this.styleTikz = \"\";\n    this.epaisseur = 1;\n    this.opacite = 1;\n    this.pointilles = false;\n    this.id = numId;\n    numId++;\n  //   mesObjets.push(this);\n    mathalea.objets2D.push(this)\n  }\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE BASE %%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n/**\n * LE POINT\n * \n* @Auteur Jean-Claude Lhote\n* Point de l'espace défini par ses trois coordonnées (Si deux sont données seulement, le point est dans le plan XY)\n* le paramètre visible définit si ce point est placé devant (par défaut) ou derrière une surface. Il sera utilisé pour définir la visibilité des arêtes qui en partent\n*/\n  class Point3d {\n    constructor (x3d,y3d,z3d,visible,label) {\n      let alpha=mathalea.anglePerspective*Math.PI/180\n      let rapport=mathalea.coeffPerspective\n      let MT = math.matrix([[1,rapport*Math.cos(alpha),0], [0,rapport*Math.sin(alpha), 1]])\n      this.x3d=x3d\n      this.y3d=y3d\n      this.z3d=z3d\n      this.visible=visible\n      this.label=label\n      let V=math.matrix([this.x3d,this.y3d,this.z3d])\n      let W=math.multiply(MT,V)\n      this.p2d=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(W._data[0],W._data[1],this.label)\n    }\n  }\n  function point3d(x3d,y3d,z3d=0,visible=true,label=\"\"){\n    return new Point3d(x3d,y3d,z3d,visible,label)\n  }\n  \n\n  /**\n   * LE VECTEUR\n   * \n   * @Auteur Jean-Claude Lhote\n   * le vecteur3d est sans doute l'objet le plus important de cette base d'objets\n   * On les utilise dans tous les objets complexeimport Additionner_soustraires_decimaux from '../exercices/6e/6C20';\ns et dans toutes les transformations.import Nature_polygone from './../exercices/2e/2G12';\nimport Exercice_fractions_decomposer from './../exercices/6e/6N20';\n\n   * Ils servent notament à définir la direction des plans.\n   * \n   * 3 usages : vecteur3d(A,B) ou vecteur3d(x,y,z) ou vecteur3d(math.matrix([x,y,z]))\n   * A et B sont deux objets de type Point3d\n   * x,y et z sont trois nombres\n   * la commande math.matrix([x,y,z]) crée une matrice colonne.\n   * \n   * L'objet créé est de type Vecteur3d\n   * sa propriété p2d est un objet Vecteur (2 dimensions : c'est la projection du vecteur)\n   * sa propriété this.representant(A) est le dessin du représentant d'origine A.\n   */\n  class Vecteur3d{\n    constructor(...args){\n     let alpha=mathalea.anglePerspective*Math.PI/180\n     let rapport=mathalea.coeffPerspective\n     let MT = math.matrix([[1,rapport*Math.cos(alpha),0], [0,rapport*Math.sin(alpha), 1]])\n    if (args.length==2) {\n      this.x3d=args[1].x3d-args[0].x3d\n      this.y3d=args[1].y3d-args[0].y3d\n      this.z3d=args[1].z3d-args[0].z3d\n    }\n    else {\n      if (typeof(args[0])=='number') {\n      this.x3d=args[0]\n      this.y3d=args[1]\n      this.z3d=args[2]\n      }\n      else if (args.length==1){\n        this.x3d=args[0]._data[0]\n        this.y3d=args[0]._data[1]\n        this.z3d=args[0]._data[2]\n      }\n    }\n    this.matrice=math.matrix([this.x3d,this.y3d,this.z3d])\n    let W=math.multiply(MT,this.matrice)\n    this.p2d=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(W._data[0],W._data[1])\n    this.representant=function(A){\n      let B=translation3d(A,this)\n      return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A.p2d,B.p2d).representant(A.p2d)\n    }\n  }\n  }\n  \n  function vecteur3d (...args){ // A,B deux Point3d ou x,y,z les composantes du vecteur\n    return new Vecteur3d(...args)\n  }\n\n  /**\n   * L'ARETE\n   * @Auteur Jean-Claude lhote\n   * \n   * \n   * \n   */\nclass Arete3d{\n    constructor (point1,point2,color){\n        this.extremite1=point1\n        this.extremite2=point2\n        this.color=color\n        if (!point1.visible||!point2.visible) {\n            this.visible=false\n        }\n        else {\n            this.visible=true\n        }\n        this.p2d=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(point1.p2d,point2.p2d,color)\n        if (!this.visible) {\n            this.p2d.pointilles=2\n        }\n        else {\n            this.p2d.pointilles=false\n        }\n    }\n  }\nfunction arete3d(p1,p2,color='black'){\n    return new Arete3d(p1,p2,color)\n}\n\n  /**\n   * LA DROITE\n   * \n   * @Auteur Jean-claude Lhote\n   * Droite de l'espace définie par point et vecteur directeur droite3d(A,v)\n   * Droite de l'espace définie par 2 points droite3d(A,B)\n   * Les droites servent principalement à définir des axes de rotation dans l'espace\n   */\n  class Droite3d{\n    constructor (point3D,vecteur3D){\n      if (vecteur3D.constructor==Vecteur3d){\n        this.directeur=vecteur3D\n      }\n      else if (vecteur3D.constructor==Point3d){\n        this.directeur=vecteur3d(point3D,vecteur3D)\n      }\n      this.origine=point3D\n      let M=translation3d(this.origine,this.directeur)\n      this.point=M\n      this.p2d=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(this.origine.p2d,M.p2d) // la droite correspndant à la projection de cette droite dans le plan Mathalea2d\n     this.p2d.isVisible=false\n    }\n  }\n  \n  function droite3d(point3D,vecteur3D){\n    return new Droite3d(point3D,vecteur3D)\n  }\n  \n\n/**\n * LE DEMI-CERCLE\n * \n *@Auteur Jean-Claude Lhote\n * Le nom est trompeur, il s'agit le plus souvent d'une demi-ellipse représentant un cercle projeté\n * Utilisé pour représenter un cercle dont une moitié est visible mais pas l'autre.\n * \n * normal et rayon sont deux vecteurs 3d\n * normal est un vecteur normal au plan du cercle\n * rayon est le vecteur qui part du centre et qui joint la 1ere extremité visible.\n * cote est soit 'caché' soit 'visible' et déterminera dans quel sens on crée le demi-cercle.\n * Si cote='caché' alors on tourne dans le sens direct et le tracé est en pointillés\n * Si cote='visible' alors on tourne dans le sens indirect et le tracé est plein.\n *\n */\nfunction demicercle3d(centre,normal,rayon,cote,color,angledepart=mathalea.anglePerspective){\n\n    let demiCercle,signe,M=[],listepoints=[]\n    if (cote=='caché') {\n      signe=1\n    }\n    else {\n      signe=-1\n    }\n    let d=droite3d(centre,normal)\n    M.push(rotation3d(translation3d(centre,rayon),d,angledepart))\n    listepoints.push(M[0].p2d)\n  \n    for (let i=1;i<19;i++) {\n          M.push(rotation3d(M[i-1],d,10*signe))\n          listepoints.push(M[i].p2d)\n    }\n    demiCercle=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polyline)(listepoints,color)\n    if (cote=='caché') {\n      demiCercle.pointilles=2\n      demiCercle.opacite=0.3\n    }\n    return demiCercle\n   }\n\n\n   /**\n    * LE CERCLE\n    * \n    * @Auteur Jean-Claude Lhote\n    * \n    * C'est la version entière du cercle : soit totalement visible, soit totalement caché.\n    * visible est un booléen\n    * \n    */\n   function cercle3d(centre,normal,rayon,visible=true,color='black'){\n  \n    let C,M=[],listepoints=[]\n    let d=droite3d(centre,normal)\n    M.push(rotation3d(translation3d(centre,rayon),d,mathalea.anglePerspective))\n    listepoints.push(M[0].p2d)\n    for (let i=1;i<37;i++) {\n          M.push(rotation3d(M[i-1],d,10))\n          listepoints.push(M[i].p2d)\n    }\n    C=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)(listepoints,color)\n    if (!visible) {\n      C.pointilles=2\n    }\n    return C\n   }\n\n  /**\n   * LE POLYGONE\n   * \n   * @Auteur Jean-Claude Lhote\n   * usages : polygone3d([A,B,C,...],color) ou polygone3d(A,B,C...) où A,B,C ... sont des point3d. color='black' par défaut.\n   */\n  class Polygone3d{\n    constructor (...args){\n      if (Array.isArray(args[0])) {\n        //Si le premier argument est un tableau\n        this.listePoints = args[0];\n        if (args[1]) {\n          this.color = args[1];\n        }\n      } else {\n        this.listePoints = args;\n        this.color='black'\n      }\n      let segments3d=[],A,segments=[]\n      A=this.listePoints[0]\n      for (let i=1;i<this.listePoints.length;i++){\n        segments3d.push(arete3d(A,this.listePoints[i],this.color))\n        segments.push(segments3d[i-1].p2d)\n        A=this.listePoints[i]\n      }\n      segments3d.push(arete3d(A,this.listePoints[0],this.color))\n      segments.push(segments3d[this.listePoints.length-1].p2d)\n      this.aretes=segments3d\n      this.p2d=segments\n    }\n  }\n  \n  function polygone3d(...args){\n    return new Polygone3d(...args)\n  }\n  \n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS DE COMPLEXES %%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n  /**\n   * LA SPHERE\n   * \n   * @Auteur Jean-Claude Lhote\n   * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n   * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n   * @param {Point3d} centre \n   * @param {Number} rayon \n   * @param {Number} nb_paralleles \n   * @param {Number} nb_meridiens \n   * @param {string} color \n   */\n   function Sphere3d(centre,rayon,nb_paralleles,nb_meridiens,color){\n     ObjetMathalea2D.call(this)\n     this.centre=centre\n     this.rayon=vecteur3d(rayon,0,0)\n     this.normal=vecteur3d(0,0,1)\n     this.color=color\n     this.nb_meridiens=nb_meridiens\n     this.nb_paralleles=nb_paralleles\n     let objets=[],c1,c2,c3,c4,C,D\n     let prodvec=vecteur3d(math.cross(this.normal.matrice,this.rayon.matrice))\n     let cote1,cote2,rayon2,R\n     rayon2=vecteur3d(math.cross(this.rayon.matrice,math.multiply(prodvec.matrice,1/math.norm(prodvec.matrice))))\n     R=rayon\n     cote1='caché'\n     cote2='visible'\n    // objets.push(cercle3d(this.centre,rotationV3d(prodvec,this.normal,mathalea.anglePerspective),rotationV3d(this.rayon,this.normal,mathalea.anglePerspective),true,this.color))\n     for (let k=0,rayon3;k<1;k+=1/(this.nb_paralleles+1)){\n       C=point3d(centre.x3d,centre.y3d,centre.z3d+R*Math.sin(k*Math.PI/2))\n       D=point3d(centre.x3d,centre.y3d,centre.z3d+R*Math.sin(-k*Math.PI/2))\n       rayon3=vecteur3d(R*Math.cos(k*Math.PI/2),0,0)\n       c1=demicercle3d(C,this.normal,rayon3,cote1,this.color,mathalea.anglePerspective)\n       c2=demicercle3d(C,this.normal,rayon3,cote2,this.color,mathalea.anglePerspective)\n       c3=demicercle3d(D,this.normal,rayon3,cote1,this.color,mathalea.anglePerspective)\n       c4=demicercle3d(D,this.normal,rayon3,cote2,this.color,mathalea.anglePerspective)\n       objets.push(c1,c2,c3,c4)\n     }\n     for (let k=0,V,W;k<1;k+=1/this.nb_meridiens){\n       V=rotationV3d(prodvec,this.normal,90+mathalea.anglePerspective+k*90) \n       W=rotationV3d(prodvec,this.normal,90+mathalea.anglePerspective-(k+1/this.nb_meridiens)*90) \n      c1=demicercle3d(this.centre,V,rayon2,cote2,this.color,0)\n      c2=demicercle3d(this.centre,V,rayon2,cote1,this.color,0)\n      c3=demicercle3d(this.centre,W,rayon2,cote2,this.color,0)\n      c4=demicercle3d(this.centre,W,rayon2,cote1,this.color,0)\n      objets.push(c1,c2,c3,c4)\n    }\n    \n     this.svg =function (coeff) {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.svg(coeff);\n      }\n      return code;\n    }\n    this.tikz = function() {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.tikz();\n      }\n      return code;\n    }\n   }\n  function sphere3d(centre,rayon,nb_paralleles,nb_meridiens,color='black'){\n    return new Sphere3d(centre,rayon,nb_paralleles,nb_meridiens,color)\n  }\n\n\n   /**\n    * LE CONE\n    * \n    * @Auteur Jean-Claude Lhote\n    * \n    * centrebase est le centre du disque de base\n    * sommet est le sommet du cône\n    * normal est un vecteur 3d normal au plan du disque (il détermine avec rayon de quel côté se trouve la partie visible)\n    * \n    */\n  function Cone3d(centrebase,sommet,normal,rayon,generatrices=18){\n    ObjetMathalea2D.call(this)\n    this.sommet=sommet\n    this.centrebase=centrebase\n    this.normal=normal\n    this.rayon=rayon\n    let objets=[],c1,c2,s,color1,color2\n    let prodvec=vecteur3d(math.cross(normal.matrice,rayon.matrice))\n    let prodscal=math.dot(prodvec.matrice,vecteur3d(0,1,0).matrice)\n    let cote1,cote2\n    if (prodscal>0) {\n      cote1='caché'\n      color1='gray'\n      cote2='visible'\n      color2='black'\n    }\n    else {\n      cote2='caché'\n      cote1='visible'\n      color1='black'\n      color2='gray'\n    }\n    c1=demicercle3d(this.centrebase,this.normal,this.rayon,cote1,color1)\n    c2=demicercle3d(this.centrebase,this.normal,this.rayon,cote2,color2)\n  \n    for (let i=0;i<c1.listePoints.length;i++){\n      if (i%generatrices==0){\n        s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(this.sommet.p2d,c1.listePoints[i])\n      if (cote1=='caché'){\n        s.pointilles=2\n        s.color='gray'\n      }\n      else {\n        s.color='black'\n      }\n      objets.push(s)\n    }}\n    for (let i=0;i<c2.listePoints.length;i++){\n      if (i%generatrices==0){\n        s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(this.sommet.p2d,c2.listePoints[i])\n      if (cote2=='caché'){\n        s.pointilles=2\n        s.color='gray'\n      }\n      else {\n        s.color='black'\n      }\n      objets.push(s)\n    }}\n    objets.push(c1,c2)\n    this.svg =function (coeff) {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.svg(coeff);\n      }\n      return code;\n    }\n    this.tikz = function() {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.tikz();\n      }\n      return code;\n    }\n  }\n  function cone3d(centre,sommet,normal,rayon,generatrices=18){\n    return new Cone3d(centre,sommet,normal,rayon,generatrices)\n  }\n\n\n  /**\n   * LE CYLINDRE\n   * \n   * @Auteur Jean-Claude Lhote\n   * Crée un cylindre de révolution définit par les centres de ses 2 bases\n   * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes\n   * @param {Point3d} centrebase1 \n   * @param {Point3d} centrebase2 \n   * @param {Vecteur3d} normal \n   * @param {Vecteur3d} rayon1 \n   * @param {Vecteur3d} rayon2\n   */\n  function Cylindre3d(centrebase1,centrebase2,normal,rayon1,rayon2,color){\n    ObjetMathalea2D.call(this)\n    this.centrebase1=centrebase1\n    this.centrebase2=centrebase2\n    this.normal=normal\n    this.rayon1=rayon1\n    this.rayon2=rayon2\n    this.color=color\n    let objets=[],c1,c2,c3,c4,s,color1,color2\n    let prodvec=vecteur3d(math.cross(this.normal.matrice,this.rayon1.matrice))\n    let prodscal=math.dot(prodvec.matrice,vecteur3d(0,1,0).matrice)\n    let cote1,cote2\n    if (prodscal>0) {\n      cote1='caché'\n      color1=this.color\n      cote2='visible'\n      color2=this.color\n    }\n    else {\n      cote2='caché'\n      cote1='visible'\n      color1=this.color\n      color2=this.color\n    }\n    c1=demicercle3d(this.centrebase1,this.normal,this.rayon1,cote1,color1)\n    c3=demicercle3d(this.centrebase2,this.normal,this.rayon2,cote1,color1)\n    c2=demicercle3d(this.centrebase1,this.normal,this.rayon1,cote2,color2)\n    c4=demicercle3d(this.centrebase2,this.normal,this.rayon2,cote2,color2)\n    c3.pointilles=false\n    c3.color=this.color\n    for (let i=0;i<c1.listePoints.length;i+=2){\n      s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(c3.listePoints[i],c1.listePoints[i])\n      if (cote1=='caché'){\n        s.pointilles=2\n        s.color=this.color\n        s.opacite=0.3\n      }\n      else {\n        s.color=this.color\n      }\n      objets.push(s)\n    }\n    for (let i=0;i<c2.listePoints.length;i+=2){\n      s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(c4.listePoints[i],c2.listePoints[i])\n      if (cote2=='caché'){\n        s.pointilles=2\n        s.color=this.color\n        s.opacite=0.3\n      }\n      else {\n        s.color=this.color\n      }\n      objets.push(s)\n    }\n    objets.push(c1,c2,c3,c4)\n    this.svg =function (coeff) {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.svg(coeff);\n      }\n      return code;\n    }\n    this.tikz = function() {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.tikz();\n      }\n      return code;\n    }\n  }\n  function cylindre3d(centrebase1,centrebase2,normal,rayon,rayon2,color='black'){\n    return new Cylindre3d(centrebase1,centrebase2,normal,rayon,rayon2,color)\n  }\n  \n  /**\n   * LE PRISME\n   * \n   * @Auteur Jean-Claude Lhote\n   * Crée un prisme à partir du base Polygone3d et d'un vecteur3d d'extrusion (on peut faire des prismes droits ou non droits)\n   */\n  class Prisme3d{\n    constructor(base,vecteur,color){\n      ObjetMathalea2D.call(this)\n\n      this.color=color\n      base.color=color\n      this.base1=base\n      this.base2=translation3d(base,vecteur)\n      this.base2.color=this.base1.color\n      this.aretes=[]\n      let objets=[],s\n      for (let i=0;i<this.base1.listePoints.length;i++){\n      objets.push(this.base1.p2d[i])\n      }\n      for (let i=0;i<this.base2.listePoints.length;i++){\n        objets.push(this.base2.p2d[i])\n      }\n      for (let i=0;i<this.base1.listePoints.length;i++){\n        s=arete3d(this.base1.listePoints[i],this.base2.listePoints[i],this.color)\n        objets.push(s.p2d)\n      }\n\n      this.svg =function (coeff) {\n        let code = \"\";\n        for (let objet of objets) {\n          code += \"\\n\\t\" + objet.svg(coeff);\n        }\n        return code;\n      }\n      this.tikz = function() {\n        let code = \"\";\n        for (let objet of objets) {\n          code += \"\\n\\t\" + objet.tikz();\n        }\n        return code;\n      }\n    }\n  }\n\n  function prisme3d(base,vecteur,color='black'){\n    return new Prisme3d(base,vecteur,color)\n  }\n  \n/**\n   * LE cube\n   * @Auteur Jean-Claude Lhote\n   * usage : cube(x,y,z,c,color) construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z.\n   * le face avant est dans le plan xz\n   * \n*/\nclass Cube3d{\n    constructor (x,y,z,c,color='black'){\n      let faceAV,faceDr,faceTOP\n      let A=point3d(x,y,z)\n      let vx=vecteur3d(c,0,0)\n      let vy=vecteur3d(0,c,0)\n      let vz=vecteur3d(0,0,c)\n      let B=translation3d(A,vx)\n      let C=translation3d(B,vz)\n      let D=translation3d(A,vz)\n      let E=translation3d(A,vy)\n      let F=translation3d(E,vx)\n      let G=translation3d(F,vz)\n      let H=translation3d(D,vy)\n      faceAV=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([A.p2d,B.p2d,C.p2d,D.p2d],color)\n      faceDr=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([B.p2d,F.p2d,G.p2d,C.p2d],color)\n      faceTOP=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([D.p2d,C.p2d,G.p2d,H.p2d],color)\n      faceAV.couleurDeRemplissage=\"#A9A9A9\"\n      faceTOP.couleurDeRemplissage='white'\n      faceDr.couleurDeRemplissage=\"#A5C400\"\n      this.svg=function(coeff){\n        return faceAV.svg(coeff)+'\\n'+faceTOP.svg(coeff)+'\\n'+faceDr.svg(coeff)\n      }\n      this.tikz=function(){\n        return faceAV.tikz()+'\\n'+faceTOP.tikz()+'\\n'+faceDr.tikz()\n      }\n    }\n}\nfunction cube3d(x,y,z,c){\n  return new Cube3d(x,y,z,c)\n}\n\nclass Cube{\n  constructor (x,y,z,alpha,beta,colorD,colorT,colorG){\n    ObjetMathalea2D.call(this)\n    this.x=x\n    this.y=y\n    this.z=z\n    this.alpha=alpha\n    this.beta=beta\n    this.colorD=colorD\n    this.colorG=colorG\n    this.colorT=colorT\n\n    this.lstPoints = [];\n    this.lstPolygone = [];\n    function proj(x,y,z,alpha, beta) {\n      const cosa = Math.cos(alpha*Math.PI/180);\n      const sina = Math.sin(alpha*Math.PI/180);\n      const cosb = Math.cos(beta*Math.PI/180);\n      const sinb = Math.sin(beta*Math.PI/180);\n      return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(cosa*x-sina*y, -sina*sinb*x-cosa*sinb*y+cosb*z);\n    }\n      \n    this.lstPoints.push(proj(this.x,this.y,this.z,this.alpha, this.beta)) // point 0 en bas\n    this.lstPoints.push(proj(this.x+1,this.y,this.z,this.alpha, this.beta)) // point 1\n    this.lstPoints.push(proj(this.x+1,this.y,this.z+1,this.alpha, this.beta)) // point 2\n    this.lstPoints.push(proj(this.x,this.y,this.z+1,this.alpha, this.beta)) //point 3\n    this.lstPoints.push(proj(this.x+1,this.y+1,this.z+1,this.alpha, this.beta)) // point 4\n    this.lstPoints.push(proj(this.x,this.y+1,this.z+1,this.alpha, this.beta)) // point 5\n    this.lstPoints.push(proj(this.x,this.y+1,this.z,this.alpha, this.beta)) // point 6\n    let p\n    p=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[0], this.lstPoints[1],this.lstPoints[2], this.lstPoints[3]], \"black\")\n    p.opaciteDeRemplissage=1;\n    p.couleurDeRemplissage=this.colorD\n    this.lstPolygone.push(p)\n    p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[2], this.lstPoints[4],this.lstPoints[5], this.lstPoints[3]], \"black\")\n    p.couleurDeRemplissage=this.colorG\n    p.opaciteDeRemplissage=1;\n    this.lstPolygone.push(p)\n    p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygone)([this.lstPoints[3], this.lstPoints[5],this.lstPoints[6], this.lstPoints[0]], \"black\")\n    p.couleurDeRemplissage=this.colorT\n    p.opaciteDeRemplissage=1;\n    this.lstPolygone.push(p)\n\n    this.svg=function(coeff){\n      let code = \"\"\n      for (let i=0;i<3;i++) {\n        code += \"\\n\\t\" + this.lstPolygone[i].svg(coeff);\n      }\n      code = `<g id=\"${this.id}\">${code}</g>`\n      return code;\n    }\n    this.tikz = function () {\n      let code = \"\"\n      for (let i=0;i<3;i++) {\n        code += \"\\n\\t\" + this.lstPolygone[i].tikz();\n      }\n      return code;\n    };\n    this.svgml = function (coeff, amp) {\n      let code = \"\"\n      for (let i=0;i<3;i++) {\n        code += \"\\n\\t\" + this.lstPolygone[i].svgml(coeff, amp);\n      }\n      return code;\n    }\n    this.tikzml = function (amp) {\n      let code = \"\"\n      for (let i=0;i<3;i++) {\n      code += \"\\n\\t\" + this.lstPolygone[i].tikzml(amp);\n      }\n      return code;\n    };\n  }\n}\nfunction cube(x=0,y=0,z=0,alpha=45,beta=-35,{colorD=\"green\",colorT=\"white\",colorG=\"gray\"}={}){\n  return new Cube(x,y,z,alpha,beta,colorD,colorG,colorT)\n}\n\n/**\n   * LE PAVE\n   * @Auteur Jean-Claude Lhote\n   * usage : pave(A,B,D,E) construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] sont délimitent 3 faces adjacentes.\n   * \n*/\nclass Pave3d{\n    constructor (A,B,D,E,color){\n        ObjetMathalea2D.call(this)\n        let v1=vecteur3d(A,B)\n        let v2=vecteur3d(A,E)\n        let v3=vecteur3d(A,D)\n        let C=translation3d(D,v1)\n        let H=translation3d(D,v2)\n        let G=translation3d(C,v2)\n        let F=translation3d(B,v2)\n        E.visible=false\n        this.color=color\n        this.base=polygone3d([A,B,F,E])\n        this.hauteur=v3\n        this.aretes=[arete3d(A,B,color),arete3d(A,D,color),arete3d(A,E,color),arete3d(C,B,color),arete3d(F,B,color),arete3d(C,D,color),arete3d(C,G,color),arete3d(F,G,color),arete3d(F,E,color),arete3d(H,G,color),arete3d(H,E,color),arete3d(H,D,color)]\n        this.svg =function (coeff) {\n            let code = \"\";\n            for (let arete of aretes) {\n              code += \"\\n\\t\" + arete.p2d.svg(coeff);\n            }\n            return code;\n          }\n          this.tikz = function() {\n            let code = \"\";\n            for (let arete of aretes) {\n              code += \"\\n\\t\" + arete.p2d.tikz();\n            }\n            return code;\n          }\n    }\n}\nfunction pave3d(A,B,C,E,color='black'){\n    return new Pave3d(A,B,C,E,color)\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% TRANSFORMATIONS%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n\n\n\n  /**\n   * LA ROTATION VECTORIELLE\n   * \n   * @Auteur Jean-Claude Lhote\n   * Cette rotation se distingue de la rotation d'axe (d) par le fait qu'on tourne autour d'une droite vectorielle\n   * Elle sert à faire tourner des vecteurs essentiellement.\n   * Si on l'utilise sur un point, alors il tournera autour d'une droite passant par l'origine.\n   * \n   * @param {*} point3D pour l'instant, cette fonction ne fait tourner qu'un point3d ou un vecteur3d\n   * @param {*} vecteur3D vecteur directeur de l'axe de rotation (l'axe passe par l'origine, pour tourner autour d'une droite particulière on utilise rotation3d())\n   * @param {*} angle Angle de rotation\n   */\n  function rotationV3d(point3D,vecteur3D,angle){ // point = ce qu'on fait tourner (Point3d) ; vecteur = directeur de l'axe de rotation [x,y,z] et angle de rotation en degrés\n  let matrice,V,p2\n  let norme=math.norm(vecteur3D.matrice)\n  let unitaire=math.multiply(vecteur3D.matrice,1/norme)\n  let u=unitaire._data[0],v=unitaire._data[1],w=unitaire._data[2]\n  let c=Math.cos(angle*Math.PI/180),s=Math.sin(angle*Math.PI/180)\n  let k=1-c\n  matrice=math.matrix([[u*u*k+c,u*v*k-w*s,u*w*k+v*s],[u*v*k+w*s,v*v*k+c,v*w*k-u*s],[u*w*k-v*s,v*w*k+u*s,w*w*k+c]])\n  if (point3D.constructor==Point3d){\n    V=math.matrix([point3D.x3d,point3D.y3d,point3D.z3d])\n    p2=math.multiply(matrice,V)\n    return point3d(p2._data[0],p2._data[1],p2._data[2])\n  }\n  else if(point3D.constructor==Vecteur3d){\n    V=point3D\n    p2=math.multiply(matrice,V.matrice)\n    return vecteur3d(p2._data[0],p2._data[1],p2._data[2])\n  }\n  }\n\n\n  /**\n   * LA ROTATION D'AXE UNE DROITE\n   * \n   * @Auteur Jean-Claude Lhote\n   * \n   * @param {Point3d} point3D Pour l'instant on ne fait tourner qu'un point3d\n   * Remarque : ça n'a aucun sens de faire tourner un vecteur autour d'une droite particulière, on utilise la rotation vectorielle pour ça.\n   * @param {Droite3d} droite3D Axe de rotation\n   * @param {Number} angle Angle de rotation\n   * @param {string} color couleur du polygone créé. si non précisé la couleur sera celle du polygone argument\n   */\n  function rotation3d(point3D,droite3D,angle,color){\n    let directeur=droite3D.directeur\n    let origine=droite3D.origine\n    let p=[]\n    if (point3D.constructor==Point3d){\n        let V=vecteur3d(origine,point3d(0,0,0))\n        let W=vecteur3d(point3d(0,0,0),origine)\n        let M=translation3d(point3D,V)\n        let N=rotationV3d(M,directeur,angle)\n        return translation3d(N,W)\n      }\n      else if(point3D.constructor==Vecteur3d){\n        return rotationV3d(point3D,directeur,angle)\n      }\n      else if (point3D.constructor==Polygone3d){\n\n\n        for (let i=0;i<point3D.listePoints.length;i++){\n          p.push(rotation3d(point3D.listePoints[i],droite3D,angle))\n        }\n        if (typeof(color)!='undefined'){\n          return polygone3d(p,color)\n        }\n        else\n          return polygone3d(p,point3D.color)\n      }\n  }\n  \n  function Sens_de_rotation3d(axe,rayon,angle,epaisseur,color){\n    ObjetMathalea2D.call(this)\n    this.epaisseur=epaisseur\n    this.color=color\n    let M,N,s,objets=[],d,A,B\n    M=translation3d(axe.origine,rayon)\n    for (let i=0;i<angle;i+=5){\n      N=rotation3d(M,axe,5)\n      s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(M.p2d,N.p2d)\n      s.color=this.color\n      s.epaisseur=this.epaisseur\n      objets.push(s)\n      M=N\n    }\n    N=rotation3d(M,axe,5)\n    s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(M.p2d,N.p2d)\n    s.color=this.color\n    s.epaisseur=this.epaisseur\n    objets.push(s)\n    d=droite3d(N,axe.directeur)\n    A=rotation3d(M,d,30)\n    B=rotation3d(M,d,-30)\n    s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(N.p2d,A.p2d)\n    s.color=this.color\n    s.epaisseur=this.epaisseur\n    objets.push(s)\n    s=(0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(N.p2d,B.p2d)\n    s.color=this.color\n    s.epaisseur=this.epaisseur\n    objets.push(s)   \n    this.svg =function (coeff) {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.svg(coeff);\n      }\n      return code;\n    }\n    this.tikz = function() {\n      let code = \"\";\n      for (let objet of objets) {\n        code += \"\\n\\t\" + objet.tikz();\n      }\n      return code;\n    }\n  }\nfunction sens_de_rotation3d(axe,rayon,angle,epaisseur,color){\n  return new Sens_de_rotation3d(axe,rayon,angle,epaisseur,color)\n}\n\n  /**\n   * LA TRANSLATION\n   * \n   * @Auteur Jean-Claude Lhote\n   * @param {Point3d} point3D Pour l'instant on ne translate qu'un point3d ou un polygone3d\n   * @param {Vecteur3d} vecteur3D \n   */\n  function translation3d(point3D,vecteur3D){\n    if (point3D.constructor == Point3d){\n    let x=point3D.x3d+vecteur3D.x3d\n    let y=point3D.y3d+vecteur3D.y3d\n    let z=point3D.z3d+vecteur3D.z3d\n    return point3d(x,y,z)\n    }\n    else if (point3D.constructor == Polygone3d){\n      let p=[]\n      for (let i=0;i<point3D.listePoints.length;i++){\n        p.push(translation3d(point3D.listePoints[i],vecteur3D))\n      }\n      return polygone3d(p,point3D.color)\n    }\n  }\n  function homothetie3d(point3D,centre,rapport,color){\n    let V\n    let p=[]\n    if (point3D.constructor==Point3d){\n        V=vecteur3d(centre,point3D)\n        V.x3d*=rapport\n        V.y3d*=rapport\n        V.y3d*=rapport\n        return translation3d(centre,V)\n      }\n      else if(point3D.constructor==Vecteur3d){\n        V=point3D\n        V.x3d*=rapport\n        V.y3d*=rapport\n        V.y3d*=rapport\n        return V\n      }\n      else if (point3D.constructor==Polygone3d){\n\n\n        for (let i=0;i<point3D.listePoints.length;i++){\n          p.push(homothetie3d(point3D.listePoints[i],centre,rapport,color))\n        }\n        if (typeof(color)!='undefined'){\n          return polygone3d(p,color)\n        }\n        else\n          return polygone3d(p,point3D.color)\n      }\n  }\n  \n  \n\n//# sourceURL=webpack://mathalea/./src/js/modules/3d.js?");

/***/ })

}]);