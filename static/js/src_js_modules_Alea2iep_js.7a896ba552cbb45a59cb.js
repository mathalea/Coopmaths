/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmathalea"] = self["webpackChunkmathalea"] || []).push([["src_js_modules_Alea2iep_js"],{

/***/ "./src/js/modules/Alea2iep.js":
/*!************************************!*\
  !*** ./src/js/modules/Alea2iep.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Alea2iep)\n/* harmony export */ });\n/* harmony import */ var _2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./2d.js */ \"./src/js/modules/2d.js\");\n/* harmony import */ var _outils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./outils.js */ \"./src/js/modules/outils.js\");\n/* harmony import */ var instrumenpoche__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! instrumenpoche */ \"./node_modules/.pnpm/framagit.org+Sesamath+instrumenpoche@7cb0619ab5484_aaffd6680a2e8049d51618026d869658/node_modules/Instrumenpoche/src/iepLoadPromise.js\");\n/* eslint-disable camelcase */\n\n\n\n/*\n * Classe parente de tous les objets Alea2iep\n *\n * @Auteur Rémi Angot\n */\n\nfunction Alea2iep() {\n  this.idIEP = 0; // Identifiant pour les tracés\n\n  this.idHTML = 0; // Identifiant pour les div et le svg\n\n  this.tempo = 5; // Pause par défaut après une instruction\n\n  this.vitesse = 10; // Vitesse par défaut pour les déplacements d'instruments\n\n  this.couleur = 'blue'; // Couleur par défaut\n\n  this.couleurCompas = 'forestgreen';\n  this.couleurTexte = 'black';\n  this.couleurPoint = 'black'; // Couleur du nom des points\n\n  this.couleurCodage = '#f15929';\n  this.couleurTraitsDeConstruction = 'gray';\n  this.epaisseur = 2;\n  this.epaisseurTraitsDeConstruction = 1;\n  this.pointilles = false;\n  this.liste_script = []; // Liste des instructions xml mise à jour par les méthodes\n\n  this.translationX = 0;\n  this.translationY = 10; // Par défaut l'angle en haut à gauche est le point de coordonnées (0,10)\n\n  this.recadre = function (xmin, ymax) {\n    this.translationX = 1 - xmin;\n    this.translationY = ymax + 3;\n  }; // Garde en mémoire les coordonnées extrêmes des objets créés\n\n\n  this.xMin = 0;\n  this.yMin = 0;\n  this.xMax = 0;\n  this.yMax = 0;\n\n  this.taille = function (width, height) {\n    this.liste_script.push(`<viewBox width=\"${width}\" height=\"${height}\" />`);\n  }; // Transforme les coordonnées MathALEA2D en coordonnées pour le XML d'IEP\n\n\n  this.x = function (A) {\n    const x = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((A.x + this.translationX) * 30, 0);\n\n    if (A.x > this.xMax) {\n      this.xMax = A.x;\n    }\n\n    if (A.x < this.xMin) {\n      this.xMin = A.x;\n    }\n\n    return x;\n  };\n\n  this.y = function (A) {\n    const y = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-A.y + this.translationY) * 30, 0);\n\n    if (A.y < this.yMin) {\n      this.yMin = A.y;\n    }\n\n    if (A.y > this.yMax) {\n      this.yMax = A.y;\n    }\n\n    return y;\n  }; // Sauvegarde de l'état des instruments\n\n\n  this.regle = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    longueur: 15,\n    zoom: 100\n  };\n  this.crayon = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  };\n  this.equerre = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  };\n  this.requerre = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  };\n  this.rapporteur = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    zoom: 100\n  };\n  this.compas = {\n    visibilite: false,\n    position: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0),\n    angle: 0,\n    orientation: 'droite',\n    ecartement: 0,\n    leve: false,\n    zoom: 100\n  };\n  this.xml = '';\n  /**\n   * Renvoie le script xml\n   *\n   */\n\n  this.script = function () {\n    if (this.xml.length > 1) {\n      return this.xml;\n    } else {\n      let codeXML = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n      codeXML += '<INSTRUMENPOCHE version=\"2\">\\n';\n      codeXML += this.liste_script.join('\\n');\n      codeXML += '\\n</INSTRUMENPOCHE>';\n      return codeXML;\n    }\n  };\n  /**\n   * Renvoie le code HTML de l'animation\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   */\n\n\n  this.html = function (id1, id2) {\n    if (window.sortieHtml) {\n      const id = `IEP_${id1}_${id2}`;\n      window.listeScriptsIep[id] = this.script(); // On ajoute le script\n\n      const codeHTML = `<div id=\"IEPContainer${id}\" ></div>`;\n      window.listeAnimationsIepACharger.push(id);\n      return codeHTML;\n    }\n  };\n  /**\n   *\n   * @param {int} numeroExercice - Numéro de l'exercice\n   * @param {int} i - Numéro de la question\n   * @return Code HTML avec le bouton qui affiche ou masque un div avec l'animation\n   */\n\n\n  this.htmlBouton = function (id1, id2 = '') {\n    if (window.sortieHtml) {\n      const id = `IEP_${id1}_${id2}`;\n      window.listeScriptsIep[id] = this.script(); // On ajoute le script\n\n      const codeHTML = `<br><button class=\"ui mini compact button\" id=\"btnAnimation${id}\" onclick=\"toggleVisibilityIEP('${id}')\" style=\"margin-top:20px\"><i class=\"large play circle outline icon\"></i>Voir animation</button>\n            <div id=\"IEPContainer${id}\" style=\"display: none;\" ></div>`;\n\n      if (!window.toggleVisibilityIEP) {\n        window.toggleVisibilityIEP = function (id) {\n          const element = document.getElementById(`IEPContainer${id}`);\n          const elementBtn = document.getElementById(`btnAnimation${id}`);\n          const xml = window.listeScriptsIep[id];\n\n          if (element.style.display === 'none') {\n            element.style.display = 'block';\n            element.style.marginTop = '30px';\n            elementBtn.innerHTML = '<i class=\"large stop circle outline icon\"></i>Masquer animation';\n            (0,instrumenpoche__WEBPACK_IMPORTED_MODULE_2__.default)(element, xml, {\n              zoom: true,\n              autostart: true\n            }).then(iepApp => {// la figure est chargée\n            }).catch(error => {\n              console.log(error);\n            });\n          } else {\n            element.style.display = 'none';\n            elementBtn.innerHTML = '<i class=\"large play circle outline icon\"></i>Voir animation';\n          }\n        };\n      }\n\n      return codeHTML;\n    } else {\n      return '';\n    }\n  };\n  /**\n  **************************\n  *** FONCTIONS COMMUNES ***\n  **************************\n  */\n\n  /**\n   *\n   * @param {string} objet - 'regle', 'equerre', 'requerre, 'compas', 'rapporteur' ou 'crayon'\n   * @param {point} A - Point (0, 0) par défaut\n   * @param {objet} options - { tempo : 10 }\n   */\n\n\n  this.montrer = function (objet, A, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    if (!this[objet].visibilite || this[objet].position !== A) {\n      // On ajoute une ligne xml que si l'objet est caché ou doit apparaitre à un autre endroit\n      let codeXML = '';\n      let A1;\n\n      if (typeof A === 'undefined') {\n        // A1 est une copie de A ou (0,0) si A n'est pas défini\n        A1 = this[objet].position;\n      } else {\n        A1 = A;\n      }\n\n      if (this[objet].visibilite) {\n        // S'il est déjà visible, montrer devient un déplcer\n        this.deplacer(objet, A1, {\n          tempo: tempo,\n          vitesse: vitesse\n        });\n      } else {\n        codeXML = `<action objet=\"${objet}\" mouvement=\"montrer\" abscisse=\"${this.x(A1)}\" ordonnee=\"${this.y(A1)}\" tempo=\"${tempo}\" />`;\n        this[objet].visibilite = true;\n      }\n\n      this[objet].position = A1;\n      this.liste_script.push(codeXML);\n    }\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.regleMontrer = function (A, options) {\n    this.montrer('regle', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.crayonMontrer = function (A, options) {\n    this.montrer('crayon', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.equerreMontrer = function (A, options) {\n    this.montrer('equerre', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.requerreMontrer = function (A, options) {\n    this.montrer('requerre', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.compasMontrer = function (A, options) {\n    this.montrer('compas', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.rapporteurMontrer = function (A, options) {\n    this.montrer('rapporteur', A, options);\n  };\n  /**\n   *\n   * @param {string} objet\n   * @param {objet} param1\n   */\n\n\n  this.masquer = function (objet, {\n    tempo = this.tempo\n  } = {}) {\n    if (this[objet].visibilite) {\n      // On ajoute une ligne xml que si l'objet est visible\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"masquer\" tempo=\"${tempo}\" />`;\n      this[objet].visibilite = false;\n      this.liste_script.push(codeXML);\n    }\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.regleMasquer = function (options) {\n    this.masquer('regle', options);\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.crayonMasquer = function (options) {\n    this.masquer('crayon', options);\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.equerreMasquer = function (options) {\n    this.masquer('equerre', options);\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.requerreMasquer = function (options) {\n    this.masquer('requerre', options);\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.compasMasquer = function (options) {\n    this.masquer('compas', options);\n  };\n  /**\n   *\n   * @param {objet} options\n   */\n\n\n  this.rapporteurMasquer = function (options) {\n    this.masquer('rapporteur', options);\n  };\n  /**\n  *\n  * @param {string} objet\n  * @param {point} A\n  * @param {objet} options\n  */\n\n\n  this.deplacer = function (objet, A, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    if (this[objet].position !== A) {\n      // On n'ajoute une commande xml que s'il y a vraiment un déplacement\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`;\n      this[objet].position = A;\n      this.liste_script.push(codeXML);\n    }\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.regleDeplacer = function (A, options) {\n    this.deplacer('regle', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.texteDeplacer = function (id, A, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    const codeXML = `<action objet=\"texte\" id=\"${id}\" mouvement=\"translation\" abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`;\n    this.liste_script.push(codeXML);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.crayonDeplacer = function (A, options) {\n    this.deplacer('crayon', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.equerreDeplacer = function (A, options) {\n    this.deplacer('equerre', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.requerreDeplacer = function (A, options) {\n    this.deplacer('requerre', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.compasDeplacer = function (A, options) {\n    this.deplacer('compas', A, options);\n  };\n  /**\n   *\n   * @param {point} A\n   * @param {objet} options\n   */\n\n\n  this.rapporteurDeplacer = function (A, options) {\n    this.deplacer('rapporteur', A, options);\n  };\n  /**\n  *\n  * @param {string} objet\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.rotation = function (objet, a, {\n    tempo = this.tempo,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0)\n  } = {}) {\n    let angle;\n\n    if (a.typeObjet === 'point') {\n      const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(this[objet].position, a);\n      angle = d.angleAvecHorizontale;\n    } else {\n      angle = a;\n    }\n\n    if (this[objet].angle !== a) {\n      // Si la rotation est inutile, on ne la fait pas\n      // Les angles de MathALEA2D et de IEP sont opposés !!!!!\n      const codeXML = `<action objet=\"${objet}\" mouvement=\"rotation\" angle=\"${-1 * angle}\" tempo=\"${tempo}\" sens=\"${sens}\" />`;\n      this[objet].angle = angle;\n\n      if (typeof angle === 'number' && isFinite(angle)) {\n        this.liste_script.push(codeXML);\n      } else {\n        console.log('Angle de rotation non défini pour l\\'objet .', objet);\n      }\n    }\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.regleRotation = function (angle, options) {\n    this.rotation('regle', angle, options);\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.crayonRotation = function (angle, options) {\n    this.rotation('crayon', angle, options);\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.equerreRotation = function (angle, options) {\n    this.rotation('equerre', angle, options);\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.requerreRotation = function (angle, options) {\n    this.rotation('requerre', angle, options);\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.compasRotation = function (angle, options) {\n    this.rotation('compas', angle, options);\n  };\n  /**\n  *\n  * @param {int} angle\n  * @param {objet} options\n  */\n\n\n  this.rapporteurRotation = function (angle, options) {\n    this.rotation('rapporteur', angle, options);\n  };\n  /**\n  *\n  * @param {int} pourcentage 200 pour doubler la taille\n  * @param {objet} options tempo = 0 par défaut\n  */\n\n\n  this.regleZoom = function (k, {\n    tempo = 0\n  } = {}) {\n    this.regle.zoom = k;\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"regle\" tempo=\"${tempo}\" />`);\n  };\n  /**\n  *\n  * @param {int} pourcentage 200 pour doubler la taille\n  * @param {objet} options tempo = 0 par défaut\n  */\n\n\n  this.equerreZoom = function (k, {\n    tempo = 0\n  } = {}) {\n    this.equerre.zoom = k;\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"equerre\" tempo=\"${tempo}\" />`);\n  };\n  /**\n  *\n  * @param {int} pourcentage 200 pour doubler la taille\n  * @param {objet} options tempo = 0 par défaut\n  */\n\n\n  this.requerreZoom = function (k, {\n    tempo = 0\n  } = {}) {\n    this.requerre.zoom = k;\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"requerre\" tempo=\"${tempo}\" />`);\n  };\n  /**\n  *\n  * @param {int} pourcentage 200 pour doubler la taille\n  * @param {objet} options tempo = 0 par défaut\n  */\n\n\n  this.rapporteurZoom = function (k, {\n    tempo = 0\n  } = {}) {\n    this.rapporteur.zoom = k;\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"rapporteur\" tempo=\"${tempo}\" />`);\n  };\n  /**\n  *\n  * @param {int} pourcentage 200 pour doubler la taille\n  * @param {objet} options tempo = 0 par défaut\n  */\n\n\n  this.compasZoom = function (k, {\n    tempo = 0\n  } = {}) {\n    this.compas.zoom = k;\n    this.liste_script.push(`<action echelle=\"${k}\" mouvement=\"zoom\" objet=\"compas\" />`);\n  };\n  /**\n  **************************\n  ********* POINT **********\n  **************************\n  */\n\n  /**\n  * Crééer un point avec la croix pour le situer et son nom en bas à droite par défaut. L'id sera sauvegardé dans l'objet point. S'il n'est pas défini alors on prend le premier entier disponible.\n  * @param {point} A\n  * @param {objet} options { label: A.nom, tempo: this.tempo, couleur: this.couleurPoint, couleurLabel: this.couleurTexte, id }\n  *\n  */\n\n\n  this.pointCreer = function (A, {\n    dx = 0.1,\n    dy,\n    label = A.nom,\n    tempo = this.tempo,\n    couleur = this.couleurPoint,\n    couleurLabel = this.couleurTexte,\n    id\n  } = {}) {\n    if (typeof id !== 'undefined') {\n      A.id = id;\n    } else {\n      this.idIEP++;\n      A.id = this.idIEP;\n    }\n\n    let codeXML;\n\n    if (label) {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" />`; // codeXML += `\\n<action couleur=\"${couleurLabel}\" nom=\"${label}\" id=\"${this.idIEP}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\"  />`\n\n      const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(A.x, A.y);\n\n      if (typeof dx !== 'undefined') {\n        M.x += dx;\n      }\n\n      if (typeof dy !== 'undefined') {\n        M.y += dy;\n      }\n\n      this.textePoint(`$${label}$`, M, {\n        tempo: 0,\n        couleur: couleurLabel\n      });\n    } else {\n      codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" couleur=\"${couleur}\" id=\"${A.id}\" mouvement=\"creer\" objet=\"point\" tempo=\"${tempo}\" />`;\n    }\n\n    this.liste_script.push(codeXML);\n  };\n  /**\n  * Création de plusieurs points\n  * Le dernier argument peut être une option qui sera appliquée à tous les points\n  *\n  * @param  {...points} points Points séparés par des virgules\n  */\n\n\n  this.pointsCreer = function (...args) {\n    if (args[args.length - 1].typeObjet === 'point') {\n      for (const point of args) {\n        this.pointCreer(point, {\n          tempo: 0\n        });\n      }\n    } else {\n      const options = args[args.length - 1];\n\n      const enleveDernier = arr => arr.slice(0, -1);\n\n      for (const point of enleveDernier(args)) {\n        this.pointCreer(point, options);\n      }\n    }\n  };\n  /**\n  * Masquer un point\n  * @param {point} A\n  * @param {objet} options Défaut : { tempo: 0 }\n  */\n\n\n  this.pointMasquer = function (A, {\n    tempo = 0\n  } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"masquer\" objet=\"point\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   * Montrer un point qui aurait été caché\n   * @param {point} A\n   * @param {objet} options Défaut ; { tempo : this.tempo }\n   */\n\n\n  this.pointMontrer = function (A, {\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action id=\"${A.id}\" mouvement=\"montrer\" objet=\"point\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   * Anime la translation d'un point\n   * @param {point} A\n   * @param {int} x Abscisse du point d'arrivée\n   * @param {int} y Ordonnée du point d'arrivée\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n\n\n  this.pointDeplacer = function (A, x, y, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(x, y);\n    this.liste_script.push(`<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" id=\"${A.id}\" mouvement=\"translation\" objet=\"point\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`);\n  };\n  /**\n   * Ajoute un label au point\n   * @param {point} A\n   * @param {string} nom\n   * @param {objet} options dx pour le déplacement vertical du nom du point, dy pour le déplacemetn horizontal, couleur: this.couleurPoint, tempo: this.tempo\n   */\n\n\n  this.pointNommer = function (A, nom, {\n    dx,\n    dy,\n    couleur = this.couleurPoint,\n    tempo = this.tempo\n  } = {}) {\n    // const coordonneesTexte = ''\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(A.x, A.y);\n\n    if (typeof dx !== 'undefined') {\n      M.x += dx;\n    }\n\n    if (typeof dy !== 'undefined') {\n      M.y += dy;\n    }\n\n    this.textePoint(`$${nom}$`, M, {\n      tempo: tempo,\n      couleur: couleur\n    }); // this.liste_script.push(`<action couleur=\"${couleur}\" nom=\"${nom}\" id=\"${A.id}\" mouvement=\"nommer\" objet=\"point\" tempo=\"${tempo}\" ${coordonneesTexte} />`)\n  };\n  /**\n  **************************\n  ********* COMPAS *********\n  **************************\n  */\n\n  /**\n  * Change l'orientation du compas. Par défaut, elle est vers la droite. L'orientation courante du compas est sauvegardée dans this.compas.orientation\n  * @param {objet} options Défaut : { tempo: this.tempo}\n  */\n\n\n  this.compasRetourner = function ({\n    tempo = this.tempo\n  } = {}) {\n    const codeXML = `<action mouvement=\"retourner\" objet=\"compas\" tempo=\"${tempo}\" />`;\n\n    if (this.compas.orientation === 'droite') {\n      this.compas.orientation = 'gauche';\n    } else {\n      this.compas.orientation = 'droite';\n    }\n\n    this.liste_script.push(codeXML);\n  };\n  /**\n   *\n   * @param {int} longueur écartement en cm\n   * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n\n\n  this.compasEcarter = function (l, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    const codeXML = `<action ecart=\"${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(l * 30, 1)}\" mouvement=\"ecarter\" objet=\"compas\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`;\n    this.compas.ecartement = l;\n    this.liste_script.push(codeXML);\n  };\n  /**\n   * Fais apparaitre la règle à l'horizontale, met le compas vertical et écarte le compas le long de la règle pour lire son écartement\n   * @param {int} longueur\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n   */\n\n\n  this.compasEcarterAvecRegle = function (l, {\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = this.vitesse / 2\n  } = {}) {\n    this.regleRotation(0, {\n      tempo: 0,\n      sens: sens\n    });\n    this.regleMontrer(this.compas.position, {\n      tempo: 0\n    });\n    this.regleDeplacer(this.compas.position, {\n      tempo: 0,\n      vitesse: vitesse\n    });\n    this.compasMontrer();\n    this.compasRotation(0, {\n      tempo: 0,\n      sens: sens\n    });\n    this.compasEcarter(l, {\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens\n    });\n  };\n  /**\n  *\n  * @param {point} A Pointe du compas\n  * @param {point} B Mine du compas\n  * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n  */\n\n\n  this.compasEcarter2Points = function (A, B, {\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2)\n  } = {}) {\n    this.compasMontrer(A);\n    this.compasDeplacer(A, {\n      tempo: tempo,\n      vitesse: vitesse\n    });\n    const s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(A, B);\n    s.isVisible = false;\n    const angle = s.angleAvecHorizontale;\n    this.compasRotation(angle, {\n      tempo: tempo,\n      sens: sens\n    });\n    this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B), {\n      tempo: tempo,\n      vitesse: vitesse\n    });\n  };\n  /**\n  * Remettre le compas en position standard. Son état est sauvegardé dans le booléen this.compas.leve.\n  * @param {objet} options Défaut : { tempo: this.tempo }\n  */\n\n\n  this.compasLever = function ({\n    tempo = this.tempo\n  } = {}) {\n    if (!this.compas.leve) {\n      // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"lever\" objet=\"compas\" tempo=\"${tempo} />`;\n      this.compas.leve = true;\n      this.liste_script.push(codeXML);\n    }\n  };\n  /**\n  * Voir le compas en vue de dessus avant qu'il trace un arc de cercle\n  * @param {objet} options Défaut : { tempo: this.tempo }\n  */\n\n\n  this.compasCoucher = function ({\n    tempo = this.tempo\n  } = {}) {\n    if (this.compas.leve) {\n      // On ne fait rien si le compas est déjà levé\n      const codeXML = `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\" />`;\n      this.compas.leve = false;\n      this.liste_script.push(codeXML);\n    }\n  };\n  /**\n  * Trace un arc de cercle en gardant l'écartement et le centre actuel. L'angle de départ sera choisi pour être le plus proche de l'angle actuel\n  * @param {int} angle1\n  * @param {int} angle2\n  * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n  * @return {id}\n  */\n\n\n  this.compasTracerArc2Angles = function (angle1, angle2, {\n    tempo = this.tempo,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0),\n    epaisseur = this.epaisseur,\n    couleur = this.couleurCompas,\n    pointilles = this.pointilles\n  } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : '';\n    this.idIEP += 1;\n\n    if (Math.abs(this.compas.angle - angle1) > Math.abs(this.compas.angle - angle2)) {\n      // On cherche à commencer par le point le plus proche de la position courante du compas\n      [angle1, angle2] = [angle2, angle1];\n    }\n\n    let codeXML = `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" tempo=\"${tempo}\" />\\n`;\n    codeXML += '<action mouvement=\"lever\" objet=\"compas\" />\\n';\n    codeXML += `<action sens=\"${sens}\" angle=\"${-angle1}\" mouvement=\"rotation\" objet=\"compas\" />\\n`;\n    let sensTexte;\n\n    if (angle2 > angle1) {\n      sensTexte = sens;\n    } else {\n      sensTexte = -1 * sens;\n    }\n\n    codeXML += `<action couleur=\"${couleur}\" epaisseur=\"${epaisseur}\" sens=\"${sensTexte}\" debut=\"${-angle1}\" fin=\"${-angle2}\" mouvement=\"tracer\" objet=\"compas\"  ${pointillesTexte} id=\"${this.idIEP}\" />\\n`;\n    codeXML += `<action mouvement=\"coucher\" objet=\"compas\" tempo=\"${tempo}\"/>`;\n    this.compas.angle = angle2;\n    this.liste_script.push(codeXML);\n    return this.idIEP;\n  };\n  /**\n   * Trace un arc de cercle autour d'un point. La longueur de l'arc est déterminée par l'option delta en degré qui est ajoutée de part et d'autre du point\n   * @param {point} centre\n   * @param {point} point\n   * @param {objet} options Défaut : { delta: 10, tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n   * @return {id}\n   */\n\n\n  this.compasTracerArcCentrePoint = function (centre, point, {\n    delta = 10,\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0),\n    epaisseur = this.epaisseur,\n    couleur = this.couleurCompas,\n    pointilles = this.pointilles\n  } = {}) {\n    this.compasMontrer();\n    this.compasDeplacer(centre, {\n      tempo: tempo,\n      vitesse: vitesse\n    });\n    const s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(centre, point);\n    s.visibility = false;\n    const angle1 = s.angleAvecHorizontale - delta;\n    const angle2 = s.angleAvecHorizontale + delta;\n\n    if (Math.abs(this.compas.ecartement - (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.compas.position, point)) > 0.1) {\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, point), {\n        tempo: tempo,\n        vitesse: vitesse\n      });\n    }\n\n    return this.compasTracerArc2Angles(angle1, angle2, {\n      tempo: tempo,\n      vitesse: vitesse,\n      epaisseur: epaisseur,\n      sens: sens,\n      couleur: couleur,\n      pointilles: pointilles\n    });\n  };\n  /**\n  *\n  * @param {point} centre\n  * @param {point} point Point de départ du tracé du cercle\n  * @param {objet} options Défaut : { tempo: this.tempo, sens: this.vitesse / 2, epaisseur: this.epaisseur, couleur: this.couleurCompas, pointilles: this.pointilles }\n  */\n\n\n  this.compasCercleCentrePoint = function (centre, point, {\n    tempo = this.tempo,\n    couleur = this.couleur,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2),\n    epaisseur = this.epaisseur,\n    pointilles = this.pointilles\n  } = {}) {\n    this.compasEcarter2Points(centre, point, {\n      vitesse: vitesse,\n      tempo: tempo\n    });\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(centre, point);\n    const angle1 = d.angleAvecHorizontale;\n    this.compasTracerArc2Angles(angle1, angle1 + 360, {\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens,\n      epaisseur: epaisseur,\n      couleur: couleur,\n      pointilles: pointilles\n    });\n  };\n  /**\n  **************************\n  ******** REQUERRE ********\n  **************************\n  */\n\n  /**\n   *\n   * @param {int} déplacement en nombre de cm (le déplacement peut être positif ou négatif)\n   * @param {*} options Défaut : { tempo: this.tempo, vitesse: this.vitesse }\n   */\n\n\n  this.requerreGlisserEquerre = function (a, {\n    tempo = this.tempo,\n    vitesse = this.vitesse\n  } = {}) {\n    this.liste_script.push(`<action abscisse=\"${a * 30}\" mouvement=\"glisser\" objet=\"requerre\" tempo=\"${tempo}\" vitesse=\"${vitesse}\" />`);\n  };\n  /**\n  **************************\n  ******* RAPPORTEUR *******\n  **************************\n  */\n  // Non pris en charge par le lecteur JS\n  // this.rapporteurCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"circulaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n  // this.rapporteurSemiCirculaire = function (tempo=this.tempo) {\n  // //     this.liste_script.push(`<action mouvement=\"semicirculaire\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`)\n  // }\n\n  /**\n   * Masque la graduation externe du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.rapporteurMasquerGraduationsExterieures = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n   * Montre la graduation extérieure si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.rapporteurMontrerGraduationsExterieures = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"montrer_nombres\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n   * Masque la graduation interne du rapporteur (laisse l'autre graduation visible)\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.rapporteurMasquerGraduationsInterieures = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n   * Montre la graduation interne si elle avait été précédemment cachée\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.rapporteurMontrerGraduationsInterieures = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"rapporteur\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n  * Met le rapporteur en position avec le centre en A et le 0 de droite alogné avec le point B\n  * @param {point} A\n  * @param {point} B\n  * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2 }\n  */\n\n\n  this.rapporteurDeplacerRotation2Points = function (A, B, {\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2)\n  } = {}) {\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    d.isVisible = false;\n    this.rapporteurMontrer();\n    this.rapporteurDeplacer(A, {\n      tempo: tempo,\n      vitesse: vitesse\n    });\n    this.rapporteurRotation(d.angleAvecHorizontale, {\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens\n    });\n  };\n  /**\n  * Fais une petite marque (couleur et épaisseur d'un trait de construction) sur une graduation du rapporteur\n  * @param {int} angle\n  * @param {objet} options Défaut : { tempo: this.tempo, vitesse: this.vitesse, couleur: this.couleurTraitsDeConstruction, epaisseur: this.epaisseurTraitsDeConstruction }\n  */\n\n\n  this.rapporteurCrayonMarqueAngle = function (angle, {\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    couleur = this.couleurTraitsDeConstruction,\n    epaisseur = this.epaisseurTraitsDeConstruction\n  } = {}) {\n    const O = this.rapporteur.position;\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(O, 5.2, angle + this.rapporteur.angle);\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(O, 5.5, angle + this.rapporteur.angle);\n    this.crayonMontrer();\n    this.crayonDeplacer(M, {\n      tempo: tempo,\n      vitesse: vitesse\n    });\n    this.tracer(N, {\n      tempo: tempo,\n      vitesse: vitesse,\n      couleur: couleur,\n      epaisseur: epaisseur\n    });\n  };\n  /**\n  * Le crayon va faire une marque sur la graduation du rapporteur, le rapporteur va se cacher et on trace une demi-droite dont on peut choisir la \"longueur\" (par défaut 90% de celle de la règle)\n  * @param {point} A Centre du rapporteur\n  * @param {point} B Point avec lequel le 0 de droite sera aligné\n  * @param {int} angle\n  * @param {objet} options { longueur: 0.9 * this.regle.longueur, couleur: this.couleur, tempo: this.tempo, vitesse: this.vitesse, sens : this.vitesse / 2, epaisseur: this.epaisseur, pointilles: this.pointilles }\n  */\n\n\n  this.rapporteurTracerDemiDroiteAngle = function (A, B, angle, {\n    longueur = 0.9 * this.regle.longueur,\n    couleur = this.couleur,\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2),\n    epaisseur = this.epaisseur,\n    pointilles = this.pointilles\n  } = {}) {\n    if (angle > 0) {\n      this.rapporteurDeplacerRotation2Points(A, B, {\n        tempo: tempo,\n        vitesse: vitesse,\n        sens: sens\n      });\n      this.rapporteurCrayonMarqueAngle(angle, {\n        tempo: tempo,\n        vitesse: vitesse,\n        sens: sens\n      });\n    } else {\n      const B2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 180);\n      this.rapporteurDeplacerRotation2Points(A, B2, {\n        tempo: tempo,\n        vitesse: vitesse,\n        sens: sens\n      });\n      this.rapporteurCrayonMarqueAngle(180 - Math.abs(angle), {\n        tempo: tempo,\n        vitesse: vitesse,\n        sens: sens\n      });\n    }\n\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    d.isVisible = false;\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(5.2 * this.rapporteur.zoom / 100, 1), d.angleAvecHorizontale + angle);\n    this.rapporteurMasquer({\n      tempo: tempo\n    });\n    this.regleDemiDroiteOriginePoint(A, M, {\n      longueur: longueur,\n      couleur: couleur,\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens,\n      epaisseur: epaisseur,\n      pointilles: pointilles\n    });\n  };\n  /**\n  **************************\n  ********* REGLE **********\n  **************************\n  */\n\n  /**\n  * Masquer les graduations sur la règle\n  * @param {objet} options Défaut : { tempo: this.tempo }\n  */\n\n\n  this.regleMasquerGraduations = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"vide\" objet=\"regle\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n  * Montrer les graduations sur la règle si elles avaient été masquées\n  * @param {objet} options Défaut : { tempo: this.tempo }\n  */\n\n\n  this.regleMontrerGraduations = function ({\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"graduations\" objet=\"regle\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n   * Modifie la taille de la règle\n   * @param {int} longueur\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.regleModifierLongueur = function (longueur = 20, {\n    tempo = this.tempo\n  } = {}) {\n    this.regle.longueur = longueur;\n    this.liste_script.push(`<action mouvement=\"modifier_longueur\" objet=\"regle\" longueur=\"${longueur}\" tempo=\"${tempo}\"/>`);\n  };\n  /**\n  * Trace une demi-droite d'origine O passant par A (ou en direction de A si les points sont trop éloignés)\n  * @param {point} O Origine\n  * @param {point} A Direction\n  * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n  */\n\n\n  this.regleDemiDroiteOriginePoint = function (O, A, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur;\n    }\n\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, A, options.longueur);\n    this.regleSegment(O, M, options);\n  };\n  /**\n   * Trace une droite passanrt par les points A et B\n   * @param {point} A\n   * @param {point} B\n   * @param {objet} options Défaut {longueur: this.regle.longueur, tempo : this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n   */\n\n\n  this.regleDroite = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur;\n    }\n\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(B, A, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-options.longueur * 0.5 + (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) * 0.5) / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B)));\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(A, B, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((-options.longueur * 0.5 + (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) * 0.5) / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B)));\n\n    if (this.x(A) <= this.x(B)) {\n      this.regleMontrer(M);\n      this.regleRotation(N, options);\n      this.regleSegment(M, N, options);\n    } else {\n      this.regleMontrer(N);\n      this.regleRotation(M, options);\n      this.regleSegment(N, M, options);\n    }\n  };\n  /**\n  * Avec la règle, on prolonge le segment de l cm du coté de la 2e extrémité si l est positif sinon du côté de la première extrémité\n  * @param {point} A\n  * @param {point} B\n  * @param {objet} options Défaut {longueur: 3, tempo: this.tempo, vitesse: this.vitesse, sens: this.vitesse / 2}\n  */\n\n\n  this.regleProlongerSegment = function (A, B, options = {}) {\n    if (!options.longueur) {\n      options.longueur = this.regle.longueur - 3;\n    }\n\n    if (options.longueur > 0) {\n      const B1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, 3);\n      const B2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, -options.longueur);\n      this.regleSegment(B1, B2, options);\n    } else {\n      const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, 3);\n      const A2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, options.longueur);\n      this.regleSegment(A1, A2, options);\n    }\n  };\n  /**\n  **************************\n  ********* TRAITS *********\n  **************************\n  */\n\n  /**\n  * Le crayon trace un trait de sa position courante jusqu'au point B\n  * @param {point} B\n  * @param {objet} options Défaut { tempo: this.tempo, vitesse: this.vitesse, epaisseur: this.epaisseur, couleur: this.couleur, pointilles: this.pointilles, vecteur: false }\n  * @return {id} id utilisée pour le tracé\n  */\n\n\n  this.tracer = function (B, {\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    epaisseur = this.epaisseur,\n    couleur = this.couleur,\n    pointilles = this.pointilles,\n    vecteur = false\n  } = {}) {\n    const pointillesTexte = pointilles ? 'pointille=\"tiret\"' : '';\n    const vecteurTexte = vecteur ? 'style=\"vecteur\"' : '';\n    this.idIEP += 1;\n    const codeXML = `<action abscisse=\"${this.x(B)}\" ordonnee=\"${this.y(B)}\" epaisseur=\"${epaisseur}\" couleur=\"${couleur}\" mouvement=\"tracer\" objet=\"crayon\" tempo=\"${tempo}\" vitesse=\"${vitesse}\"  ${pointillesTexte} ${vecteurTexte} id=\"${this.idIEP}\" />`;\n    this.crayon.position = B;\n    this.liste_script.push(codeXML);\n    return this.idIEP;\n  };\n  /**\n   * Trace au crayon le segment [AB]\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n\n\n  this.trait = function (A, B, options = {}) {\n    this.crayonDeplacer(A, options);\n    return this.tracer(B, options);\n  };\n  /**\n   * Trace au crayon le segment [AB] sans tempo et avec une vitesse multipliée par 1 000\n   * @param {point} A Première extrémité\n   * @param {point} B Deuxième extrémité\n   * @param {*} options\n   * @return {id} id utilisée pour le tracé\n   */\n\n\n  this.traitRapide = function (A, B, options = {}) {\n    options.tempo = 0;\n    options.vitesse = 10000;\n    this.crayonDeplacer(A, options);\n    return this.tracer(B, options);\n  };\n  /**\n  * Masque le trait d'id fourni\n  * @param {int} id\n  * @param {objet} options Défaut : { tempo: 0, vitesse: 200 }\n  */\n\n\n  this.traitMasquer = function (id, {\n    tempo = 0,\n    vitesse = 200\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"trait\" id=\"${id}\" vitesse=\"${vitesse}\" />`);\n  };\n  /**\n   *\n   * @param {segment/point} Segment à tracer ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points\n   * @returns {id} identifiant utilisé pour le trait\n   */\n\n\n  this.regleSegment = function (arg1, arg2, arg3) {\n    let A, B, options, id;\n\n    if (arg1.typeObjet === 'segment') {\n      A = arg1.extremite1;\n      B = arg1.extremite2;\n      options = arg2;\n    } else {\n      A = arg1;\n      B = arg2;\n      options = arg3;\n    }\n\n    if (A.x <= B.x) {\n      // Toujours avoir la règle de gauche à droite\n      this.regleMontrer(A, options);\n      this.regleRotation(B, options);\n    } else {\n      this.regleMontrer(B, options);\n      this.regleRotation(A, options);\n    }\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.crayon.position, A) < (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(this.crayon.position, B)) {\n      // Le crayon ira au point le plus proche\n      this.crayonMontrer(A, options);\n      id = this.tracer(B, options);\n    } else {\n      this.crayonMontrer(B, options);\n      id = this.tracer(A, options);\n    }\n\n    return id;\n  };\n  /**\n   * Trace un polygone avec les options par défaut que l'on ne peut pas changer ici\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n\n\n  this.polygoneTracer = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.regleSegment(sommets[i], sommets[i + 1]);\n    }\n\n    this.regleSegment(sommets[sommets.length - 1], sommets[0]);\n  };\n  /**\n   * Trace un polygone avec traitRapide()\n   * @param  {...points} sommets du polygonne séparés par des virgules\n   */\n\n\n  this.polygoneRapide = function (...sommets) {\n    for (let i = 0; i < sommets.length - 1; i++) {\n      this.traitRapide(sommets[i], sommets[i + 1]);\n    }\n\n    this.traitRapide(sommets[sommets.length - 1], sommets[0]);\n  };\n  /**\n  **************************\n  ********* TEXTE **********\n  **************************\n  */\n\n  /**\n   * Ecris un texte collé au point. On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {point} A\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   * @return {id}\n   */\n\n\n  this.textePoint = function (texte, A, {\n    tempo = this.tempo,\n    police = false,\n    couleur = this.couleurTexte,\n    taille,\n    couleurFond,\n    opaciteFond,\n    couleurCadre,\n    epaisseurCadre,\n    marge,\n    margeGauche,\n    margeDroite,\n    margeHaut,\n    margeBas\n  } = {}) {\n    this.idIEP++;\n    const policeTexte = police ? `police=\"${police}\"` : '';\n    let options = '';\n\n    if (typeof couleurFond !== 'undefined') {\n      options += ` couleur_fond=\"${couleurFond}\"`;\n    }\n\n    if (typeof opaciteFond !== 'undefined') {\n      options += ` opacite_fond=\"${opaciteFond}\"`;\n    }\n\n    if (typeof couleurCadre !== 'undefined') {\n      options += ` couleur_cadre=\"${couleurCadre}\"`;\n    }\n\n    if (typeof epaisseurCadre !== 'undefined') {\n      options += ` epaisseur_cadre=\"${epaisseurCadre}\"`;\n    }\n\n    if (typeof marge !== 'undefined') {\n      options += ` marge=\"${marge}\"`;\n    }\n\n    if (typeof margeGauche !== 'undefined') {\n      options += ` marge_gauche=\"${margeGauche}\"`;\n    }\n\n    if (typeof margeDroite !== 'undefined') {\n      options += ` marge_droite=\"${margeDroite}\"`;\n    }\n\n    if (typeof margeBas !== 'undefined') {\n      options += ` marge_bas=\"${margeBas}\"`;\n    }\n\n    if (typeof margeHaut !== 'undefined') {\n      options += ` marge_haut=\"${margeHaut}\"`;\n    }\n\n    if (typeof taille !== 'undefined') {\n      options += ` taille=\"${taille}\"`;\n    }\n\n    let codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"creer\" objet=\"texte\" />`;\n    codeXML += `\\n<action ${policeTexte} couleur=\"${couleur}\" texte=\"${texte}\" id=\"${this.idIEP}\" mouvement=\"ecrire\" objet=\"texte\" ${options} tempo=\"${tempo}\" />`;\n    this.liste_script.push(codeXML);\n    return this.idIEP;\n  };\n  /**\n   * Ecris un texte collé au point de coordonnées (x,y). On peut choisir un fond, un cadre, l'opacité du fond, la police...\n   * @param {string} texte\n   * @param {int} x Abscisse du coin en haut à gauche\n   * @param {int} y Ordonnée du coin en haut à gauche\n   * @param {objet} options Défaut : { tempo: this.tempo, police: false, couleur: this.couleurTexte, couleurFond, opaciteFond, couleurCadre, epaisseurCadre, marge, margeGauche, margeDroite, margeHaut, margeBas }\n   */\n\n\n  this.textePosition = function (texte, x, y, options) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(x, y);\n    return this.textePoint(texte, A, options);\n  };\n\n  this.longueurSegment = function (A, B, dy, options) {\n    const l = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B, 1));\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B);\n    const w = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-v.y * dy / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.norme)(v), v.x * dy / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.norme)(v));\n    const ancrage = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, l / 2 - 0.7), w), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(0, 1));\n    return this.textePoint(`${l} cm`, ancrage, options);\n  };\n\n  this.mesureAngle = function (A, O, B) {\n    const a = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)(A, O, B);\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, a / 2), O, 1.3 / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(O, A)), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-0.2, 0.5));\n    return this.textePoint(Math.abs(a) + '°', C);\n  };\n  /**\n  * Masque le trait d'id fourni\n  * @param {int} id\n  * @param {objet} options Défaut : { tempo: 0 }\n  */\n\n\n  this.texteMasquer = function (id, {\n    tempo = 0\n  } = {}) {\n    this.liste_script.push(`<action mouvement=\"masquer\" objet=\"texte\" id=\"${id}\"  />`);\n  };\n  /**\n   * Met l'animation en pause forçant l'utilisateur à appuyer sur lecture pour voir la suite\n   */\n\n\n  this.pause = function () {\n    this.liste_script.push('<action mouvement=\"pause\" />');\n  };\n  /**\n  **************************\n  ******* CODAGES **********\n  **************************\n  */\n\n  /**\n   *\n   * @param {segment/point} Segment à coder ou première extrémité\n   * @param {objet/point} options ou deuxième extrémité\n   * @param {objet} options si les deux premiers arguments étaient des points. Défaut : { tempo: this.tempo, couleur: this.couleurCodage, codage: '//', }\n   * @return {id}\n  */\n\n\n  this.segmentCodage = function (arg1, arg2 = {}, arg3 = {}) {\n    let s;\n    let options = {};\n\n    if (arg1.typeObjet === 'segment') {\n      s = arg1;\n      options = arg2;\n    } else {\n      s = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.segment)(arg1, arg2);\n      options = { ...arg3\n      };\n    }\n\n    if (options.tempo === undefined) {\n      options.tempo = this.tempo;\n    }\n\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage;\n    }\n\n    if (options.codage === undefined) {\n      options.codage = '\\\\';\n    }\n\n    this.idIEP++;\n    const id = this.idIEP;\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(s.extremite1, s.extremite2);\n    const codeXML = `<action abscisse=\"${this.x(M)}\" ordonnee=\"${this.y(M)}\" forme=\"${options.codage}\"  couleur=\"${options.couleur}\" id=\"${id}\" tempo=\"${options.tempo}\" mouvement=\"creer\" objet=\"longueur\" />`;\n    this.liste_script.push(codeXML);\n    return id;\n  };\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.segmentCodageMasquer = function (id, {\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"longueur\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   *\n   * @param {int} id Identifiant du codage\n   * @param {objet} options Défaut : { tempo: this.tempo }\n   */\n\n\n  this.segmentCodageMontrer = function (id, {\n    tempo = this.tempo\n  } = {}) {\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"longueur\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   * Trace le petit carré au crayon\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : {longueur : 0.3, couleur: this.couleurCodage}\n   * @return {array} [idTrait1, idTrait2]\n   */\n\n\n  this.codageAngleDroit = function (A, B, C, options = {}) {\n    this.crayonMontrer();\n\n    if (options.longueur === undefined) {\n      options.longueur = 0.3;\n    }\n\n    if (options.couleur === undefined) {\n      options.couleur = this.couleurCodage;\n    }\n\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, C, options.longueur);\n    const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, options.longueur);\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(A1, B, C1);\n    const options1 = { ...options\n    }; // On recopie options pour ouvoir en changer le tempo du premier tracé\n\n    options1.tempo = 0;\n    const trait1 = this.trait(C1, M, options1);\n    const trait2 = this.trait(M, A1, options);\n    return [trait1, trait2];\n  };\n  /**\n   * Masque le codage d'un angle droit\n   * @param {int} id Identifiant du codage d'un angle droit\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n\n\n  this.codageAngleDroitMasquer = function (id, {\n    tempo = 0\n  } = {}) {\n    this.traitMasquer(id[0], {\n      tempo: tempo\n    });\n    this.traitMasquer(id[1], {\n      tempo: tempo\n    });\n  };\n  /**\n   * Code un angle. L'option codage peut être \"simple\", \"/\", \"//\", \"///\", \"O\"\n   * \"double\", \"double/\", \"double//\", \"double///\", \"doubleO\"\n   * \"triple\", \"triple/\", \"triple//\", \"triple///\", \"tripleO\"\n   * \"plein\", \"plein/\", \"plein//\", \"plein///\", \"pleinO\"\n   * @param {point} A Point sur un côté de l'angle\n   * @param {point} B Sommet de l'angle\n   * @param {point} C Point sur un côté de l'angle\n   * @param {objet} options Défaut : { rayon : 1, couleur: this.couleurCodage, codage: 'plein'}\n   * @return {id} L'identifiant correspond à l'identifiant des 3 points de l'angle séparés par _\n   */\n\n\n  this.angleCodage = function (B, A, C, {\n    couleur = this.couleurCodage,\n    codage = 'plein',\n    rayon = 1,\n    tempo = this.tempo\n  } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id;\n    const d1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    const d2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, C);\n    d1.isVisible = false;\n    d2.isVisible = false;\n    const angle1 = -d1.angleAvecHorizontale;\n    const angle2 = -d2.angleAvecHorizontale;\n    const codeXML = `<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" rayon=\"${rayon * 30}\" angle1=\"${angle1}\" angle2=\"${angle2}\" forme=\"${codage}\"  couleur=\"${couleur}\" id=\"${id}\" tempo=\"${tempo}\" mouvement=\"creer\" objet=\"angle\" />`;\n    this.liste_script.push(codeXML);\n    return id;\n  };\n  /**\n   * Masque un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n\n\n  this.angleCodageMasquer = function (B, A, C, {\n    tempo = 0\n  } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id;\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"masquer\" objet=\"angle\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   * Montre un codage préalablement créé\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {objet} options Défaut { tempo: 0 }\n   */\n\n\n  this.angleCodageMontrer = function (B, A, C, {\n    tempo = 0\n  } = {}) {\n    const id = B.id + '_' + A.id + '_' + C.id;\n    this.liste_script.push(`<action id=\"${id}\" mouvement=\"montrer\" objet=\"angle\" tempo=\"${tempo}\" />`);\n  };\n  /**\n   * Affiche une image (donnée par son URL) au point A\n   * @param {string} url\n   * @returns {id}\n   */\n\n\n  this.image = function (url, A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(0, 0)) {\n    this.idIEP++;\n    let codeXML;\n    codeXML = `<action id=\"${this.idIEP}\" url=\"${url}\" mouvement=\"chargement\" objet=\"image\" />`;\n    codeXML += `\\n<action abscisse=\"${this.x(A)}\" ordonnee=\"${this.y(A)}\" id=\"${this.idIEP}\" mouvement=\"translation\" objet=\"image\" vitesse=\"100000\" />`;\n    this.liste_script.push(codeXML);\n    return this.idIEP;\n  };\n  /**\n  *****************************************\n  ********* MACROS-CONSTRUCTIONS **********\n  *****************************************\n  */\n\n  /**\n   * Trace la parallèle à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {*} options\n   */\n\n\n  this.paralleleRegleEquerre2points3epoint = function (A, B, C, options) {\n    let G, D, H1; // G est le point le plus à gauche, D le plus à droite et H le projeté de C sur (AB)\n    // H1 est un point de (AB) à gauche de H, c'est là où seront la règle et l'équerre avant de glisser\n\n    if (A.x < B.x) {\n      G = A;\n      D = B;\n    } else {\n      G = B;\n      D = A;\n    }\n\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d);\n\n    if (H.x < D.x) {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, D, -2); // H1 sera plus à gauche que H\n    } else if (H.x > D.x) {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, D, 2);\n    } else {\n      H1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(H, G, 2);\n    }\n\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(H1, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtParallele)(C, d)); // C1 est le point d'arrivée de l'équerre après avoir glissé\n\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(C1, C, 6); // Le tracé de la parallèle ne fera que 6 cm pour ne pas dépassr de l'équerre. M est la fin de ce tracé\n\n    if (H.x < G.x && (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, G) > 3) {\n      // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G);\n      this.regleMasquer();\n    }\n\n    if (H.x > D.x && (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, D) > 3) {\n      // Si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(G, D);\n    }\n\n    this.equerreMontrer(H1);\n\n    if (M.x > C1.x) {\n      this.equerreRotation(d.angleAvecHorizontale - 90);\n    } else {\n      this.equerreRotation(d.angleAvecHorizontale + 90);\n    }\n\n    if (H1.y > C1.y) {\n      if (this.regle.visibilite) {\n        this.regleDeplacer(H1, {\n          vitesse: this.vitesse,\n          tempo: 0\n        });\n        this.regleRotation(C1, {\n          sens: this.vitesse / 2,\n          tempo: 0\n        });\n      } else {\n        this.regleDeplacer(H1, {\n          vitesse: 1000,\n          tempo: 0\n        });\n        this.regleRotation(C1, {\n          sens: 1000,\n          tempo: 0\n        });\n      }\n    } else {\n      const C12 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(C1, H1, -2); // On monte un peu plus la règle pour que ça soit plus crédible\n\n      if (this.regle.visibilite) {\n        this.regleDeplacer(C12, {\n          vitesse: this.vitesse,\n          tempo: 0\n        });\n        this.regleRotation(H1, {\n          sens: this.vitesse / 2,\n          tempo: 0\n        });\n      } else {\n        this.regleDeplacer(C12, {\n          vitesse: 1000,\n          tempo: 0\n        });\n        this.regleRotation(H1, {\n          sens: 1000,\n          tempo: 0\n        });\n      }\n    }\n\n    this.regleMontrer();\n    this.equerreDeplacer(C1, options);\n    this.crayonMontrer();\n    this.crayonDeplacer(C1, options);\n    this.tracer(M, options);\n  };\n  /**\n     * Trace la perpendiculaire à (AB) passant par C avec la règle et l'équerre. Peut prolonger le segment [AB] si le pied de la hauteur est trop éloigné des extrémités du segment\n     * @param {point} A\n     * @param {point} B\n     * @param {point} C\n     * @param {*} options\n     */\n\n\n  this.perpendiculaireRegleEquerre2points3epoint = function (A, B, C, options) {\n    const longueurRegle = this.regle.longueur;\n    const zoomEquerre = this.equerre.zoom;\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    let dist;\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.appartientDroite)(C, A, B)) {\n      dist = 7.5;\n    } else {\n      const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d);\n      dist = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(H, C) + 2;\n    }\n\n    this.equerreZoom((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(dist * 100 / 7.5));\n    this.regleModifierLongueur(Math.max(dist * 2, 15));\n    this.perpendiculaireRegleEquerreDroitePoint(d, C);\n    this.equerreZoom(zoomEquerre);\n    this.regleModifierLongueur(longueurRegle);\n  };\n\n  this.perpendiculaireRegleEquerreDroitePoint = function (d, P) {\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(P, d);\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(P, H, 90);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, H, 180);\n    const alpha = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(10000, H.y), H, B);\n    this.equerreRotation(alpha);\n    this.equerreMontrer(H);\n    this.regleSegment(H, P);\n    this.equerreMasquer();\n    this.codageAngleDroit(A, H, P);\n    this.regleProlongerSegment(P, H, {\n      longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(P, H) * 2\n    });\n  };\n  /**\n  *****************************************\n  ********* DROITES REMARQUABLES **********\n  *****************************************\n  */\n\n  /**\n  * Trace la médiatrice de [AB] au compas. Le paramétrage des longueurs correspond à la distance entre le milieu du segment et le point d'intersection des arcs de cercles\n  *\n  * @param {point} A\n  * @param {point} B\n  * @param {objet} options Défaut : {longueur1: 3, longueur2: 3, codage: 'X', couleurCodage : this.couleurCodage, couleurCompas: this.couleurCompas}\n  * @return {array} [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre]\n  */\n\n\n  this.mediatriceAuCompas = function (A, B, options = {}) {\n    if (options.longueur1 === undefined) {\n      options.longueur1 = 3;\n    }\n\n    if (options.longueur2 === undefined) {\n      options.longueur2 = -3;\n    }\n\n    if (options.codage === undefined) {\n      options.codage = 'X';\n    }\n\n    if (options.couleurCodage === undefined) {\n      options.couleurCodage = this.couleurCodage;\n    }\n\n    if (options.couleurCompas === undefined) {\n      options.couleurCompas = this.couleurCompas;\n    }\n\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B);\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90);\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, options.longueur1);\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, options.longueur2);\n    this.compasMontrer();\n    this.compasDeplacer(A, options);\n    let arc1, arc2, arc3, arc4;\n\n    if (options.longueur1 === -1 * options.longueur2) {\n      // Si la distance est la même des deux côtés, on peut faire les arcs de part et d'autre\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, M), {\n        vitesse: options.vitesse,\n        sens: options.vitesse\n      });\n      arc1 = this.compasTracerArcCentrePoint(A, M, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc2 = this.compasTracerArcCentrePoint(A, N, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc3 = this.compasTracerArcCentrePoint(B, M, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc4 = this.compasTracerArcCentrePoint(B, N, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n    } else {\n      this.compasEcarter((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, M), options);\n      arc1 = this.compasTracerArcCentrePoint(A, M, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc2 = this.compasTracerArcCentrePoint(B, M, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc3 = this.compasTracerArcCentrePoint(B, N, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n      arc4 = this.compasTracerArcCentrePoint(A, N, {\n        delta: options.delta,\n        couleur: options.couleurCompas,\n        sens: options.sens,\n        vitesse: options.vitesse,\n        tempo: options.tempo\n      });\n    }\n\n    this.compasMasquer();\n\n    if (M.x <= N.x) {\n      this.regleDroite(M, N, options);\n    } else {\n      this.regleDroite(N, M, options);\n    }\n\n    this.regleMasquer();\n    const codage1 = this.segmentCodage(A, O, {\n      codage: options.codage,\n      couleur: options.couleurCodage,\n      tempo: options.tempo\n    });\n    const codage2 = this.segmentCodage(O, B, {\n      codage: options.codage,\n      couleur: options.couleurCodage,\n      tempo: options.tempo\n    });\n    const codageCarre = this.codageAngleDroit(A, O, O2, {\n      couleur: options.couleurCodage,\n      tempo: options.tempo,\n      vitesse: options.vitesse\n    });\n    return [arc1, arc2, arc3, arc4, codage1, codage2, codageCarre];\n  };\n  /**\n   * Trace la médiatrice du segment [AB] avec la méthode Règle + équerre.\n   * @param {point} A\n   * @param {point} B\n   * @param {booléen} codage\n   */\n\n\n  this.mediatriceRegleEquerre = function (A, B, codage = 'X') {\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B);\n    this.regleMontrer();\n    this.regleDeplacer(A);\n    this.regleRotation(B);\n    this.crayonMontrer();\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90);\n    const O3 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, 90);\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, 0.2);\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O3, 0.2);\n\n    if (this.y(M) > this.y(N)) {\n      this.trait(O, M);\n    } else {\n      this.trait(O, N);\n    }\n\n    this.regleMasquer();\n\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A);\n      this.equerreMontrer();\n      this.equerreRotation(B);\n    } else {\n      this.equerreDeplacer(B);\n      this.equerreMontrer();\n      this.equerreRotation(A);\n    }\n\n    this.equerreDeplacer(O);\n    this.crayonDeplacer(O);\n    this.trait(O, O2);\n    this.equerreMasquer();\n    this.regleDroite(O2, O3);\n    this.regleMasquer();\n    this.segmentCodage(A, O, codage);\n    this.segmentCodage(O, B, codage);\n    this.codageAngleDroit(A, O, O2);\n  };\n  /**\n   * Trace la hauteur issue de C dans un triangle ABC. Prolonge si besoin le segment [AB] pour avoir le pied de la hauteur et le codage de l'angle droit.\n   * @param {point} A 1er point de la base\n   * @param {point} B 2e point de la base\n   * @param {point} C Sommet dont est issue la hauteur\n   * @param {booléen} codage angle droit ajouté si true\n   */\n\n\n  this.hauteur = function (A, B, C, codage = true) {\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    d.isVisible = false;\n    const H = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.projectionOrtho)(C, d);\n    let G, D;\n\n    if (this.x(A) < this.x(B)) {\n      G = A;\n      D = B;\n    } else {\n      G = B;\n      D = A;\n    }\n\n    if (this.x(H) < this.x(G)) {\n      // si le pied de la hauteur est trop à gauche\n      this.regleProlongerSegment(D, G, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(G, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true);\n    }\n\n    if (this.x(H) > this.x(D)) {\n      // si le pied de la hauteur est trop à droite\n      this.regleProlongerSegment(G, D, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(D, H) + 2, this.couleur, this.tempo, this.vitesse, this.epaisseurTraitsDeConstruction, true);\n    }\n\n    if (this.x(H) < this.x(G) || this.x(H) > this.x(D)) {\n      this.regleMasquer();\n    }\n\n    if (this.x(A) < this.x(B)) {\n      this.equerreDeplacer(A);\n      this.equerreMontrer();\n      this.equerreRotation(B);\n    } else {\n      this.equerreDeplacer(B);\n      this.equerreMontrer();\n      this.equerreRotation(A);\n    }\n\n    this.equerreDeplacer(H);\n    this.crayonMontrer();\n    this.crayonDeplacer(H);\n    this.trait(H, C);\n    this.equerreMasquer();\n\n    if (codage) {\n      this.codageAngleDroit(A, H, C);\n    }\n\n    this.crayonMasquer();\n  };\n  /**\n  * Trace la médiane issue de C passant par le milieu de [AB]\n  * @param {point} A\n  * @param {point} B\n  * @param {point} C\n  * @param {objet} options\n  */\n\n\n  this.mediane = function (A, B, C, options = {}) {\n    if (options.codage === undefined) {\n      options.codage = 'X';\n    }\n\n    if (options.couleurTraitsDeConstruction === undefined) {\n      options.couleurTraitsDeConstruction = this.couleurTraitsDeConstruction;\n    }\n\n    if (options.epaisseurTraitsDeConstruction === undefined) {\n      options.epaisseurTraitsDeConstruction = this.epaisseurTraitsDeConstruction;\n    }\n\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(A, B);\n    this.regleMontrer(A, options);\n    this.regleRotation(B, options);\n    this.crayonMontrer();\n    const O2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, -90);\n    const O3 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, O, 90);\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O2, 0.2);\n    const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(O, O3, 0.2);\n\n    if (M.y > N.y) {\n      this.trait(O, M, {\n        vitesse: options.vitesse,\n        tempo: options.tempo,\n        couleur: options.couleurTraitsDeConstruction,\n        epaisseur: options.epaisseurTraitsDeConstruction\n      });\n    } else {\n      this.trait(O, N, {\n        vitesse: options.vitesse,\n        tempo: options.tempo,\n        couleur: options.couleurTraitsDeConstruction,\n        epaisseur: options.epaisseurTraitsDeConstruction\n      });\n    }\n\n    this.regleSegment(O, C, options);\n\n    if (options.codage) {\n      this.segmentCodage(A, O, options);\n      this.segmentCodage(O, B, options);\n    }\n  };\n  /**\n  * Trace la bissectrice de l'angle ABC au compas.\n  * @param {point} A\n  * @param {point} B\n  * @param {point} C\n  * @param {objet} param3\n  * @returns {objet} {arc1, arc2, arc3, arc4}\n  */\n\n\n  this.bissectriceAuCompas = function (A, B, C, {\n    codage = '/',\n    l = 2,\n    couleur = this.couleur,\n    tempo = this.tempo,\n    vitesse = this.vitesse,\n    sens = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(this.vitesse / 2, 0),\n    epaisseur = this.epaisseur,\n    pointilles = this.pointilles,\n    couleurCodage = this.couleurCodage,\n    masquerTraitsDeConstructions = true\n  } = {}) {\n    const A1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, A, l);\n    const C1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, C, l); // const demiangle = calcul(angleOriente(A, B, C) / 2);\n\n    const angle = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.angleOriente)(A, B, C);\n    const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A1, -(180 - angle));\n    const options = {\n      couleur: couleur,\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens,\n      pointilles: false\n    };\n    const arc1 = this.compasTracerArcCentrePoint(B, A1, options);\n    const arc2 = this.compasTracerArcCentrePoint(B, C1, options);\n    const arc3 = this.compasTracerArcCentrePoint(A1, M, options);\n    const arc4 = this.compasTracerArcCentrePoint(C1, M, options);\n    this.compasMasquer();\n    this.regleDemiDroiteOriginePoint(B, M, {\n      longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, A),\n      couleur: couleur,\n      tempo: tempo,\n      vitesse: vitesse,\n      sens: sens,\n      epaisseur: epaisseur,\n      pointilles: pointilles\n    });\n    this.regleMasquer();\n    this.crayonMasquer();\n\n    if (codage) {\n      this.angleCodage(A, B, M, {\n        couleur: couleurCodage,\n        codage: codage,\n        tempo: tempo\n      });\n      this.angleCodage(M, B, C, {\n        couleur: couleurCodage,\n        codage: codage,\n        tempo: tempo\n      });\n    }\n\n    if (masquerTraitsDeConstructions) {\n      this.traitMasquer(arc1);\n      this.traitMasquer(arc2);\n      this.traitMasquer(arc3);\n      this.traitMasquer(arc4);\n    }\n\n    return {\n      arc1: arc1,\n      arc2: arc2,\n      arc3: arc3,\n      arc4: arc4\n    };\n  };\n  /**\n  * Construit les 3 médiatrices des côtés du triangle ABC puis le cercle circonscrit au triangle\n  * @param {point} A\n  * @param {point} B\n  * @param {point} C\n  * @param {objet} options\n  */\n\n\n  this.cercleCirconscrit = function (A, B, C, options = {}) {\n    if (options.couleur === undefined) {\n      options.couleur = this.couleur;\n    }\n\n    if (options.couleurMediatrice === undefined) {\n      options.couleurMediatrice = options.couleur;\n    }\n\n    if (options.couleurCercle === undefined) {\n      options.couleurCercle = options.couleur;\n    }\n\n    options.codage = 'X';\n    options.couleur = options.couleurMediatrice;\n    const m1 = this.mediatriceAuCompas(A, B, options);\n    this.traitMasquer(m1[0]); // On cache les arcs de cercle une fois la médiatrice tracée\n\n    this.traitMasquer(m1[1]);\n    this.traitMasquer(m1[2]);\n    this.traitMasquer(m1[3]);\n    options.codage = '||';\n    const m2 = this.mediatriceAuCompas(B, C, options);\n    this.traitMasquer(m2[0]);\n    this.traitMasquer(m2[1]);\n    this.traitMasquer(m2[2]);\n    this.traitMasquer(m2[3]);\n    options.codage = '///';\n    const m3 = this.mediatriceAuCompas(A, C, options);\n    this.traitMasquer(m3[0]);\n    this.traitMasquer(m3[1]);\n    this.traitMasquer(m3[2]);\n    this.traitMasquer(m3[3]);\n    const O = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.centreCercleCirconscrit)(A, B, C);\n    options.couleur = options.couleurCercle;\n    this.compasCercleCentrePoint(O, A, options);\n  };\n  /**\n  *****************************************\n  ************** TRIANGLES ****************\n  *****************************************\n  */\n\n  /**\n   * Macro de construction d'un triangle à partir de ses 3 dimensions. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BC Distance entre le 2e et le 3e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n\n\n  this.triangle3longueurs = function (ABC, AB, AC, BC, description = true) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20));\n    const p = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.triangle2points2longueurs)(A, B, AC, BC);\n    const C = p.listePoints[2];\n\n    if (ABC.length !== 3) {\n      description = false;\n    } else {\n      A.nom = ABC[0];\n      B.nom = ABC[1];\n      C.nom = ABC[2];\n    }\n\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2);\n    this.pointCreer(A); // this.regleRotation(droite(A,B).angleAvecHorizontale)\n    // this.regleMontrer(A)\n\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    this.crayonMasquer();\n    if (description) this.textePosition(`${A.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm.`, 0, -3);\n    this.couleur = 'forestgreen';\n    this.epaisseur = 2;\n    this.compasMontrer(A);\n    this.compasEcarterAvecRegle(AC);\n    this.compasTracerArcCentrePoint(A, C, 40);\n    if (description) this.textePosition(`${B.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm donc ${C.nom} appartient au cercle de centre ${B.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm.`, 0, -4);\n    this.compasDeplacer(B);\n    this.compasEcarterAvecRegle(BC);\n    this.compasTracerArcCentrePoint(B, C);\n    this.compasMasquer();\n    this.couleur = 'blue';\n    this.epaisseur = 3;\n    if (description) this.textePosition(`Le point ${C.nom} est à une intersection des deux cercles.`, 0, -5);\n    this.pointCreer(C);\n    this.regleSegment(B, C);\n    this.regleSegment(C, A);\n    this.crayonMasquer();\n    this.regleMasquer();\n    return [A, B, C];\n  };\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur d'un côté et de la longueur de l'hypoténuse.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n\n\n  this.triangleRectangleCoteHypotenuse = function (ABC, AB, AC, description = true) {\n    // Triangle rectangle en B\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20));\n    const dAB = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    dAB.isVisible = false;\n    const dBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtPerpendiculaire)(B, dAB);\n    dBC.isVisible = false;\n    const cAC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.cercle)(A, AC);\n    cAC.isVisible = false;\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionLC)(dBC, cAC);\n    const c = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(C, B, 1.2);\n\n    if (ABC.length !== 3) {\n      description = false;\n    } else {\n      A.nom = ABC[0];\n      B.nom = ABC[1];\n      C.nom = ABC[2];\n    }\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 8) this.equerreZoom(150);\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2);\n    this.equerreRotation(dAB.angleAvecHorizontale);\n    this.pointCreer(A);\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3);\n    this.equerreMontrer(A);\n    this.equerreDeplacer(B);\n    this.tracer(c);\n    this.equerreMasquer();\n    this.codageAngleDroit(A, B, C);\n    this.crayonMasquer();\n    if (description) this.textePosition(`${A.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm donc ${C.nom} appartient au cercle de centre ${A.nom} et de rayon ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AC)} cm.`, 0, -4);\n    this.compasMontrer(A);\n    this.compasEcarterAvecRegle(AC);\n    this.couleur = 'forestgreen';\n    this.epaisseur = 2;\n    this.compasTracerArcCentrePoint(A, C);\n    this.couleur = 'blue';\n    this.epaisseur = 2;\n    if (description) this.textePosition(`${C.nom} est à une intersection de la perpendiculaire et du cercle.`, 0, -5);\n    this.crayonMontrer(C);\n    this.pointCreer(C);\n    this.compasMasquer();\n    this.regleSegment(A, C);\n    this.regleMasquer();\n    this.crayonMasquer();\n    return [A, B, C];\n  };\n  /**\n   * Macro de construction d'un triangle rectangle (l'angle droit est le 2e point dans l'ordre du nom)\n   *  à partir de la donnée de la longueur des deux côtés de l'angle droit.\n   *  Le premier sommet aura pour coordonnées (6, 0)\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet (hypoténuse)\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n\n\n  this.triangleRectangle2Cotes = function (ABC, AB, BC, description = true) {\n    // Triangle rectangle en B\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20));\n    const dAB = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B);\n    dAB.isVisible = false;\n    const dBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droiteParPointEtPerpendiculaire)(B, dAB);\n    dBC.isVisible = false;\n    const cBC = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.cercle)(B, BC);\n    cBC.isVisible = false;\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionLC)(dBC, cBC);\n    const c = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(C, B, 1.2);\n\n    if (ABC.length !== 3) {\n      description = false;\n    } else {\n      A.nom = ABC[0];\n      B.nom = ABC[1];\n      C.nom = ABC[2];\n    }\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 8) this.equerreZoom(150);\n    if (description) this.textePosition(`${A.nom + B.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm`, 0, -2);\n    this.equerreRotation(dAB.angleAvecHorizontale);\n    this.pointCreer(A);\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    if (description) this.textePosition(`${A.nom + B.nom + C.nom} est un triangle rectangle en ${B.nom} donc ${C.nom} appartient à la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -3);\n    this.equerreMontrer(A);\n    this.equerreDeplacer(B);\n    this.tracer(c);\n    this.equerreMasquer();\n    this.codageAngleDroit(A, B, C);\n    if (description) this.textePosition(`${B.nom + C.nom} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm donc ${C.nom} est à ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(BC)} cm de ${B.nom} sur la perpendiculaire à (${A.nom + B.nom}) passant par ${B.nom}.`, 0, -4);\n    this.regleMontrer(B);\n    this.regleRotation(C);\n    this.crayonDeplacer(C);\n    this.pointCreer(C);\n    this.couleur = 'blue';\n    this.epaisseur = 2;\n    this.compasMasquer();\n    this.regleSegment(A, C);\n    this.regleMasquer();\n    this.crayonMasquer();\n    return [A, B, C];\n  };\n  /**\n   * Macro de construction d'un triangle à partir d'une longueur et des 2 angles adajcents au côté connu. Le premier point aura pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {*} CBA Angle au 2e sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n\n\n  this.triangle1longueur2angles = function (NOM, AB, BAC, CBA, description = true, mesure = false) {\n    const angle = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20);\n    const a1 = BAC;\n    const a2 = CBA;\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, angle);\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, 5.2, a1 + angle);\n    const D2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, 10);\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, D2, 0.4);\n    const E = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(B, 3, 180 - a2 + angle);\n    const E2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(B, E, 10);\n    const E1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(E, E2, -0.4);\n    const F = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(B, 5.2, 180 - a2 + angle);\n    const F1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(F, E2, 0.4);\n    const d = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(A, B), A, a1);\n    D.isVisible = false;\n    const d2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.droite)(B, A), B, -a2);\n    d2.isVisible = false;\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointIntersectionDD)(d, d2);\n\n    if (NOM.length !== 3) {\n      description = false;\n    } else {\n      A.nom = NOM[0];\n      B.nom = NOM[1];\n      C.nom = NOM[2];\n    }\n\n    this.couleur = 'blue';\n    this.epaisseur = 3;\n    this.pointCreer(A);\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm.`, 0, -4);\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    this.couleur = 'grey';\n    this.epaisseur = 1;\n    this.rapporteurMontrer(A);\n    this.rapporteurDeplacer(A);\n    this.rapporteurRotation(angle);\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5);\n    this.epaisseur = 3;\n    this.trait(D, D1, 20);\n    this.epaisseur = 1;\n    this.rapporteurMasquer();\n    this.regleSegment(A, D2);\n    this.regleMasquer();\n    this.angleCodage(B, A, C);\n    this.rapporteurMontrer(A);\n    this.rapporteurDeplacer(B);\n    if (description) this.textePosition(`On place un repère à ${a2} degrés pour tracer la demi-droite [${B.nom + C.nom}).`, 0, -6);\n    this.epaisseur = 3;\n    this.trait(E, E1, 10);\n    this.trait(F, F1, 20);\n    this.epaisseur = 1;\n    this.rapporteurMasquer();\n    this.regleMontrer(B);\n    this.regleSegment(B, E2);\n    this.angleCodage(C, B, A);\n    this.pointCreer(C, '', 0);\n    this.pointNommer(C, C.nom, -0.5, 1);\n    this.couleur = 'blue';\n    this.epaisseur = 3;\n    this.regleSegment(B, C);\n    this.regleSegment(C, A);\n    this.regleMasquer();\n    this.crayonMasquer();\n    if (description && mesure) this.textePosition(`On peut mesurer ${A.nom + C.nom} ≈ ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C, 1))} cm et ${B.nom + C.nom} ≈ ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, C, 1))} cm.`, 0, -7);\n    return [A, B, C];\n  };\n  /**\n   * Macro de construction d'un triangle à partir des longueurs des deux côtés d'un angle Le premier point a pour coordonnées (6,0).\n   * @param {string} ABC Une chaine de caractère de 3 lettre\n   * @param {*} AB Distance entre le 1er et le 2e sommet\n   * @param {*} AC Distance entre le 1er et le 3e sommet\n   * @param {*} BAC Angle au 1er sommet\n   * @param {boolean} description Affichage d'un texte descriptif des étapes de la construction\n   * @return {array} [A, B, C] les 3 sommets du triangle (objets MathALEA2D)\n   */\n\n\n  this.triangle2longueurs1angle = function (NOM, AB, AC, BAC, description = true, mesure = false) {\n    const angle = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20);\n    const a1 = BAC;\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, angle);\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, 5.2, a1 + angle);\n    const D2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, 10);\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, D2, 0.4);\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D2, AC);\n\n    if (NOM.length !== 3) {\n      description = false;\n    } else {\n      A.nom = NOM[0];\n      B.nom = NOM[1];\n      C.nom = NOM[2];\n    }\n\n    this.couleur = 'blue';\n    this.epaisseur = 3;\n    this.pointCreer(A);\n    if (description) this.textePosition(`On trace le côté [${A.nom + B.nom}] de ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.nombre_avec_espace)(AB)} cm.`, 0, -4);\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    this.couleur = 'grey';\n    this.epaisseur = 1;\n    this.rapporteurMontrer(A);\n    this.rapporteurDeplacer(A);\n    this.rapporteurRotation(angle);\n    if (description) this.textePosition(`On place un repère à ${a1} degrés pour tracer la demi-droite [${A.nom + C.nom}).`, 0, -5);\n    this.epaisseur = 3;\n    this.trait(D, D1, 20);\n    this.epaisseur = 1;\n    this.rapporteurMasquer();\n    this.regleSegment(A, D2);\n    this.angleCodage(B, A, C);\n    this.rapporteurMasquer();\n    if (description) this.textePosition(`On place le point ${C.nom} sur la demi-droite [${A.nom + C.nom}) à ${AC} cm de ${A.nom}.`, 0, -6);\n    this.epaisseur = 3;\n    this.couleur = 'blue';\n    this.crayonDeplacer(C);\n    this.pointCreer(C);\n    this.regleSegment(A, C);\n    this.crayonMasquer();\n    if (description) this.textePosition(`On trace le côté [${B.nom + C.nom}].`, 0, -7);\n    this.regleMontrer(C);\n    this.crayonMontrer(C);\n    this.regleSegment(C, B);\n    this.regleMasquer();\n    this.crayonMasquer();\n    return [A, B, C];\n  };\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de 2 points\n   * @param {point} A\n   * @param {point} B\n   * @param {string} nomC\n   * @return {array} [A, B, C]\n   */\n\n\n  this.triangleEquilateral2Sommets = function (A, B, nomC = '') {\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 60);\n    C.nom = nomC;\n    this.traitRapide(A, B);\n    this.pointCreer(A, A.nom, 0);\n    this.pointCreer(B, B.nom, 0);\n    this.compasEcarter2Points(A, B);\n    this.compasTracerArcCentrePoint(A, C);\n    this.compasTracerArcCentrePoint(B, C);\n    this.pointCreer(C);\n    this.compasMasquer();\n    this.regleSegment(A, C);\n    this.regleSegment(C, B);\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.segmentCodage(A, B);\n    this.segmentCodage(A, C);\n    this.segmentCodage(B, C);\n    return [A, B, C];\n  };\n  /**\n   * Trace un triangle équilatéral à partir de la donnée de la longueur du côté. Le premier point a pour coordonnées (6;0)\n   * @param {string} NOM\n   * @param {number} AB\n   * @return {array} [A, B, C]\n   */\n\n\n  this.triangleEquilateral = function (NOM, AB) {\n    const A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(6, 0);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, AB, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20));\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 60);\n\n    if (NOM.length === 3) {\n      A.nom = NOM[0];\n      B.nom = NOM[1];\n      C.nom = NOM[2];\n    }\n\n    this.regleSegment(A, B);\n    this.pointCreer(A);\n    this.pointCreer(B);\n    this.compasEcarter2Points(A, B);\n    this.compasTracerArcCentrePoint(A, C);\n    this.compasTracerArcCentrePoint(B, C);\n    this.pointCreer(C);\n    this.compasMasquer();\n    this.regleSegment(A, C);\n    this.regleSegment(C, B);\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.segmentCodage(A, B);\n    this.segmentCodage(A, C);\n    this.segmentCodage(B, C);\n    return [A, B, C];\n  };\n  /**\n  ************************************************\n  ************** PARALLELOGRAMMES ****************\n  ************************************************\n  */\n\n  /**\n   * Trace un parallélogramme à partir de la donnée de 3 sommets consécutifs\n   * @param {point} A\n   * @param {point} B\n   * @param {point} C\n   * @param {string} nomD\n   * @param {boolean} description\n   * @param {boolean} csDejaTraces À true (par défaut), les 2 côtés seront faits immédiatement, sinon, on les tracera à la règle.\n   */\n\n\n  this.parallelogramme3sommetsConsecutifs = function (A, B, C, nomD = '', description = true, csDejaTraces = true) {\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(C, B, A);\n    D.nom = nomD;\n    const xMin = Math.min(A.x, B.x, C.x, D.x);\n    const yMin = Math.min(A.y, B.y, C.y, D.y); // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n\n    this.traitRapide(A, B);\n    this.traitRapide(B, C);\n    this.pointCreer(A, A.nom, 0);\n    this.pointCreer(B, B.nom, 0);\n    this.pointCreer(C, C.nom, 0);\n    this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses côtés opposés sont de même longueur.`, xMin - 1, yMin - 1);\n    this.compasEcarter2Points(B, A);\n    this.textePosition(`${B.nom + A.nom} = ${C.nom + D.nom}`, xMin - 1, yMin - 2);\n    this.compasTracerArcCentrePoint(C, D);\n    this.compasEcarter2Points(B, C);\n    this.textePosition(`${B.nom + C.nom} = ${A.nom + D.nom}`, xMin - 1, yMin - 3);\n    this.compasTracerArcCentrePoint(A, D, 10);\n    this.pointCreer(D);\n    this.compasMasquer();\n    this.regleSegment(C, D);\n    this.regleSegment(D, A);\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.segmentCodage(A, B, {\n      codage: '///',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(D, C, {\n      codage: '///',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(B, C, {\n      codage: '//',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(A, D, {\n      codage: '//',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n  };\n  /**\n   * Trace le parallélogramme ABCD de centre O à partir de [AB] et O.\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   * @param {string} nomC\n   * @param {string} nomD\n   * @param {boolean} description\n   */\n\n\n  this.parallelogramme2sommetsConsecutifsCentre = function (A, B, O, nomC = '', nomD = '', description = true) {\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(O, A, O);\n    C.nom = nomC;\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(O, B, O);\n    D.nom = nomD;\n    const nom = A.nom + B.nom + C.nom + D.nom;\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) > 12 || (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, D) > 12) {\n      this.regleModifierLongueur(30);\n    }\n\n    const xMin = Math.min(A.x, B.x, C.x, D.x);\n    const yMin = Math.min(A.y, B.y, C.y, D.y); // const xMax = Math.max(A.x, B.x, C.x, D.x)\n    // const yMax = Math.max(A.y, B.y, C.y, D.y)\n\n    this.traitRapide(A, B);\n    this.pointCreer(A, {\n      tempo: 0\n    });\n    this.pointCreer(B, {\n      tempo: 0\n    });\n    this.pointCreer(O, {\n      tempo: 0\n    });\n\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + B.nom + C.nom + D.nom} est un parallélogramme donc ses diagonales se coupent en leur milieu.`, xMin - 1, yMin - 1);\n    }\n\n    this.pointilles = true;\n    this.epaisseur = 1;\n    this.couleur = this.couleurTraitsDeConstruction;\n    this.regleDemiDroiteOriginePoint(A, O, {\n      longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, C) + 3\n    });\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.compasEcarter2Points(A, O);\n\n    if (description && nom.length === 4) {\n      this.textePosition(`${A.nom + O.nom} = ${O.nom + C.nom}`, xMin - 1, yMin - 2);\n    }\n\n    this.pointilles = false;\n    this.compasTracerArcCentrePoint(O, C);\n    this.compasMasquer();\n    this.pointilles = true;\n    this.regleDemiDroiteOriginePoint(B, O, {\n      longueur: (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(B, D) + 3\n    });\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.pointilles = false;\n    this.compasEcarter2Points(B, O);\n\n    if (description && nom.length === 4) {\n      this.textePosition(`${B.nom + O.nom} = ${O.nom + D.nom}`, xMin - 1, yMin - 3);\n    }\n\n    this.compasTracerArcCentrePoint(O, D);\n    this.compasMasquer();\n    this.couleur = 'blue';\n    this.epaisseur = 3;\n    this.pointCreer(D);\n    this.regleSegment(A, D);\n    this.regleSegment(D, C);\n    this.regleSegment(C, B);\n    this.regleMasquer();\n    this.compasMasquer();\n    this.crayonMasquer();\n    this.segmentCodage(A, O, {\n      codage: '//',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(O, C, {\n      codage: '//',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(B, O, {\n      codage: 'O',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n    this.segmentCodage(O, D, {\n      codage: 'O',\n      couleur: this.couleurCodage,\n      tempo: 0\n    });\n  };\n  /**\n   * Trace la parallélogramme ABCD de centre O en partant de [AD), [AB) et O (mais sans voir la position de B et D au départ)\n   * @param {point} D\n   * @param {point} A\n   * @param {point} B\n   * @param {point} O\n   */\n\n\n  this.parallelogrammeAngleCentre = function (D, A, B, O) {\n    const B1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, B, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, B) + 2);\n    const D1 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, D) + 2);\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation2Points)(B, A, D);\n    this.traitRapide(A, B1);\n    this.traitRapide(A, D1);\n    this.pointCreer(O, {\n      tempo: 0\n    });\n    this.pointCreer(A, {\n      tempo: 0\n    });\n    this.regleDemiDroiteOriginePoint(A, O, {\n      couleur: this.couleurTraitsDeConstruction,\n      epaisseur: 1,\n      pointilles: true\n    });\n    this.pointilles = false;\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.compasEcarter2Points(A, O);\n    this.compasTracerArcCentrePoint(O, C, {\n      couleur: this.couleurTraitsDeConstruction\n    });\n    this.compasMasquer();\n    this.paralleleRegleEquerre2points3epoint(B1, A, C, {\n      couleur: this.couleurTraitsDeConstruction,\n      epaisseur: 1\n    });\n    this.equerreMasquer();\n    this.regleDroite(C, D, {\n      couleur: this.couleurTraitsDeConstruction,\n      epaisseur: 1\n    });\n    this.paralleleRegleEquerre2points3epoint(A, D1, C, {\n      couleur: this.couleurTraitsDeConstruction,\n      epaisseur: 1\n    });\n    this.equerreMasquer();\n    this.regleDroite(C, B, {\n      couleur: this.couleurTraitsDeConstruction,\n      epaisseur: 1\n    });\n    this.pointCreer(D, {\n      tempo: 0\n    });\n    this.pointCreer(B, {\n      tempo: 0\n    });\n    this.pointCreer(C, {\n      tempo: 0\n    });\n    this.regleSegment(B, C);\n    this.regleSegment(C, D);\n    this.regleMasquer();\n    this.crayonMasquer();\n  };\n  /**\n   ************************************************\n   ************** Carrés ****************\n   ************************************************\n   */\n\n  /**\n   * Macro crée par Sophie Desruelle\n   * @param {objet} A\n   * @param {number} c\n   * @returns polygoneAvecNom\n   */\n\n\n  this.carre1point1longueur = function (nom, A, c) {\n    const interligne = 1;\n    A = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.point)(5, 0, nom[0]);\n    const B = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointAdistance)(A, c, (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(-20, 20), nom[1]);\n    const C = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(A, B, -90, nom[2]);\n    const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(B, A, 90, nom[3]);\n    const E = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(A, D, c + 2, 'E');\n    const F = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.pointSurSegment)(D, C, c + 2, 'F');\n    this.equerreZoom((c + 3) * 100 / 7.5);\n    this.tempo = 20;\n    this.textePosition(`1) On veut construire un carré dont les côtés mesurent ${c} cm, donc on commence par tracer un segment, ici [${nom[0] + nom[1]}], de cette longueur.`, 0, -2);\n    this.pointCreer(A, {\n      tempo: 0\n    }); // On coupe la pause pour ne pas voir le déplacement du point\n\n    this.pointNommer(A, A.nom, {\n      dx: -0.5,\n      dy: 0\n    }); // On déplace le label du point A vers la gauche\n\n    this.regleSegment(A, B);\n    this.pointCreer(B);\n    this.regleMasquer();\n    this.longueurSegment(A, B, -1);\n    this.textePosition(`2) Un carré possède 4 angles droits, donc on trace la perpendiculaire à (${nom[0] + nom[1]}) passant par ${nom[0]}.`, 0, -2 - 1 * interligne);\n    this.equerreMontrer();\n    this.equerreDeplacer(A);\n    this.equerreRotation(B);\n    this.trait(A, E);\n    this.equerreMasquer();\n    this.codageAngleDroit(B, A, D);\n    this.textePosition(`3) Les 4 côtés d'un carré sont de la même longueur, donc on place le point ${nom[3]} sur cette perpendiculaire, à ${c} cm de ${nom[0]}.`, 0, -2 - 2 * interligne);\n    this.regleSegment(A, D);\n    this.pointCreer(D, {\n      tempo: 0\n    });\n    this.pointNommer(D, D.nom, {\n      dx: -0.7,\n      dy: 0.5\n    });\n    this.regleMasquer();\n    this.segmentCodage(A, B);\n    this.segmentCodage(A, D);\n    this.textePosition(`4) De même, on trace la perpendiculaire à (${nom[0] + nom[3]}) passant par ${nom[3]}, puis on place le point ${nom[2]} sur cette perpendiculaire, à ${c} cm de ${nom[3]}.`, 0, -2 - 3 * interligne);\n    this.equerreMontrer();\n    this.equerreDeplacer(D);\n    this.equerreRotation(A);\n    this.trait(D, F);\n    this.equerreMasquer();\n    this.codageAngleDroit(A, D, C);\n    this.regleSegment(D, C);\n    this.pointCreer(C, {\n      tempo: 0\n    });\n    this.pointNommer(C, C.nom, {\n      dx: 0,\n      dy: 0.9\n    });\n    this.regleMasquer();\n    this.segmentCodage(D, C);\n    this.textePosition(`5) On trace le segment [${nom[1] + nom[2]}].`, 0, -2 - 4 * interligne);\n    this.regleSegment(C, B);\n    this.regleMasquer();\n    this.segmentCodage(B, C);\n    this.textePosition(`6) On vérifie que ${nom[1] + nom[2]} = ${c} cm et que les deux derniers angles tracés sont droits.`, 0, -2 - 5 * interligne);\n    this.equerreMontrer(C, {\n      tempo: 0\n    });\n    this.equerreRotation(D);\n    this.equerreMasquer();\n    this.codageAngleDroit(D, C, B);\n    this.equerreMontrer(B, {\n      tempo: 0\n    });\n    this.equerreRotation(C);\n    this.equerreMasquer();\n    this.codageAngleDroit(C, B, A);\n    return (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.polygoneAvecNom)(A, B, C, D);\n  };\n  /********************************************/\n\n  /** *********** Transformations **************/\n\n  /********************************************/\n\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de la rotation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n\n\n  this.rotationPoint = function (p, centre, angle, nom, {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage,\n    codage = true\n  } = {}) {\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\";\n    }\n\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle, nom); // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n\n    this.regleSegment(centre, p); // On trace le support du rapporteur\n\n    this.rapporteurMontrer(centre);\n    this.rapporteurTracerDemiDroiteAngle(centre, p, angle); // On trace le deuxième côté\n\n    this.regleMasquer();\n    this.rapporteurMasquer();\n    this.compasEcarter2Points(centre, p); // on prend l'écartement du compas\n\n    this.compasTracerArcCentrePoint(centre, image); // On fait l'arc qui coupe la demi-droite\n\n    this.compasMasquer();\n    this.pointCreer(image, {\n      couleur: couleur,\n      couleurLabel: couleur\n    }); // On marque le point image (qui est nommé)\n\n    if (codage) {\n      if (Math.abs(angle) === 90) {\n        this.codageAngleDroit(p, centre, image, {\n          couleur: couleurCodage\n        });\n      } else {\n        this.angleCodage(p, centre, image, {\n          couleur: couleurCodage\n        });\n        this.textePoint(Math.abs(angle) + '°', (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle / 2), centre, 1.3 / (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, p)), (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(-0.2, 0.5)));\n      }\n    }\n  };\n  /**\n   *\n   * @param {objet} p point dont on construit l'image et qui doit être tracé.\n   * @param {objet} d axe de symétrie.\n   * @param {string} nom nom de l'image\n   * @param {objet} options couleur et couleurCodage\n   * @auteur Liouba Leroux et Jean-Claude Lhote\n   */\n\n\n  this.symetrieAxialePoint = function (p, d, nom, {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage,\n    codage = '//'\n  } = {}) {\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\";\n    }\n\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.symetrieAxiale)(p, d, nom); // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(p, image) !== 0) {\n      const M = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.milieu)(p, image); // on crée le point milieu\n\n      const N = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, M, 90);\n      const D = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(N, M, 180);\n      this.regleMasquerGraduations();\n      this.perpendiculaireRegleEquerre2points3epoint(N, D, p);\n      this.compasEcarter2Points(M, p);\n      this.compasTracerArcCentrePoint(M, image);\n      this.regleSegment(p, image);\n      this.regleMasquer();\n      this.equerreMasquer();\n      this.segmentCodage(p, M, {\n        codage: codage,\n        couleur: couleurCodage\n      });\n      this.segmentCodage(image, M, {\n        codage: codage,\n        couleur: couleurCodage\n      });\n      this.crayonMasquer();\n      this.compasMasquer();\n    }\n\n    this.pointCreer(image, {\n      couleur: couleur,\n      couleurLabel: couleur\n    }); // on construit l'image\n  };\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} le point de départ de la translation\n   * @param {objet} le point d'arrivée de la translation\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param4 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n\n\n  this.translationPoint = function (p, A, B, nom, {\n    couleur = 'black',\n    couleurCodage = this.couleurCodage\n  } = {}) {\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B);\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\";\n    }\n\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)(p, v, nom); // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n\n    if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(A, p) !== 0) {\n      // si le point de départ A est l'antécédent, alors le point d'arrivée B est l'image... pas besoin de construction\n      this.compasEcarter2Points(A, p);\n      this.compasTracerArcCentrePoint(B, image);\n      this.compasEcarter2Points(A, B);\n      this.compasTracerArcCentrePoint(p, image);\n    }\n\n    this.compasMasquer();\n    this.pointCreer(image, {\n      couleur: couleur,\n      couleurLabel: couleur\n    });\n    const choix1 = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(0, 4);\n    const choix2 = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.randint)(0, 4, choix1);\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\'];\n    const marque1 = marques[choix1];\n    const marque2 = marques[choix2];\n    this.couleur = 'green';\n    this.traitRapide(p, image);\n    this.traitRapide(A, B);\n    this.segmentCodage(p, image, {\n      codage: marque1,\n      couleur: couleurCodage\n    });\n    this.segmentCodage(A, B, {\n      codage: marque1,\n      couleur: couleurCodage\n    });\n    this.couleur = 'red';\n    this.traitRapide(B, image);\n    this.traitRapide(A, p);\n    this.segmentCodage(B, image, {\n      codage: marque2,\n      couleur: couleurCodage\n    });\n    this.segmentCodage(A, p, {\n      codage: marque2,\n      couleur: couleurCodage\n    });\n  };\n  /**\n   *\n   * @param {objet} p  le point dont on veut construire l'image\n   * @param {objet} centre le centre de symétrie\n   * @param {string} nom le nom de l'image (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur, couleurCodage et codage\n   * @Auteur Jean-Claude Lhote\n   */\n\n\n  this.demiTourPoint = function (p, centre, nom, {\n    couleur = 'black',\n    couleurCodage = this.couleurCodage,\n    codage = '//'\n  } = {}) {\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\";\n    }\n\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, 180, nom); // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n\n    this.compasEcarter2Points(centre, p);\n    this.compasTracerArcCentrePoint(centre, image);\n    this.compasMasquer();\n    this.crayonDeplacer(p);\n    this.regleSegment(p, image);\n    this.couleur = couleur;\n    this.epaisseur = 2;\n    this.pointCreer(image, {\n      couleur: couleur,\n      couleurLabel: couleur\n    }); // on construit l'image\n\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.segmentCodage(p, centre, {\n      codage: codage,\n      couleur: couleurCodage\n    });\n    this.segmentCodage(centre, image, {\n      codage: codage,\n      couleur: couleurCodage\n    });\n  };\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n\n\n  this.homothetiePoint = function (p, centre, k, nom, {\n    couleur = this.couleur,\n    positionTexte = {\n      x: 0,\n      y: 0\n    }\n  } = {}) {\n    this.epaisseur = 1; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    const couleurSave = this.couleur;\n    this.couleur = 'grey';\n    let t;\n\n    if (nom === undefined || nom === '') {\n      nom = p.nom + \"'\";\n    }\n\n    const image = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(p, centre, k, nom); // on définit le point image (pour le viser avec la règle on ajoute une apostrophe au nom)\n\n    if (k > 0) {\n      t = this.textePosition(`Comme le rapport est positif alors les points ${p.nom} et ${image.nom} sont du même côté de ${centre.nom}`, positionTexte.x, positionTexte.y, {\n        taille: 15\n      });\n    } else {\n      t = this.textePosition(`Comme le rapport est négatif alors ${centre.nom} est entre les points ${p.nom} et ${image.nom}`, positionTexte.x, positionTexte.y, {\n        taille: 15\n      });\n    }\n\n    this.regleSegment(p, centre);\n    const l = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(p, centre), 1);\n    const lprime = (0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.calcul)(l * Math.abs(k)));\n    const t1 = this.textePosition(`La mesure de ${centre.nom}${p.nom} est ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.texNombre)((0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.arrondi)(l, 1))} cm et le rapport de l'homothetie est ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.texNombre)(k)}`, positionTexte.x, positionTexte.y - 1, {\n      taille: 15\n    });\n    const t2 = this.textePosition(`donc ${centre.nom}${image.nom} mesure ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.texNombre)(l)} cm × ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.texNombre)(Math.abs(k))} = ${(0,_outils_js__WEBPACK_IMPORTED_MODULE_1__.texNombre)(lprime)} cm`, positionTexte.x, positionTexte.y - 2, {\n      taille: 15\n    });\n    this.regleSegment(centre, image);\n    this.pointCreer(image, {\n      couleur: couleur,\n      couleurLabel: couleur\n    }); // on construit l'image\n\n    this.regleMasquer();\n    this.crayonMasquer();\n    this.pause();\n    this.texteMasquer(t1);\n    this.texteMasquer(t2);\n    this.texteMasquer(t);\n    this.couleur = couleurSave;\n  };\n  /**\n   *\n   * @param {objet} p le polygone qui est déjà tracé\n   * @param {objet} centre le centre de la rotation\n   * @param {number} angle l'angle de rotation\n   * @Auteur Jean-Claude Lhote\n   * @param {objet} param4 options couleur et couleurCodage\n  */\n\n\n  this.rotationPolygone = function (p, centre, angle, noms = [], {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage\n  } = {}) {\n    let nom;\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, angle); // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n    let i = 0;\n    let codage;\n\n    for (const sommet of p.listePoints) {\n      // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i];\n      } else {\n        nom = sommet.nom + \"'\";\n      }\n\n      if (i < 1) {\n        codage = true;\n      } else {\n        codage = false;\n      }\n\n      if ((0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.longueur)(centre, sommet) !== 0) {\n        this.rotationPoint(sommet, centre, angle, nom, {\n          couleur: couleur,\n          couleurCodage: couleurCodage,\n          codage: codage\n        });\n      }\n\n      i++;\n    }\n\n    this.epaisseur = 2;\n    this.couleur = couleur;\n    this.polygoneRapide(...p2.listePoints); // on trace le polygone image en bleu épaisseur 2\n  };\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image et qui doit être tracé avec ses points nommés.\n   * @param {objet} d axe de symétrie.\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n   * @param {objet} param3 options couleur et couleurCodage\n   * @auteur Liouba Leroux et Jean-Claude Lhote\n   */\n\n\n  this.symetrieAxialePolygone = function (p, d, noms = [], {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage\n  } = {}) {\n    let nom;\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.symetrieAxiale)(p, d); // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n    // const N = homothetie(milieu(p.listePoints[0], p2.listePoints[0]), milieu(p.listePoints[1], p2.listePoints[1]), 1.23456) // créer unh point de l'axe de symétrie pour les alignements et les mesure d'angles\n\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n    let i = 0;\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\'];\n\n    for (const sommet of p.listePoints) {\n      // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i];\n      } else {\n        nom = sommet.nom + \"'\";\n      }\n\n      this.symetrieAxialePoint(sommet, d, nom, {\n        couleur: couleur,\n        couleurCodage: couleurCodage,\n        codage: marques[i]\n      });\n      i++;\n    }\n\n    this.compasMasquer();\n    this.crayonMasquer();\n    this.epaisseur = 2;\n    this.couleur = couleur;\n    this.polygoneRapide(...p2.listePoints); // on trace le polygone image en bleu épaisseur 2\n\n    this.polygoneRapide(p2);\n  };\n  /**\n   *\n   * @param {objet} p polygone dont on construit l'image\n   * @param {objet} A point de départ de la translation\n   * @param {objet} B point d'arrivée de la translation\n   * @param {string} noms tableau contenant les noms des sommets dans le même ordre que p\n  * @param {objet} param3 options couleur et couleurCodage\n  * @Auteur Jean-Claude Lhote\n  */\n\n\n  this.translationPolygone = function (p, A, B, noms = [], {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage,\n    codage = 'O'\n  } = {}) {\n    let nom;\n    const v = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.vecteur)(A, B);\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.translation)(p, v); // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n    let i = 0;\n\n    for (const sommet of p.listePoints) {\n      // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i];\n      } else {\n        nom = sommet.nom + \"'\";\n      }\n\n      this.translationPoint(sommet, A, B, nom, {\n        couleur: couleur,\n        couleurCodage: couleurCodage,\n        codage: codage\n      });\n    }\n\n    this.epaisseur = 2;\n    this.couleur = couleur;\n    this.polygoneRapide(...p2.listePoints); // on trace le polygone image en bleu épaisseur 2\n\n    this.polygoneRapide(p2);\n    i++;\n  };\n  /**\n   *\n   * @param {objet} p  le polygone dont on veut construire l'image qui doit être tracé\n   * @param {objet} centre le centre de symétrie\n   * @param {array} noms les noms des sommets images (si pas précisé ce sera le nom de l'antécédent avec un ')\n   * @param {objet} param3 options couleur et couleurCodage\n   * @Auteur Jean-Claude Lhote\n   */\n\n\n  this.demiTourPolygone = function (p, centre, noms = [], {\n    couleur = this.couleur,\n    couleurCodage = this.couleurCodage\n  } = {}) {\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.rotation)(p, centre, 180); // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n\n    this.epaisseur = 0.5; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n    let nom;\n    let i = 0;\n    const marques = ['/', '//', '///', 'O', '\\\\\\\\'];\n\n    for (const sommet of p.listePoints) {\n      // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i];\n      } else {\n        nom = sommet.nom + \"'\";\n      }\n\n      this.demiTourPoint(sommet, centre, nom, {\n        couleur: couleur,\n        couleurCodage: couleurCodage,\n        codage: marques[i]\n      });\n      i++;\n    }\n\n    this.epaisseur = 2;\n    this.couleur = couleur;\n    this.polygoneRapide(...p2.listePoints); // on trace le polygone image en bleu épaisseur 2\n\n    this.polygoneRapide(p2); // figure svg de l'exercice\n  };\n  /**\n   *\n   * @param {objet} p polygone dont on doit construire l'image\n   * @param {objet} centre de l'homothétie\n   * @param {number} k rapport de l'homothétie\n   * @param {array} noms tableau contenant les différents noms des sommets dans le même ordre que ceux de p. Si vide, alors on ajoute ' à ceux de p\n   * @param {objet} param4 options (couleur)\n   */\n\n\n  this.homothetiePolygone = function (p, centre, k, noms = [], {\n    couleur = this.couleur\n  } = {}) {\n    let nom;\n    const p2 = (0,_2d_js__WEBPACK_IMPORTED_MODULE_0__.homothetie)(p, centre, k); // Pour tracer la figure image à la fin de l'animation avec polygoneRapide\n\n    this.epaisseur = 1; // épaisseur et couleur de crayon de papier bien taillé pour la construction\n\n    this.couleur = 'grey';\n    const t = this.textePosition('Comme k est ' + (k >= 0 ? 'positif' : 'négatif') + ' alors ' + (k >= 0 ? 'les figures sont du même côté de ' + centre.nom : centre.nom + ' est entre les figures'), 0, 0, {\n      taille: 15\n    });\n    let i = 0;\n\n    for (const sommet of p.listePoints) {\n      // On répète la construction pour chaque sommet du polygone\n      if (noms[i] !== undefined) {\n        nom = noms[i];\n      } else {\n        nom = sommet.nom + \"'\";\n      }\n\n      this.homothetiePoint(sommet, centre, k, nom, {\n        couleur: couleur\n      });\n      i++;\n    }\n\n    this.epaisseur = 2;\n    this.couleur = couleur;\n    this.polygoneRapide(...p2.listePoints); // on trace le polygone image en bleu épaisseur 2\n\n    this.texteMasquer(t);\n  };\n  /** **** Fin de la classe Alea2iep */\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvbW9kdWxlcy9BbGVhMmllcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGhhbGVhLy4vc3JjL2pzL21vZHVsZXMvQWxlYTJpZXAuanM/OThjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmltcG9ydCB7IHZlY3RldXIsIHBvbHlnb25lQXZlY05vbSwgdHJhbnNsYXRpb24sIHN5bWV0cmllQXhpYWxlLCBhcHBhcnRpZW50RHJvaXRlLCBwb2ludCwgcG9pbnRBZGlzdGFuY2UsIGRyb2l0ZSwgZHJvaXRlUGFyUG9pbnRFdFBlcnBlbmRpY3VsYWlyZSwgc2VnbWVudCwgdHJpYW5nbGUycG9pbnRzMmxvbmd1ZXVycywgY2VyY2xlLCBwb2ludEludGVyc2VjdGlvbkxDLCBob21vdGhldGllLCBsb25ndWV1ciwgbWlsaWV1LCBwb2ludFN1clNlZ21lbnQsIHJvdGF0aW9uLCBwb2ludEludGVyc2VjdGlvbkRELCB0cmFuc2xhdGlvbjJQb2ludHMsIGRyb2l0ZVBhclBvaW50RXRQYXJhbGxlbGUsIHByb2plY3Rpb25PcnRobywgY2VudHJlQ2VyY2xlQ2lyY29uc2NyaXQsIGFuZ2xlT3JpZW50ZSwgbm9ybWUgfSBmcm9tICcuLzJkLmpzJ1xuaW1wb3J0IHsgY2FsY3VsLCByYW5kaW50LCBub21icmVfYXZlY19lc3BhY2UgYXMgbm9tYnJlQXZlY0VzcGFjZSwgYXJyb25kaSwgdGV4Tm9tYnJlIH0gZnJvbSAnLi9vdXRpbHMuanMnXG5pbXBvcnQgaWVwTG9hZFByb21pc2UgZnJvbSAnaW5zdHJ1bWVucG9jaGUnXG5cbi8qXG4gKiBDbGFzc2UgcGFyZW50ZSBkZSB0b3VzIGxlcyBvYmpldHMgQWxlYTJpZXBcbiAqXG4gKiBAQXV0ZXVyIFLDqW1pIEFuZ290XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFsZWEyaWVwICgpIHtcbiAgdGhpcy5pZElFUCA9IDAgLy8gSWRlbnRpZmlhbnQgcG91ciBsZXMgdHJhY8Opc1xuICB0aGlzLmlkSFRNTCA9IDAgLy8gSWRlbnRpZmlhbnQgcG91ciBsZXMgZGl2IGV0IGxlIHN2Z1xuICB0aGlzLnRlbXBvID0gNSAvLyBQYXVzZSBwYXIgZMOpZmF1dCBhcHLDqHMgdW5lIGluc3RydWN0aW9uXG4gIHRoaXMudml0ZXNzZSA9IDEwIC8vIFZpdGVzc2UgcGFyIGTDqWZhdXQgcG91ciBsZXMgZMOpcGxhY2VtZW50cyBkJ2luc3RydW1lbnRzXG4gIHRoaXMuY291bGV1ciA9ICdibHVlJyAvLyBDb3VsZXVyIHBhciBkw6lmYXV0XG4gIHRoaXMuY291bGV1ckNvbXBhcyA9ICdmb3Jlc3RncmVlbidcbiAgdGhpcy5jb3VsZXVyVGV4dGUgPSAnYmxhY2snXG4gIHRoaXMuY291bGV1clBvaW50ID0gJ2JsYWNrJyAvLyBDb3VsZXVyIGR1IG5vbSBkZXMgcG9pbnRzXG4gIHRoaXMuY291bGV1ckNvZGFnZSA9ICcjZjE1OTI5J1xuICB0aGlzLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiA9ICdncmF5J1xuICB0aGlzLmVwYWlzc2V1ciA9IDJcbiAgdGhpcy5lcGFpc3NldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiA9IDFcbiAgdGhpcy5wb2ludGlsbGVzID0gZmFsc2VcbiAgdGhpcy5saXN0ZV9zY3JpcHQgPSBbXSAvLyBMaXN0ZSBkZXMgaW5zdHJ1Y3Rpb25zIHhtbCBtaXNlIMOgIGpvdXIgcGFyIGxlcyBtw6l0aG9kZXNcblxuICB0aGlzLnRyYW5zbGF0aW9uWCA9IDBcbiAgdGhpcy50cmFuc2xhdGlvblkgPSAxMCAvLyBQYXIgZMOpZmF1dCBsJ2FuZ2xlIGVuIGhhdXQgw6AgZ2F1Y2hlIGVzdCBsZSBwb2ludCBkZSBjb29yZG9ubsOpZXMgKDAsMTApXG5cbiAgdGhpcy5yZWNhZHJlID0gZnVuY3Rpb24gKHhtaW4sIHltYXgpIHtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDEgLSB4bWluXG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSB5bWF4ICsgM1xuICB9XG5cbiAgLy8gR2FyZGUgZW4gbcOpbW9pcmUgbGVzIGNvb3Jkb25uw6llcyBleHRyw6ptZXMgZGVzIG9iamV0cyBjcsOpw6lzXG4gIHRoaXMueE1pbiA9IDBcbiAgdGhpcy55TWluID0gMFxuICB0aGlzLnhNYXggPSAwXG4gIHRoaXMueU1heCA9IDBcblxuICB0aGlzLnRhaWxsZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPHZpZXdCb3ggd2lkdGg9XCIke3dpZHRofVwiIGhlaWdodD1cIiR7aGVpZ2h0fVwiIC8+YClcbiAgfVxuICAvLyBUcmFuc2Zvcm1lIGxlcyBjb29yZG9ubsOpZXMgTWF0aEFMRUEyRCBlbiBjb29yZG9ubsOpZXMgcG91ciBsZSBYTUwgZCdJRVBcbiAgdGhpcy54ID0gZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCB4ID0gY2FsY3VsKChBLnggKyB0aGlzLnRyYW5zbGF0aW9uWCkgKiAzMCwgMClcbiAgICBpZiAoQS54ID4gdGhpcy54TWF4KSB7XG4gICAgICB0aGlzLnhNYXggPSBBLnhcbiAgICB9XG4gICAgaWYgKEEueCA8IHRoaXMueE1pbikge1xuICAgICAgdGhpcy54TWluID0gQS54XG4gICAgfVxuICAgIHJldHVybiB4XG4gIH1cbiAgdGhpcy55ID0gZnVuY3Rpb24gKEEpIHtcbiAgICBjb25zdCB5ID0gY2FsY3VsKCgtQS55ICsgdGhpcy50cmFuc2xhdGlvblkpICogMzAsIDApXG4gICAgaWYgKEEueSA8IHRoaXMueU1pbikge1xuICAgICAgdGhpcy55TWluID0gQS55XG4gICAgfVxuICAgIGlmIChBLnkgPiB0aGlzLnlNYXgpIHtcbiAgICAgIHRoaXMueU1heCA9IEEueVxuICAgIH1cbiAgICByZXR1cm4geVxuICB9XG5cbiAgLy8gU2F1dmVnYXJkZSBkZSBsJ8OpdGF0IGRlcyBpbnN0cnVtZW50c1xuICB0aGlzLnJlZ2xlID0ge1xuICAgIHZpc2liaWxpdGU6IGZhbHNlLFxuICAgIHBvc2l0aW9uOiBwb2ludCgwLCAwKSxcbiAgICBhbmdsZTogMCxcbiAgICBsb25ndWV1cjogMTUsXG4gICAgem9vbTogMTAwXG4gIH1cblxuICB0aGlzLmNyYXlvbiA9IHtcbiAgICB2aXNpYmlsaXRlOiBmYWxzZSxcbiAgICBwb3NpdGlvbjogcG9pbnQoMCwgMCksXG4gICAgYW5nbGU6IDAsXG4gICAgem9vbTogMTAwXG4gIH1cblxuICB0aGlzLmVxdWVycmUgPSB7XG4gICAgdmlzaWJpbGl0ZTogZmFsc2UsXG4gICAgcG9zaXRpb246IHBvaW50KDAsIDApLFxuICAgIGFuZ2xlOiAwLFxuICAgIHpvb206IDEwMFxuICB9XG5cbiAgdGhpcy5yZXF1ZXJyZSA9IHtcbiAgICB2aXNpYmlsaXRlOiBmYWxzZSxcbiAgICBwb3NpdGlvbjogcG9pbnQoMCwgMCksXG4gICAgYW5nbGU6IDAsXG4gICAgem9vbTogMTAwXG4gIH1cblxuICB0aGlzLnJhcHBvcnRldXIgPSB7XG4gICAgdmlzaWJpbGl0ZTogZmFsc2UsXG4gICAgcG9zaXRpb246IHBvaW50KDAsIDApLFxuICAgIGFuZ2xlOiAwLFxuICAgIHpvb206IDEwMFxuICB9XG5cbiAgdGhpcy5jb21wYXMgPSB7XG4gICAgdmlzaWJpbGl0ZTogZmFsc2UsXG4gICAgcG9zaXRpb246IHBvaW50KDAsIDApLFxuICAgIGFuZ2xlOiAwLFxuICAgIG9yaWVudGF0aW9uOiAnZHJvaXRlJyxcbiAgICBlY2FydGVtZW50OiAwLFxuICAgIGxldmU6IGZhbHNlLFxuICAgIHpvb206IDEwMFxuICB9XG5cbiAgdGhpcy54bWwgPSAnJ1xuXG4gIC8qKlxuICAgKiBSZW52b2llIGxlIHNjcmlwdCB4bWxcbiAgICpcbiAgICovXG4gIHRoaXMuc2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnhtbC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy54bWxcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvZGVYTUwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuJ1xuICAgICAgY29kZVhNTCArPSAnPElOU1RSVU1FTlBPQ0hFIHZlcnNpb249XCIyXCI+XFxuJ1xuICAgICAgY29kZVhNTCArPSB0aGlzLmxpc3RlX3NjcmlwdC5qb2luKCdcXG4nKVxuICAgICAgY29kZVhNTCArPSAnXFxuPC9JTlNUUlVNRU5QT0NIRT4nXG4gICAgICByZXR1cm4gY29kZVhNTFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW52b2llIGxlIGNvZGUgSFRNTCBkZSBsJ2FuaW1hdGlvblxuICAgKiBAcGFyYW0ge2ludH0gbnVtZXJvRXhlcmNpY2UgLSBOdW3DqXJvIGRlIGwnZXhlcmNpY2VcbiAgICogQHBhcmFtIHtpbnR9IGkgLSBOdW3DqXJvIGRlIGxhIHF1ZXN0aW9uXG4gICAqL1xuICB0aGlzLmh0bWwgPSBmdW5jdGlvbiAoaWQxLCBpZDIpIHtcbiAgICBpZiAod2luZG93LnNvcnRpZUh0bWwpIHtcbiAgICAgIGNvbnN0IGlkID0gYElFUF8ke2lkMX1fJHtpZDJ9YFxuICAgICAgd2luZG93Lmxpc3RlU2NyaXB0c0llcFtpZF0gPSB0aGlzLnNjcmlwdCgpIC8vIE9uIGFqb3V0ZSBsZSBzY3JpcHRcbiAgICAgIGNvbnN0IGNvZGVIVE1MID0gYDxkaXYgaWQ9XCJJRVBDb250YWluZXIke2lkfVwiID48L2Rpdj5gXG4gICAgICB3aW5kb3cubGlzdGVBbmltYXRpb25zSWVwQUNoYXJnZXIucHVzaChpZClcbiAgICAgIHJldHVybiBjb2RlSFRNTFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ludH0gbnVtZXJvRXhlcmNpY2UgLSBOdW3DqXJvIGRlIGwnZXhlcmNpY2VcbiAgICogQHBhcmFtIHtpbnR9IGkgLSBOdW3DqXJvIGRlIGxhIHF1ZXN0aW9uXG4gICAqIEByZXR1cm4gQ29kZSBIVE1MIGF2ZWMgbGUgYm91dG9uIHF1aSBhZmZpY2hlIG91IG1hc3F1ZSB1biBkaXYgYXZlYyBsJ2FuaW1hdGlvblxuICAgKi9cbiAgdGhpcy5odG1sQm91dG9uID0gZnVuY3Rpb24gKGlkMSwgaWQyID0gJycpIHtcbiAgICBpZiAod2luZG93LnNvcnRpZUh0bWwpIHtcbiAgICAgIGNvbnN0IGlkID0gYElFUF8ke2lkMX1fJHtpZDJ9YFxuICAgICAgd2luZG93Lmxpc3RlU2NyaXB0c0llcFtpZF0gPSB0aGlzLnNjcmlwdCgpIC8vIE9uIGFqb3V0ZSBsZSBzY3JpcHRcbiAgICAgIGNvbnN0IGNvZGVIVE1MID0gYDxicj48YnV0dG9uIGNsYXNzPVwidWkgbWluaSBjb21wYWN0IGJ1dHRvblwiIGlkPVwiYnRuQW5pbWF0aW9uJHtpZH1cIiBvbmNsaWNrPVwidG9nZ2xlVmlzaWJpbGl0eUlFUCgnJHtpZH0nKVwiIHN0eWxlPVwibWFyZ2luLXRvcDoyMHB4XCI+PGkgY2xhc3M9XCJsYXJnZSBwbGF5IGNpcmNsZSBvdXRsaW5lIGljb25cIj48L2k+Vm9pciBhbmltYXRpb248L2J1dHRvbj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJJRVBDb250YWluZXIke2lkfVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIiA+PC9kaXY+YFxuICAgICAgaWYgKCF3aW5kb3cudG9nZ2xlVmlzaWJpbGl0eUlFUCkge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVmlzaWJpbGl0eUlFUCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgSUVQQ29udGFpbmVyJHtpZH1gKVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgYnRuQW5pbWF0aW9uJHtpZH1gKVxuICAgICAgICAgIGNvbnN0IHhtbCA9IHdpbmRvdy5saXN0ZVNjcmlwdHNJZXBbaWRdXG4gICAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICczMHB4J1xuICAgICAgICAgICAgZWxlbWVudEJ0bi5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJsYXJnZSBzdG9wIGNpcmNsZSBvdXRsaW5lIGljb25cIj48L2k+TWFzcXVlciBhbmltYXRpb24nXG4gICAgICAgICAgICBpZXBMb2FkUHJvbWlzZShlbGVtZW50LCB4bWwsIHsgem9vbTogdHJ1ZSwgYXV0b3N0YXJ0OiB0cnVlIH0pLnRoZW4oaWVwQXBwID0+IHtcbiAgICAgICAgICAgICAgLy8gbGEgZmlndXJlIGVzdCBjaGFyZ8OpZVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4geyBjb25zb2xlLmxvZyhlcnJvcikgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBlbGVtZW50QnRuLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImxhcmdlIHBsYXkgY2lyY2xlIG91dGxpbmUgaWNvblwiPjwvaT5Wb2lyIGFuaW1hdGlvbidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlSFRNTFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gIH1cblxuICAvKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICoqKiBGT05DVElPTlMgQ09NTVVORVMgKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZXQgLSAncmVnbGUnLCAnZXF1ZXJyZScsICdyZXF1ZXJyZSwgJ2NvbXBhcycsICdyYXBwb3J0ZXVyJyBvdSAnY3JheW9uJ1xuICAgKiBAcGFyYW0ge3BvaW50fSBBIC0gUG9pbnQgKDAsIDApIHBhciBkw6lmYXV0XG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgLSB7IHRlbXBvIDogMTAgfVxuICAgKi9cbiAgdGhpcy5tb250cmVyID0gZnVuY3Rpb24gKG9iamV0LCBBLCB7IHRlbXBvID0gdGhpcy50ZW1wbywgdml0ZXNzZSA9IHRoaXMudml0ZXNzZSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXNbb2JqZXRdLnZpc2liaWxpdGUgfHwgdGhpc1tvYmpldF0ucG9zaXRpb24gIT09IEEpIHsgLy8gT24gYWpvdXRlIHVuZSBsaWduZSB4bWwgcXVlIHNpIGwnb2JqZXQgZXN0IGNhY2jDqSBvdSBkb2l0IGFwcGFyYWl0cmUgw6AgdW4gYXV0cmUgZW5kcm9pdFxuICAgICAgbGV0IGNvZGVYTUwgPSAnJ1xuICAgICAgbGV0IEExXG4gICAgICBpZiAodHlwZW9mIEEgPT09ICd1bmRlZmluZWQnKSB7IC8vIEExIGVzdCB1bmUgY29waWUgZGUgQSBvdSAoMCwwKSBzaSBBIG4nZXN0IHBhcyBkw6lmaW5pXG4gICAgICAgIEExID0gdGhpc1tvYmpldF0ucG9zaXRpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEExID0gQVxuICAgICAgfVxuICAgICAgaWYgKHRoaXNbb2JqZXRdLnZpc2liaWxpdGUpIHsgLy8gUydpbCBlc3QgZMOpasOgIHZpc2libGUsIG1vbnRyZXIgZGV2aWVudCB1biBkw6lwbGNlclxuICAgICAgICB0aGlzLmRlcGxhY2VyKG9iamV0LCBBMSwgeyB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVYTUwgPSBgPGFjdGlvbiBvYmpldD1cIiR7b2JqZXR9XCIgbW91dmVtZW50PVwibW9udHJlclwiIGFic2Npc3NlPVwiJHt0aGlzLngoQTEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQTEpfVwiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmBcbiAgICAgICAgdGhpc1tvYmpldF0udmlzaWJpbGl0ZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRoaXNbb2JqZXRdLnBvc2l0aW9uID0gQTFcbiAgICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLnJlZ2xlTW9udHJlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb250cmVyKCdyZWdsZScsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5jcmF5b25Nb250cmVyID0gZnVuY3Rpb24gKEEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1vbnRyZXIoJ2NyYXlvbicsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5lcXVlcnJlTW9udHJlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb250cmVyKCdlcXVlcnJlJywgQSwgb3B0aW9ucylcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLnJlcXVlcnJlTW9udHJlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb250cmVyKCdyZXF1ZXJyZScsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5jb21wYXNNb250cmVyID0gZnVuY3Rpb24gKEEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1vbnRyZXIoJ2NvbXBhcycsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5yYXBwb3J0ZXVyTW9udHJlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb250cmVyKCdyYXBwb3J0ZXVyJywgQSwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZXRcbiAgICogQHBhcmFtIHtvYmpldH0gcGFyYW0xXG4gICAqL1xuICB0aGlzLm1hc3F1ZXIgPSBmdW5jdGlvbiAob2JqZXQsIHsgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIGlmICh0aGlzW29iamV0XS52aXNpYmlsaXRlKSB7IC8vIE9uIGFqb3V0ZSB1bmUgbGlnbmUgeG1sIHF1ZSBzaSBsJ29iamV0IGVzdCB2aXNpYmxlXG4gICAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gb2JqZXQ9XCIke29iamV0fVwiIG1vdXZlbWVudD1cIm1hc3F1ZXJcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gXG4gICAgICB0aGlzW29iamV0XS52aXNpYmlsaXRlID0gZmFsc2VcbiAgICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMucmVnbGVNYXNxdWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hc3F1ZXIoJ3JlZ2xlJywgb3B0aW9ucylcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5jcmF5b25NYXNxdWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hc3F1ZXIoJ2NyYXlvbicsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuZXF1ZXJyZU1hc3F1ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMubWFzcXVlcignZXF1ZXJyZScsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMucmVxdWVycmVNYXNxdWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hc3F1ZXIoJ3JlcXVlcnJlJywgb3B0aW9ucylcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5jb21wYXNNYXNxdWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hc3F1ZXIoJ2NvbXBhcycsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMucmFwcG9ydGV1ck1hc3F1ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMubWFzcXVlcigncmFwcG9ydGV1cicsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqZXRcbiAqIEBwYXJhbSB7cG9pbnR9IEFcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAqL1xuICB0aGlzLmRlcGxhY2VyID0gZnVuY3Rpb24gKG9iamV0LCBBLCB7IHRlbXBvID0gdGhpcy50ZW1wbywgdml0ZXNzZSA9IHRoaXMudml0ZXNzZSB9ID0ge30pIHtcbiAgICBpZiAodGhpc1tvYmpldF0ucG9zaXRpb24gIT09IEEpIHsgLy8gT24gbidham91dGUgdW5lIGNvbW1hbmRlIHhtbCBxdWUgcydpbCB5IGEgdnJhaW1lbnQgdW4gZMOpcGxhY2VtZW50XG4gICAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gb2JqZXQ9XCIke29iamV0fVwiIG1vdXZlbWVudD1cInRyYW5zbGF0aW9uXCIgYWJzY2lzc2U9XCIke3RoaXMueChBKX1cIiBvcmRvbm5lZT1cIiR7dGhpcy55KEEpfVwiIHRlbXBvPVwiJHt0ZW1wb31cIiB2aXRlc3NlPVwiJHt2aXRlc3NlfVwiIC8+YFxuICAgICAgdGhpc1tvYmpldF0ucG9zaXRpb24gPSBBXG4gICAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGNvZGVYTUwpXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMucmVnbGVEZXBsYWNlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5kZXBsYWNlcigncmVnbGUnLCBBLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMudGV4dGVEZXBsYWNlciA9IGZ1bmN0aW9uIChpZCwgQSwgeyB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgY29kZVhNTCA9IGA8YWN0aW9uIG9iamV0PVwidGV4dGVcIiBpZD1cIiR7aWR9XCIgbW91dmVtZW50PVwidHJhbnNsYXRpb25cIiBhYnNjaXNzZT1cIiR7dGhpcy54KEEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQSl9XCIgdGVtcG89XCIke3RlbXBvfVwiIHZpdGVzc2U9XCIke3ZpdGVzc2V9XCIgLz5gXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChjb2RlWE1MKVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuY3JheW9uRGVwbGFjZXIgPSBmdW5jdGlvbiAoQSwgb3B0aW9ucykge1xuICAgIHRoaXMuZGVwbGFjZXIoJ2NyYXlvbicsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5lcXVlcnJlRGVwbGFjZXIgPSBmdW5jdGlvbiAoQSwgb3B0aW9ucykge1xuICAgIHRoaXMuZGVwbGFjZXIoJ2VxdWVycmUnLCBBLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMucmVxdWVycmVEZXBsYWNlciA9IGZ1bmN0aW9uIChBLCBvcHRpb25zKSB7XG4gICAgdGhpcy5kZXBsYWNlcigncmVxdWVycmUnLCBBLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuY29tcGFzRGVwbGFjZXIgPSBmdW5jdGlvbiAoQSwgb3B0aW9ucykge1xuICAgIHRoaXMuZGVwbGFjZXIoJ2NvbXBhcycsIEEsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5yYXBwb3J0ZXVyRGVwbGFjZXIgPSBmdW5jdGlvbiAoQSwgb3B0aW9ucykge1xuICAgIHRoaXMuZGVwbGFjZXIoJ3JhcHBvcnRldXInLCBBLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iamV0XG4gKiBAcGFyYW0ge2ludH0gYW5nbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAqL1xuICB0aGlzLnJvdGF0aW9uID0gZnVuY3Rpb24gKG9iamV0LCBhLCB7IHRlbXBvID0gdGhpcy50ZW1wbywgc2VucyA9IGNhbGN1bCh0aGlzLnZpdGVzc2UgLyAyLCAwKSB9ID0ge30pIHtcbiAgICBsZXQgYW5nbGVcbiAgICBpZiAoYS50eXBlT2JqZXQgPT09ICdwb2ludCcpIHtcbiAgICAgIGNvbnN0IGQgPSBkcm9pdGUodGhpc1tvYmpldF0ucG9zaXRpb24sIGEpXG4gICAgICBhbmdsZSA9IGQuYW5nbGVBdmVjSG9yaXpvbnRhbGVcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSBhXG4gICAgfVxuICAgIGlmICh0aGlzW29iamV0XS5hbmdsZSAhPT0gYSkgeyAvLyBTaSBsYSByb3RhdGlvbiBlc3QgaW51dGlsZSwgb24gbmUgbGEgZmFpdCBwYXNcbiAgICAgIC8vIExlcyBhbmdsZXMgZGUgTWF0aEFMRUEyRCBldCBkZSBJRVAgc29udCBvcHBvc8OpcyAhISEhIVxuICAgICAgY29uc3QgY29kZVhNTCA9IGA8YWN0aW9uIG9iamV0PVwiJHtvYmpldH1cIiBtb3V2ZW1lbnQ9XCJyb3RhdGlvblwiIGFuZ2xlPVwiJHstMSAqIGFuZ2xlfVwiIHRlbXBvPVwiJHt0ZW1wb31cIiBzZW5zPVwiJHtzZW5zfVwiIC8+YFxuICAgICAgdGhpc1tvYmpldF0uYW5nbGUgPSBhbmdsZVxuICAgICAgaWYgKHR5cGVvZiBhbmdsZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoYW5nbGUpKSB7XG4gICAgICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBbmdsZSBkZSByb3RhdGlvbiBub24gZMOpZmluaSBwb3VyIGxcXCdvYmpldCAuJywgb2JqZXQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBhbmdsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICovXG4gIHRoaXMucmVnbGVSb3RhdGlvbiA9IGZ1bmN0aW9uIChhbmdsZSwgb3B0aW9ucykge1xuICAgIHRoaXMucm90YXRpb24oJ3JlZ2xlJywgYW5nbGUsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gKlxuICogQHBhcmFtIHtpbnR9IGFuZ2xlXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zXG4gKi9cbiAgdGhpcy5jcmF5b25Sb3RhdGlvbiA9IGZ1bmN0aW9uIChhbmdsZSwgb3B0aW9ucykge1xuICAgIHRoaXMucm90YXRpb24oJ2NyYXlvbicsIGFuZ2xlLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBhbmdsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICovXG4gIHRoaXMuZXF1ZXJyZVJvdGF0aW9uID0gZnVuY3Rpb24gKGFuZ2xlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5yb3RhdGlvbignZXF1ZXJyZScsIGFuZ2xlLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBhbmdsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICovXG4gIHRoaXMucmVxdWVycmVSb3RhdGlvbiA9IGZ1bmN0aW9uIChhbmdsZSwgb3B0aW9ucykge1xuICAgIHRoaXMucm90YXRpb24oJ3JlcXVlcnJlJywgYW5nbGUsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gKlxuICogQHBhcmFtIHtpbnR9IGFuZ2xlXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zXG4gKi9cbiAgdGhpcy5jb21wYXNSb3RhdGlvbiA9IGZ1bmN0aW9uIChhbmdsZSwgb3B0aW9ucykge1xuICAgIHRoaXMucm90YXRpb24oJ2NvbXBhcycsIGFuZ2xlLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBhbmdsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9uc1xuICovXG4gIHRoaXMucmFwcG9ydGV1clJvdGF0aW9uID0gZnVuY3Rpb24gKGFuZ2xlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5yb3RhdGlvbigncmFwcG9ydGV1cicsIGFuZ2xlLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBwb3VyY2VudGFnZSAyMDAgcG91ciBkb3VibGVyIGxhIHRhaWxsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyB0ZW1wbyA9IDAgcGFyIGTDqWZhdXRcbiAqL1xuICB0aGlzLnJlZ2xlWm9vbSA9IGZ1bmN0aW9uIChrLCB7IHRlbXBvID0gMCB9ID0ge30pIHtcbiAgICB0aGlzLnJlZ2xlLnpvb20gPSBrXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBlY2hlbGxlPVwiJHtrfVwiIG1vdXZlbWVudD1cInpvb21cIiBvYmpldD1cInJlZ2xlXCIgdGVtcG89XCIke3RlbXBvfVwiIC8+YClcbiAgfVxuICAvKipcbiAqXG4gKiBAcGFyYW0ge2ludH0gcG91cmNlbnRhZ2UgMjAwIHBvdXIgZG91YmxlciBsYSB0YWlsbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgdGVtcG8gPSAwIHBhciBkw6lmYXV0XG4gKi9cbiAgdGhpcy5lcXVlcnJlWm9vbSA9IGZ1bmN0aW9uIChrLCB7IHRlbXBvID0gMCB9ID0ge30pIHtcbiAgICB0aGlzLmVxdWVycmUuem9vbSA9IGtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGVjaGVsbGU9XCIke2t9XCIgbW91dmVtZW50PVwiem9vbVwiIG9iamV0PVwiZXF1ZXJyZVwiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmApXG4gIH1cbiAgLyoqXG4gKlxuICogQHBhcmFtIHtpbnR9IHBvdXJjZW50YWdlIDIwMCBwb3VyIGRvdWJsZXIgbGEgdGFpbGxlXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIHRlbXBvID0gMCBwYXIgZMOpZmF1dFxuICovXG4gIHRoaXMucmVxdWVycmVab29tID0gZnVuY3Rpb24gKGssIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIHRoaXMucmVxdWVycmUuem9vbSA9IGtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGVjaGVsbGU9XCIke2t9XCIgbW91dmVtZW50PVwiem9vbVwiIG9iamV0PVwicmVxdWVycmVcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gKVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7aW50fSBwb3VyY2VudGFnZSAyMDAgcG91ciBkb3VibGVyIGxhIHRhaWxsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyB0ZW1wbyA9IDAgcGFyIGTDqWZhdXRcbiAqL1xuICB0aGlzLnJhcHBvcnRldXJab29tID0gZnVuY3Rpb24gKGssIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIHRoaXMucmFwcG9ydGV1ci56b29tID0ga1xuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gZWNoZWxsZT1cIiR7a31cIiBtb3V2ZW1lbnQ9XCJ6b29tXCIgb2JqZXQ9XCJyYXBwb3J0ZXVyXCIgdGVtcG89XCIke3RlbXBvfVwiIC8+YClcbiAgfVxuICAvKipcbiAqXG4gKiBAcGFyYW0ge2ludH0gcG91cmNlbnRhZ2UgMjAwIHBvdXIgZG91YmxlciBsYSB0YWlsbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgdGVtcG8gPSAwIHBhciBkw6lmYXV0XG4gKi9cbiAgdGhpcy5jb21wYXNab29tID0gZnVuY3Rpb24gKGssIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIHRoaXMuY29tcGFzLnpvb20gPSBrXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBlY2hlbGxlPVwiJHtrfVwiIG1vdXZlbWVudD1cInpvb21cIiBvYmpldD1cImNvbXBhc1wiIC8+YClcbiAgfVxuXG4gIC8qKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKioqKioqKioqIFBPSU5UICoqKioqKioqKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICovXG5cbiAgLyoqXG4gKiBDcsOpw6llciB1biBwb2ludCBhdmVjIGxhIGNyb2l4IHBvdXIgbGUgc2l0dWVyIGV0IHNvbiBub20gZW4gYmFzIMOgIGRyb2l0ZSBwYXIgZMOpZmF1dC4gTCdpZCBzZXJhIHNhdXZlZ2FyZMOpIGRhbnMgbCdvYmpldCBwb2ludC4gUydpbCBuJ2VzdCBwYXMgZMOpZmluaSBhbG9ycyBvbiBwcmVuZCBsZSBwcmVtaWVyIGVudGllciBkaXNwb25pYmxlLlxuICogQHBhcmFtIHtwb2ludH0gQVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyB7IGxhYmVsOiBBLm5vbSwgdGVtcG86IHRoaXMudGVtcG8sIGNvdWxldXI6IHRoaXMuY291bGV1clBvaW50LCBjb3VsZXVyTGFiZWw6IHRoaXMuY291bGV1clRleHRlLCBpZCB9XG4gKlxuICovXG4gIHRoaXMucG9pbnRDcmVlciA9IGZ1bmN0aW9uIChBLCB7IGR4ID0gMC4xLCBkeSwgbGFiZWwgPSBBLm5vbSwgdGVtcG8gPSB0aGlzLnRlbXBvLCBjb3VsZXVyID0gdGhpcy5jb3VsZXVyUG9pbnQsIGNvdWxldXJMYWJlbCA9IHRoaXMuY291bGV1clRleHRlLCBpZCB9ID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQS5pZCA9IGlkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRJRVArK1xuICAgICAgQS5pZCA9IHRoaXMuaWRJRVBcbiAgICB9XG4gICAgbGV0IGNvZGVYTUxcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIGNvZGVYTUwgPSBgPGFjdGlvbiBhYnNjaXNzZT1cIiR7dGhpcy54KEEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQSl9XCIgY291bGV1cj1cIiR7Y291bGV1cn1cIiBpZD1cIiR7QS5pZH1cIiBtb3V2ZW1lbnQ9XCJjcmVlclwiIG9iamV0PVwicG9pbnRcIiAvPmBcbiAgICAgIC8vIGNvZGVYTUwgKz0gYFxcbjxhY3Rpb24gY291bGV1cj1cIiR7Y291bGV1ckxhYmVsfVwiIG5vbT1cIiR7bGFiZWx9XCIgaWQ9XCIke3RoaXMuaWRJRVB9XCIgbW91dmVtZW50PVwibm9tbWVyXCIgb2JqZXQ9XCJwb2ludFwiIHRlbXBvPVwiJHt0ZW1wb31cIiAgLz5gXG4gICAgICBjb25zdCBNID0gcG9pbnQoQS54LCBBLnkpXG4gICAgICBpZiAodHlwZW9mIGR4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBNLnggKz0gZHhcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIE0ueSArPSBkeVxuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ZVBvaW50KGAkJHtsYWJlbH0kYCwgTSwgeyB0ZW1wbzogMCwgY291bGV1cjogY291bGV1ckxhYmVsIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVYTUwgPSBgPGFjdGlvbiBhYnNjaXNzZT1cIiR7dGhpcy54KEEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQSl9XCIgY291bGV1cj1cIiR7Y291bGV1cn1cIiBpZD1cIiR7QS5pZH1cIiBtb3V2ZW1lbnQ9XCJjcmVlclwiIG9iamV0PVwicG9pbnRcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gXG4gICAgfVxuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgfVxuICAvKipcbiAqIENyw6lhdGlvbiBkZSBwbHVzaWV1cnMgcG9pbnRzXG4gKiBMZSBkZXJuaWVyIGFyZ3VtZW50IHBldXQgw6p0cmUgdW5lIG9wdGlvbiBxdWkgc2VyYSBhcHBsaXF1w6llIMOgIHRvdXMgbGVzIHBvaW50c1xuICpcbiAqIEBwYXJhbSAgey4uLnBvaW50c30gcG9pbnRzIFBvaW50cyBzw6lwYXLDqXMgcGFyIGRlcyB2aXJndWxlc1xuICovXG4gIHRoaXMucG9pbnRzQ3JlZXIgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGlmIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0udHlwZU9iamV0ID09PSAncG9pbnQnKSB7XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5wb2ludENyZWVyKHBvaW50LCB7IHRlbXBvOiAwIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGVubGV2ZURlcm5pZXIgPSBhcnIgPT4gYXJyLnNsaWNlKDAsIC0xKVxuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBlbmxldmVEZXJuaWVyKGFyZ3MpKSB7XG4gICAgICAgIHRoaXMucG9pbnRDcmVlcihwb2ludCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gKiBNYXNxdWVyIHVuIHBvaW50XG4gKiBAcGFyYW0ge3BvaW50fSBBXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7IHRlbXBvOiAwIH1cbiAqL1xuICB0aGlzLnBvaW50TWFzcXVlciA9IGZ1bmN0aW9uIChBLCB7IHRlbXBvID0gMCB9ID0ge30pIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGlkPVwiJHtBLmlkfVwiIG1vdXZlbWVudD1cIm1hc3F1ZXJcIiBvYmpldD1cInBvaW50XCIgdGVtcG89XCIke3RlbXBvfVwiIC8+YClcbiAgfVxuICAvKipcbiAgICogTW9udHJlciB1biBwb2ludCBxdWkgYXVyYWl0IMOpdMOpIGNhY2jDqVxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA7IHsgdGVtcG8gOiB0aGlzLnRlbXBvIH1cbiAgICovXG4gIHRoaXMucG9pbnRNb250cmVyID0gZnVuY3Rpb24gKEEsIHsgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gaWQ9XCIke0EuaWR9XCIgbW91dmVtZW50PVwibW9udHJlclwiIG9iamV0PVwicG9pbnRcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gKVxuICB9XG4gIC8qKlxuICAgKiBBbmltZSBsYSB0cmFuc2xhdGlvbiBkJ3VuIHBvaW50XG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtpbnR9IHggQWJzY2lzc2UgZHUgcG9pbnQgZCdhcnJpdsOpZVxuICAgKiBAcGFyYW0ge2ludH0geSBPcmRvbm7DqWUgZHUgcG9pbnQgZCdhcnJpdsOpZVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7IHRlbXBvOiB0aGlzLnRlbXBvLCB2aXRlc3NlOiB0aGlzLnZpdGVzc2UgfVxuICAgKi9cbiAgdGhpcy5wb2ludERlcGxhY2VyID0gZnVuY3Rpb24gKEEsIHgsIHksIHsgdGVtcG8gPSB0aGlzLnRlbXBvLCB2aXRlc3NlID0gdGhpcy52aXRlc3NlIH0gPSB7fSkge1xuICAgIGNvbnN0IEIgPSBwb2ludCh4LCB5KVxuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gYWJzY2lzc2U9XCIke3RoaXMueChCKX1cIiBvcmRvbm5lZT1cIiR7dGhpcy55KEIpfVwiIGlkPVwiJHtBLmlkfVwiIG1vdXZlbWVudD1cInRyYW5zbGF0aW9uXCIgb2JqZXQ9XCJwb2ludFwiIHRlbXBvPVwiJHt0ZW1wb31cIiB2aXRlc3NlPVwiJHt2aXRlc3NlfVwiIC8+YClcbiAgfVxuICAvKipcbiAgICogQWpvdXRlIHVuIGxhYmVsIGF1IHBvaW50XG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vbVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIGR4IHBvdXIgbGUgZMOpcGxhY2VtZW50IHZlcnRpY2FsIGR1IG5vbSBkdSBwb2ludCwgZHkgcG91ciBsZSBkw6lwbGFjZW1ldG4gaG9yaXpvbnRhbCwgY291bGV1cjogdGhpcy5jb3VsZXVyUG9pbnQsIHRlbXBvOiB0aGlzLnRlbXBvXG4gICAqL1xuICB0aGlzLnBvaW50Tm9tbWVyID0gZnVuY3Rpb24gKEEsIG5vbSwgeyBkeCwgZHksIGNvdWxldXIgPSB0aGlzLmNvdWxldXJQb2ludCwgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIC8vIGNvbnN0IGNvb3Jkb25uZWVzVGV4dGUgPSAnJ1xuICAgIGNvbnN0IE0gPSBwb2ludChBLngsIEEueSlcbiAgICBpZiAodHlwZW9mIGR4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgTS54ICs9IGR4XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBNLnkgKz0gZHlcbiAgICB9XG4gICAgdGhpcy50ZXh0ZVBvaW50KGAkJHtub219JGAsIE0sIHsgdGVtcG86IHRlbXBvLCBjb3VsZXVyOiBjb3VsZXVyIH0pXG4gICAgLy8gdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBjb3VsZXVyPVwiJHtjb3VsZXVyfVwiIG5vbT1cIiR7bm9tfVwiIGlkPVwiJHtBLmlkfVwiIG1vdXZlbWVudD1cIm5vbW1lclwiIG9iamV0PVwicG9pbnRcIiB0ZW1wbz1cIiR7dGVtcG99XCIgJHtjb29yZG9ubmVlc1RleHRlfSAvPmApXG4gIH1cblxuICAvKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICoqKioqKioqKiBDT01QQVMgKioqKioqKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4gIC8qKlxuKiBDaGFuZ2UgbCdvcmllbnRhdGlvbiBkdSBjb21wYXMuIFBhciBkw6lmYXV0LCBlbGxlIGVzdCB2ZXJzIGxhIGRyb2l0ZS4gTCdvcmllbnRhdGlvbiBjb3VyYW50ZSBkdSBjb21wYXMgZXN0IHNhdXZlZ2FyZMOpZSBkYW5zIHRoaXMuY29tcGFzLm9yaWVudGF0aW9uXG4qIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG99XG4qL1xuICB0aGlzLmNvbXBhc1JldG91cm5lciA9IGZ1bmN0aW9uICh7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gbW91dmVtZW50PVwicmV0b3VybmVyXCIgb2JqZXQ9XCJjb21wYXNcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gXG4gICAgaWYgKHRoaXMuY29tcGFzLm9yaWVudGF0aW9uID09PSAnZHJvaXRlJykge1xuICAgICAgdGhpcy5jb21wYXMub3JpZW50YXRpb24gPSAnZ2F1Y2hlJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBhcy5vcmllbnRhdGlvbiA9ICdkcm9pdGUnXG4gICAgfVxuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtpbnR9IGxvbmd1ZXVyIMOpY2FydGVtZW50IGVuIGNtXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8sIHZpdGVzc2U6IHRoaXMudml0ZXNzZSB9XG4gICAqL1xuICB0aGlzLmNvbXBhc0VjYXJ0ZXIgPSBmdW5jdGlvbiAobCwgeyB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgY29kZVhNTCA9IGA8YWN0aW9uIGVjYXJ0PVwiJHtjYWxjdWwobCAqIDMwLCAxKX1cIiBtb3V2ZW1lbnQ9XCJlY2FydGVyXCIgb2JqZXQ9XCJjb21wYXNcIiB0ZW1wbz1cIiR7dGVtcG99XCIgdml0ZXNzZT1cIiR7dml0ZXNzZX1cIiAvPmBcbiAgICB0aGlzLmNvbXBhcy5lY2FydGVtZW50ID0gbFxuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgfVxuICAvKipcbiAgICogRmFpcyBhcHBhcmFpdHJlIGxhIHLDqGdsZSDDoCBsJ2hvcml6b250YWxlLCBtZXQgbGUgY29tcGFzIHZlcnRpY2FsIGV0IMOpY2FydGUgbGUgY29tcGFzIGxlIGxvbmcgZGUgbGEgcsOoZ2xlIHBvdXIgbGlyZSBzb24gw6ljYXJ0ZW1lbnRcbiAgICogQHBhcmFtIHtpbnR9IGxvbmd1ZXVyXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zIDogdGhpcy52aXRlc3NlIC8gMiB9XG4gICAqL1xuICB0aGlzLmNvbXBhc0VjYXJ0ZXJBdmVjUmVnbGUgPSBmdW5jdGlvbiAobCwgeyB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UsIHNlbnMgPSB0aGlzLnZpdGVzc2UgLyAyIH0gPSB7fSkge1xuICAgIHRoaXMucmVnbGVSb3RhdGlvbigwLCB7IHRlbXBvOiAwLCBzZW5zOiBzZW5zIH0pXG4gICAgdGhpcy5yZWdsZU1vbnRyZXIodGhpcy5jb21wYXMucG9zaXRpb24sIHsgdGVtcG86IDAgfSlcbiAgICB0aGlzLnJlZ2xlRGVwbGFjZXIodGhpcy5jb21wYXMucG9zaXRpb24sIHsgdGVtcG86IDAsIHZpdGVzc2U6IHZpdGVzc2UgfSlcbiAgICB0aGlzLmNvbXBhc01vbnRyZXIoKVxuICAgIHRoaXMuY29tcGFzUm90YXRpb24oMCwgeyB0ZW1wbzogMCwgc2Vuczogc2VucyB9KVxuICAgIHRoaXMuY29tcGFzRWNhcnRlcihsLCB7IHRlbXBvOiB0ZW1wbywgdml0ZXNzZTogdml0ZXNzZSwgc2Vuczogc2VucyB9KVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7cG9pbnR9IEEgUG9pbnRlIGR1IGNvbXBhc1xuICogQHBhcmFtIHtwb2ludH0gQiBNaW5lIGR1IGNvbXBhc1xuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zIDogdGhpcy52aXRlc3NlIC8gMiB9XG4gKi9cbiAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyA9IGZ1bmN0aW9uIChBLCBCLCB7IHRlbXBvID0gdGhpcy50ZW1wbywgdml0ZXNzZSA9IHRoaXMudml0ZXNzZSwgc2VucyA9IGNhbGN1bCh0aGlzLnZpdGVzc2UgLyAyKSB9ID0ge30pIHtcbiAgICB0aGlzLmNvbXBhc01vbnRyZXIoQSlcbiAgICB0aGlzLmNvbXBhc0RlcGxhY2VyKEEsIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlIH0pXG4gICAgY29uc3QgcyA9IHNlZ21lbnQoQSwgQilcbiAgICBzLmlzVmlzaWJsZSA9IGZhbHNlXG4gICAgY29uc3QgYW5nbGUgPSBzLmFuZ2xlQXZlY0hvcml6b250YWxlXG4gICAgdGhpcy5jb21wYXNSb3RhdGlvbihhbmdsZSwgeyB0ZW1wbzogdGVtcG8sIHNlbnM6IHNlbnMgfSlcbiAgICB0aGlzLmNvbXBhc0VjYXJ0ZXIobG9uZ3VldXIoQSwgQiksIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlIH0pXG4gIH1cbiAgLyoqXG4gKiBSZW1ldHRyZSBsZSBjb21wYXMgZW4gcG9zaXRpb24gc3RhbmRhcmQuIFNvbiDDqXRhdCBlc3Qgc2F1dmVnYXJkw6kgZGFucyBsZSBib29sw6llbiB0aGlzLmNvbXBhcy5sZXZlLlxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gKi9cbiAgdGhpcy5jb21wYXNMZXZlciA9IGZ1bmN0aW9uICh7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuY29tcGFzLmxldmUpIHsgLy8gT24gbmUgZmFpdCByaWVuIHNpIGxlIGNvbXBhcyBlc3QgZMOpasOgIGxldsOpXG4gICAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gbW91dmVtZW50PVwibGV2ZXJcIiBvYmpldD1cImNvbXBhc1wiIHRlbXBvPVwiJHt0ZW1wb30gLz5gXG4gICAgICB0aGlzLmNvbXBhcy5sZXZlID0gdHJ1ZVxuICAgICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChjb2RlWE1MKVxuICAgIH1cbiAgfVxuICAvKipcbiAqIFZvaXIgbGUgY29tcGFzIGVuIHZ1ZSBkZSBkZXNzdXMgYXZhbnQgcXUnaWwgdHJhY2UgdW4gYXJjIGRlIGNlcmNsZVxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gKi9cbiAgdGhpcy5jb21wYXNDb3VjaGVyID0gZnVuY3Rpb24gKHsgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmNvbXBhcy5sZXZlKSB7IC8vIE9uIG5lIGZhaXQgcmllbiBzaSBsZSBjb21wYXMgZXN0IGTDqWrDoCBsZXbDqVxuICAgICAgY29uc3QgY29kZVhNTCA9IGA8YWN0aW9uIG1vdXZlbWVudD1cImNvdWNoZXJcIiBvYmpldD1cImNvbXBhc1wiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmBcbiAgICAgIHRoaXMuY29tcGFzLmxldmUgPSBmYWxzZVxuICAgICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChjb2RlWE1MKVxuICAgIH1cbiAgfVxuICAvKipcbiAqIFRyYWNlIHVuIGFyYyBkZSBjZXJjbGUgZW4gZ2FyZGFudCBsJ8OpY2FydGVtZW50IGV0IGxlIGNlbnRyZSBhY3R1ZWwuIEwnYW5nbGUgZGUgZMOpcGFydCBzZXJhIGNob2lzaSBwb3VyIMOqdHJlIGxlIHBsdXMgcHJvY2hlIGRlIGwnYW5nbGUgYWN0dWVsXG4gKiBAcGFyYW0ge2ludH0gYW5nbGUxXG4gKiBAcGFyYW0ge2ludH0gYW5nbGUyXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7IHRlbXBvOiB0aGlzLnRlbXBvLCBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyLCBlcGFpc3NldXI6IHRoaXMuZXBhaXNzZXVyLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb21wYXMsIHBvaW50aWxsZXM6IHRoaXMucG9pbnRpbGxlcyB9XG4gKiBAcmV0dXJuIHtpZH1cbiAqL1xuICB0aGlzLmNvbXBhc1RyYWNlckFyYzJBbmdsZXMgPSBmdW5jdGlvbiAoYW5nbGUxLCBhbmdsZTIsIHsgdGVtcG8gPSB0aGlzLnRlbXBvLCBzZW5zID0gY2FsY3VsKHRoaXMudml0ZXNzZSAvIDIsIDApLCBlcGFpc3NldXIgPSB0aGlzLmVwYWlzc2V1ciwgY291bGV1ciA9IHRoaXMuY291bGV1ckNvbXBhcywgcG9pbnRpbGxlcyA9IHRoaXMucG9pbnRpbGxlcyB9ID0ge30pIHtcbiAgICBjb25zdCBwb2ludGlsbGVzVGV4dGUgPSBwb2ludGlsbGVzID8gJ3BvaW50aWxsZT1cInRpcmV0XCInIDogJydcbiAgICB0aGlzLmlkSUVQICs9IDFcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb21wYXMuYW5nbGUgLSBhbmdsZTEpID4gTWF0aC5hYnModGhpcy5jb21wYXMuYW5nbGUgLSBhbmdsZTIpKSB7IC8vIE9uIGNoZXJjaGUgw6AgY29tbWVuY2VyIHBhciBsZSBwb2ludCBsZSBwbHVzIHByb2NoZSBkZSBsYSBwb3NpdGlvbiBjb3VyYW50ZSBkdSBjb21wYXNcbiAgICAgIFthbmdsZTEsIGFuZ2xlMl0gPSBbYW5nbGUyLCBhbmdsZTFdXG4gICAgfVxuICAgIGxldCBjb2RlWE1MID0gYDxhY3Rpb24gc2Vucz1cIiR7c2Vuc31cIiBhbmdsZT1cIiR7LWFuZ2xlMX1cIiBtb3V2ZW1lbnQ9XCJyb3RhdGlvblwiIG9iamV0PVwiY29tcGFzXCIgdGVtcG89XCIke3RlbXBvfVwiIC8+XFxuYFxuICAgIGNvZGVYTUwgKz0gJzxhY3Rpb24gbW91dmVtZW50PVwibGV2ZXJcIiBvYmpldD1cImNvbXBhc1wiIC8+XFxuJ1xuICAgIGNvZGVYTUwgKz0gYDxhY3Rpb24gc2Vucz1cIiR7c2Vuc31cIiBhbmdsZT1cIiR7LWFuZ2xlMX1cIiBtb3V2ZW1lbnQ9XCJyb3RhdGlvblwiIG9iamV0PVwiY29tcGFzXCIgLz5cXG5gXG4gICAgbGV0IHNlbnNUZXh0ZVxuICAgIGlmIChhbmdsZTIgPiBhbmdsZTEpIHtcbiAgICAgIHNlbnNUZXh0ZSA9IHNlbnNcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vuc1RleHRlID0gLTEgKiBzZW5zXG4gICAgfVxuICAgIGNvZGVYTUwgKz0gYDxhY3Rpb24gY291bGV1cj1cIiR7Y291bGV1cn1cIiBlcGFpc3NldXI9XCIke2VwYWlzc2V1cn1cIiBzZW5zPVwiJHtzZW5zVGV4dGV9XCIgZGVidXQ9XCIkey1hbmdsZTF9XCIgZmluPVwiJHstYW5nbGUyfVwiIG1vdXZlbWVudD1cInRyYWNlclwiIG9iamV0PVwiY29tcGFzXCIgICR7cG9pbnRpbGxlc1RleHRlfSBpZD1cIiR7dGhpcy5pZElFUH1cIiAvPlxcbmBcbiAgICBjb2RlWE1MICs9IGA8YWN0aW9uIG1vdXZlbWVudD1cImNvdWNoZXJcIiBvYmpldD1cImNvbXBhc1wiIHRlbXBvPVwiJHt0ZW1wb31cIi8+YFxuICAgIHRoaXMuY29tcGFzLmFuZ2xlID0gYW5nbGUyXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChjb2RlWE1MKVxuICAgIHJldHVybiB0aGlzLmlkSUVQXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIHVuIGFyYyBkZSBjZXJjbGUgYXV0b3VyIGQndW4gcG9pbnQuIExhIGxvbmd1ZXVyIGRlIGwnYXJjIGVzdCBkw6l0ZXJtaW7DqWUgcGFyIGwnb3B0aW9uIGRlbHRhIGVuIGRlZ3LDqSBxdWkgZXN0IGFqb3V0w6llIGRlIHBhcnQgZXQgZCdhdXRyZSBkdSBwb2ludFxuICAgKiBAcGFyYW0ge3BvaW50fSBjZW50cmVcbiAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyBkZWx0YTogMTAsIHRlbXBvOiB0aGlzLnRlbXBvLCBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyLCBlcGFpc3NldXI6IHRoaXMuZXBhaXNzZXVyLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb21wYXMsIHBvaW50aWxsZXM6IHRoaXMucG9pbnRpbGxlcyB9XG4gICAqIEByZXR1cm4ge2lkfVxuICAgKi9cbiAgdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludCA9IGZ1bmN0aW9uIChjZW50cmUsIHBvaW50LCB7IGRlbHRhID0gMTAsIHRlbXBvID0gdGhpcy50ZW1wbywgdml0ZXNzZSA9IHRoaXMudml0ZXNzZSwgc2VucyA9IGNhbGN1bCh0aGlzLnZpdGVzc2UgLyAyLCAwKSwgZXBhaXNzZXVyID0gdGhpcy5lcGFpc3NldXIsIGNvdWxldXIgPSB0aGlzLmNvdWxldXJDb21wYXMsIHBvaW50aWxsZXMgPSB0aGlzLnBvaW50aWxsZXMgfSA9IHt9KSB7XG4gICAgdGhpcy5jb21wYXNNb250cmVyKClcbiAgICB0aGlzLmNvbXBhc0RlcGxhY2VyKGNlbnRyZSwgeyB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UgfSlcbiAgICBjb25zdCBzID0gc2VnbWVudChjZW50cmUsIHBvaW50KVxuICAgIHMudmlzaWJpbGl0eSA9IGZhbHNlXG4gICAgY29uc3QgYW5nbGUxID0gcy5hbmdsZUF2ZWNIb3Jpem9udGFsZSAtIGRlbHRhXG4gICAgY29uc3QgYW5nbGUyID0gcy5hbmdsZUF2ZWNIb3Jpem9udGFsZSArIGRlbHRhXG4gICAgaWYgKChNYXRoLmFicyh0aGlzLmNvbXBhcy5lY2FydGVtZW50IC0gbG9uZ3VldXIodGhpcy5jb21wYXMucG9zaXRpb24sIHBvaW50KSkpID4gMC4xKSB7XG4gICAgICB0aGlzLmNvbXBhc0VjYXJ0ZXIobG9uZ3VldXIoY2VudHJlLCBwb2ludCksIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBhc1RyYWNlckFyYzJBbmdsZXMoYW5nbGUxLCBhbmdsZTIsIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlLCBlcGFpc3NldXI6IGVwYWlzc2V1ciwgc2Vuczogc2VucywgY291bGV1cjogY291bGV1ciwgcG9pbnRpbGxlczogcG9pbnRpbGxlcyB9KVxuICB9XG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7cG9pbnR9IGNlbnRyZVxuICogQHBhcmFtIHtwb2ludH0gcG9pbnQgUG9pbnQgZGUgZMOpcGFydCBkdSB0cmFjw6kgZHUgY2VyY2xlXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7IHRlbXBvOiB0aGlzLnRlbXBvLCBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyLCBlcGFpc3NldXI6IHRoaXMuZXBhaXNzZXVyLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb21wYXMsIHBvaW50aWxsZXM6IHRoaXMucG9pbnRpbGxlcyB9XG4gKi9cbiAgdGhpcy5jb21wYXNDZXJjbGVDZW50cmVQb2ludCA9IGZ1bmN0aW9uIChjZW50cmUsIHBvaW50LCB7IHRlbXBvID0gdGhpcy50ZW1wbywgY291bGV1ciA9IHRoaXMuY291bGV1ciwgdml0ZXNzZSA9IHRoaXMudml0ZXNzZSwgc2VucyA9IGNhbGN1bCh0aGlzLnZpdGVzc2UgLyAyKSwgZXBhaXNzZXVyID0gdGhpcy5lcGFpc3NldXIsIHBvaW50aWxsZXMgPSB0aGlzLnBvaW50aWxsZXMgfSA9IHt9KSB7XG4gICAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyhjZW50cmUsIHBvaW50LCB7IHZpdGVzc2U6IHZpdGVzc2UsIHRlbXBvOiB0ZW1wbyB9KVxuICAgIGNvbnN0IGQgPSBkcm9pdGUoY2VudHJlLCBwb2ludClcbiAgICBjb25zdCBhbmdsZTEgPSBkLmFuZ2xlQXZlY0hvcml6b250YWxlXG4gICAgdGhpcy5jb21wYXNUcmFjZXJBcmMyQW5nbGVzKGFuZ2xlMSwgYW5nbGUxICsgMzYwLCB7IHRlbXBvOiB0ZW1wbywgdml0ZXNzZTogdml0ZXNzZSwgc2Vuczogc2VucywgZXBhaXNzZXVyOiBlcGFpc3NldXIsIGNvdWxldXI6IGNvdWxldXIsIHBvaW50aWxsZXM6IHBvaW50aWxsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKioqKioqKiogUkVRVUVSUkUgKioqKioqKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICovXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW50fSBkw6lwbGFjZW1lbnQgZW4gbm9tYnJlIGRlIGNtIChsZSBkw6lwbGFjZW1lbnQgcGV1dCDDqnRyZSBwb3NpdGlmIG91IG7DqWdhdGlmKVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8sIHZpdGVzc2U6IHRoaXMudml0ZXNzZSB9XG4gICAqL1xuICB0aGlzLnJlcXVlcnJlR2xpc3NlckVxdWVycmUgPSBmdW5jdGlvbiAoYSwgeyB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UgfSA9IHt9KSB7XG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBhYnNjaXNzZT1cIiR7YSAqIDMwfVwiIG1vdXZlbWVudD1cImdsaXNzZXJcIiBvYmpldD1cInJlcXVlcnJlXCIgdGVtcG89XCIke3RlbXBvfVwiIHZpdGVzc2U9XCIke3ZpdGVzc2V9XCIgLz5gKVxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqKioqKioqIFJBUFBPUlRFVVIgKioqKioqKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvLyBOb24gcHJpcyBlbiBjaGFyZ2UgcGFyIGxlIGxlY3RldXIgSlNcbiAgLy8gdGhpcy5yYXBwb3J0ZXVyQ2lyY3VsYWlyZSA9IGZ1bmN0aW9uICh0ZW1wbz10aGlzLnRlbXBvKSB7XG4gIC8vIC8vICAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIG1vdXZlbWVudD1cImNpcmN1bGFpcmVcIiBvYmpldD1cInJhcHBvcnRldXJcIiB0ZW1wbz1cIiR7dGVtcG99XCIvPmApXG4gIC8vIH1cbiAgLy8gdGhpcy5yYXBwb3J0ZXVyU2VtaUNpcmN1bGFpcmUgPSBmdW5jdGlvbiAodGVtcG89dGhpcy50ZW1wbykge1xuICAvLyAvLyAgICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBtb3V2ZW1lbnQ9XCJzZW1pY2lyY3VsYWlyZVwiIG9iamV0PVwicmFwcG9ydGV1clwiIHRlbXBvPVwiJHt0ZW1wb31cIi8+YClcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBNYXNxdWUgbGEgZ3JhZHVhdGlvbiBleHRlcm5lIGR1IHJhcHBvcnRldXIgKGxhaXNzZSBsJ2F1dHJlIGdyYWR1YXRpb24gdmlzaWJsZSlcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gICAqL1xuICB0aGlzLnJhcHBvcnRldXJNYXNxdWVyR3JhZHVhdGlvbnNFeHRlcmlldXJlcyA9IGZ1bmN0aW9uICh7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIG1vdXZlbWVudD1cIm1hc3F1ZXJfbm9tYnJlc1wiIG9iamV0PVwicmFwcG9ydGV1clwiIHRlbXBvPVwiJHt0ZW1wb31cIi8+YClcbiAgfVxuICAvKipcbiAgICogTW9udHJlIGxhIGdyYWR1YXRpb24gZXh0w6lyaWV1cmUgc2kgZWxsZSBhdmFpdCDDqXTDqSBwcsOpY8OpZGVtbWVudCBjYWNow6llXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8gfVxuICAgKi9cbiAgdGhpcy5yYXBwb3J0ZXVyTW9udHJlckdyYWR1YXRpb25zRXh0ZXJpZXVyZXMgPSBmdW5jdGlvbiAoeyB0ZW1wbyA9IHRoaXMudGVtcG8gfSA9IHt9KSB7XG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBtb3V2ZW1lbnQ9XCJtb250cmVyX25vbWJyZXNcIiBvYmpldD1cInJhcHBvcnRldXJcIiB0ZW1wbz1cIiR7dGVtcG99XCIvPmApXG4gIH1cbiAgLyoqXG4gICAqIE1hc3F1ZSBsYSBncmFkdWF0aW9uIGludGVybmUgZHUgcmFwcG9ydGV1ciAobGFpc3NlIGwnYXV0cmUgZ3JhZHVhdGlvbiB2aXNpYmxlKVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7IHRlbXBvOiB0aGlzLnRlbXBvIH1cbiAgICovXG4gIHRoaXMucmFwcG9ydGV1ck1hc3F1ZXJHcmFkdWF0aW9uc0ludGVyaWV1cmVzID0gZnVuY3Rpb24gKHsgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gbW91dmVtZW50PVwidmlkZVwiIG9iamV0PVwicmFwcG9ydGV1clwiIHRlbXBvPVwiJHt0ZW1wb31cIi8+YClcbiAgfVxuICAvKipcbiAgICogTW9udHJlIGxhIGdyYWR1YXRpb24gaW50ZXJuZSBzaSBlbGxlIGF2YWl0IMOpdMOpIHByw6ljw6lkZW1tZW50IGNhY2jDqWVcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gICAqL1xuICB0aGlzLnJhcHBvcnRldXJNb250cmVyR3JhZHVhdGlvbnNJbnRlcmlldXJlcyA9IGZ1bmN0aW9uICh7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIG1vdXZlbWVudD1cImdyYWR1YXRpb25zXCIgb2JqZXQ9XCJyYXBwb3J0ZXVyXCIgdGVtcG89XCIke3RlbXBvfVwiLz5gKVxuICB9XG4gIC8qKlxuICogTWV0IGxlIHJhcHBvcnRldXIgZW4gcG9zaXRpb24gYXZlYyBsZSBjZW50cmUgZW4gQSBldCBsZSAwIGRlIGRyb2l0ZSBhbG9nbsOpIGF2ZWMgbGUgcG9pbnQgQlxuICogQHBhcmFtIHtwb2ludH0gQVxuICogQHBhcmFtIHtwb2ludH0gQlxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zIDogdGhpcy52aXRlc3NlIC8gMiB9XG4gKi9cbiAgdGhpcy5yYXBwb3J0ZXVyRGVwbGFjZXJSb3RhdGlvbjJQb2ludHMgPSBmdW5jdGlvbiAoQSwgQiwgeyB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UsIHNlbnMgPSBjYWxjdWwodGhpcy52aXRlc3NlIC8gMikgfSA9IHt9KSB7XG4gICAgY29uc3QgZCA9IGRyb2l0ZShBLCBCKVxuICAgIGQuaXNWaXNpYmxlID0gZmFsc2VcbiAgICB0aGlzLnJhcHBvcnRldXJNb250cmVyKClcbiAgICB0aGlzLnJhcHBvcnRldXJEZXBsYWNlcihBLCB7IHRlbXBvOiB0ZW1wbywgdml0ZXNzZTogdml0ZXNzZSB9KVxuICAgIHRoaXMucmFwcG9ydGV1clJvdGF0aW9uKGQuYW5nbGVBdmVjSG9yaXpvbnRhbGUsIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlLCBzZW5zOiBzZW5zIH0pXG4gIH1cbiAgLyoqXG4gKiBGYWlzIHVuZSBwZXRpdGUgbWFycXVlIChjb3VsZXVyIGV0IMOpcGFpc3NldXIgZCd1biB0cmFpdCBkZSBjb25zdHJ1Y3Rpb24pIHN1ciB1bmUgZ3JhZHVhdGlvbiBkdSByYXBwb3J0ZXVyXG4gKiBAcGFyYW0ge2ludH0gYW5nbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8sIHZpdGVzc2U6IHRoaXMudml0ZXNzZSwgY291bGV1cjogdGhpcy5jb3VsZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24sIGVwYWlzc2V1cjogdGhpcy5lcGFpc3NldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiB9XG4gKi9cbiAgdGhpcy5yYXBwb3J0ZXVyQ3JheW9uTWFycXVlQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUsIHsgdGVtcG8gPSB0aGlzLnRlbXBvLCB2aXRlc3NlID0gdGhpcy52aXRlc3NlLCBjb3VsZXVyID0gdGhpcy5jb3VsZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24sIGVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24gfSA9IHt9KSB7XG4gICAgY29uc3QgTyA9IHRoaXMucmFwcG9ydGV1ci5wb3NpdGlvblxuICAgIGNvbnN0IE0gPSBwb2ludEFkaXN0YW5jZShPLCA1LjIsIGFuZ2xlICsgdGhpcy5yYXBwb3J0ZXVyLmFuZ2xlKVxuICAgIGNvbnN0IE4gPSBwb2ludEFkaXN0YW5jZShPLCA1LjUsIGFuZ2xlICsgdGhpcy5yYXBwb3J0ZXVyLmFuZ2xlKVxuICAgIHRoaXMuY3JheW9uTW9udHJlcigpXG4gICAgdGhpcy5jcmF5b25EZXBsYWNlcihNLCB7IHRlbXBvOiB0ZW1wbywgdml0ZXNzZTogdml0ZXNzZSB9KVxuICAgIHRoaXMudHJhY2VyKE4sIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlLCBjb3VsZXVyOiBjb3VsZXVyLCBlcGFpc3NldXI6IGVwYWlzc2V1ciB9KVxuICB9XG4gIC8qKlxuICogTGUgY3JheW9uIHZhIGZhaXJlIHVuZSBtYXJxdWUgc3VyIGxhIGdyYWR1YXRpb24gZHUgcmFwcG9ydGV1ciwgbGUgcmFwcG9ydGV1ciB2YSBzZSBjYWNoZXIgZXQgb24gdHJhY2UgdW5lIGRlbWktZHJvaXRlIGRvbnQgb24gcGV1dCBjaG9pc2lyIGxhIFwibG9uZ3VldXJcIiAocGFyIGTDqWZhdXQgOTAlIGRlIGNlbGxlIGRlIGxhIHLDqGdsZSlcbiAqIEBwYXJhbSB7cG9pbnR9IEEgQ2VudHJlIGR1IHJhcHBvcnRldXJcbiAqIEBwYXJhbSB7cG9pbnR9IEIgUG9pbnQgYXZlYyBsZXF1ZWwgbGUgMCBkZSBkcm9pdGUgc2VyYSBhbGlnbsOpXG4gKiBAcGFyYW0ge2ludH0gYW5nbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgeyBsb25ndWV1cjogMC45ICogdGhpcy5yZWdsZS5sb25ndWV1ciwgY291bGV1cjogdGhpcy5jb3VsZXVyLCB0ZW1wbzogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zIDogdGhpcy52aXRlc3NlIC8gMiwgZXBhaXNzZXVyOiB0aGlzLmVwYWlzc2V1ciwgcG9pbnRpbGxlczogdGhpcy5wb2ludGlsbGVzIH1cbiAqL1xuICB0aGlzLnJhcHBvcnRldXJUcmFjZXJEZW1pRHJvaXRlQW5nbGUgPSBmdW5jdGlvbiAoQSwgQiwgYW5nbGUsIHsgbG9uZ3VldXIgPSAwLjkgKiB0aGlzLnJlZ2xlLmxvbmd1ZXVyLCBjb3VsZXVyID0gdGhpcy5jb3VsZXVyLCB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UsIHNlbnMgPSBjYWxjdWwodGhpcy52aXRlc3NlIC8gMiksIGVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyLCBwb2ludGlsbGVzID0gdGhpcy5wb2ludGlsbGVzIH0gPSB7fSkge1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHRoaXMucmFwcG9ydGV1ckRlcGxhY2VyUm90YXRpb24yUG9pbnRzKEEsIEIsIHsgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlLCBzZW5zOiBzZW5zIH0pXG4gICAgICB0aGlzLnJhcHBvcnRldXJDcmF5b25NYXJxdWVBbmdsZShhbmdsZSwgeyB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UsIHNlbnM6IHNlbnMgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgQjIgPSByb3RhdGlvbihCLCBBLCAxODApXG4gICAgICB0aGlzLnJhcHBvcnRldXJEZXBsYWNlclJvdGF0aW9uMlBvaW50cyhBLCBCMiwgeyB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UsIHNlbnM6IHNlbnMgfSlcbiAgICAgIHRoaXMucmFwcG9ydGV1ckNyYXlvbk1hcnF1ZUFuZ2xlKDE4MCAtIE1hdGguYWJzKGFuZ2xlKSwgeyB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UsIHNlbnM6IHNlbnMgfSlcbiAgICB9XG4gICAgY29uc3QgZCA9IGRyb2l0ZShBLCBCKVxuICAgIGQuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBNID0gcG9pbnRBZGlzdGFuY2UoQSwgY2FsY3VsKDUuMiAqIHRoaXMucmFwcG9ydGV1ci56b29tIC8gMTAwLCAxKSwgZC5hbmdsZUF2ZWNIb3Jpem9udGFsZSArIGFuZ2xlKVxuICAgIHRoaXMucmFwcG9ydGV1ck1hc3F1ZXIoeyB0ZW1wbzogdGVtcG8gfSlcbiAgICB0aGlzLnJlZ2xlRGVtaURyb2l0ZU9yaWdpbmVQb2ludChBLCBNLCB7IGxvbmd1ZXVyOiBsb25ndWV1ciwgY291bGV1cjogY291bGV1ciwgdGVtcG86IHRlbXBvLCB2aXRlc3NlOiB2aXRlc3NlLCBzZW5zOiBzZW5zLCBlcGFpc3NldXI6IGVwYWlzc2V1ciwgcG9pbnRpbGxlczogcG9pbnRpbGxlcyB9KVxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqKioqKioqKiogUkVHTEUgKioqKioqKioqKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvKipcbiAqIE1hc3F1ZXIgbGVzIGdyYWR1YXRpb25zIHN1ciBsYSByw6hnbGVcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8gfVxuICovXG4gIHRoaXMucmVnbGVNYXNxdWVyR3JhZHVhdGlvbnMgPSBmdW5jdGlvbiAoeyB0ZW1wbyA9IHRoaXMudGVtcG8gfSA9IHt9KSB7XG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBtb3V2ZW1lbnQ9XCJ2aWRlXCIgb2JqZXQ9XCJyZWdsZVwiIHRlbXBvPVwiJHt0ZW1wb31cIi8+YClcbiAgfVxuICAvKipcbiAqIE1vbnRyZXIgbGVzIGdyYWR1YXRpb25zIHN1ciBsYSByw6hnbGUgc2kgZWxsZXMgYXZhaWVudCDDqXTDqSBtYXNxdcOpZXNcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IHRoaXMudGVtcG8gfVxuICovXG4gIHRoaXMucmVnbGVNb250cmVyR3JhZHVhdGlvbnMgPSBmdW5jdGlvbiAoeyB0ZW1wbyA9IHRoaXMudGVtcG8gfSA9IHt9KSB7XG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBtb3V2ZW1lbnQ9XCJncmFkdWF0aW9uc1wiIG9iamV0PVwicmVnbGVcIiB0ZW1wbz1cIiR7dGVtcG99XCIvPmApXG4gIH1cbiAgLyoqXG4gICAqIE1vZGlmaWUgbGEgdGFpbGxlIGRlIGxhIHLDqGdsZVxuICAgKiBAcGFyYW0ge2ludH0gbG9uZ3VldXJcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gICAqL1xuICB0aGlzLnJlZ2xlTW9kaWZpZXJMb25ndWV1ciA9IGZ1bmN0aW9uIChsb25ndWV1ciA9IDIwLCB7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICB0aGlzLnJlZ2xlLmxvbmd1ZXVyID0gbG9uZ3VldXJcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIG1vdXZlbWVudD1cIm1vZGlmaWVyX2xvbmd1ZXVyXCIgb2JqZXQ9XCJyZWdsZVwiIGxvbmd1ZXVyPVwiJHtsb25ndWV1cn1cIiB0ZW1wbz1cIiR7dGVtcG99XCIvPmApXG4gIH1cbiAgLyoqXG4gKiBUcmFjZSB1bmUgZGVtaS1kcm9pdGUgZCdvcmlnaW5lIE8gcGFzc2FudCBwYXIgQSAob3UgZW4gZGlyZWN0aW9uIGRlIEEgc2kgbGVzIHBvaW50cyBzb250IHRyb3Agw6lsb2lnbsOpcylcbiAqIEBwYXJhbSB7cG9pbnR9IE8gT3JpZ2luZVxuICogQHBhcmFtIHtwb2ludH0gQSBEaXJlY3Rpb25cbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCB7bG9uZ3VldXI6IHRoaXMucmVnbGUubG9uZ3VldXIsIHRlbXBvIDogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyfVxuICovXG4gIHRoaXMucmVnbGVEZW1pRHJvaXRlT3JpZ2luZVBvaW50ID0gZnVuY3Rpb24gKE8sIEEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghb3B0aW9ucy5sb25ndWV1cikge1xuICAgICAgb3B0aW9ucy5sb25ndWV1ciA9IHRoaXMucmVnbGUubG9uZ3VldXJcbiAgICB9XG4gICAgY29uc3QgTSA9IHBvaW50U3VyU2VnbWVudChPLCBBLCBvcHRpb25zLmxvbmd1ZXVyKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KE8sIE0sIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVHJhY2UgdW5lIGRyb2l0ZSBwYXNzYW5ydCBwYXIgbGVzIHBvaW50cyBBIGV0IEJcbiAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgKiBAcGFyYW0ge3BvaW50fSBCXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCB7bG9uZ3VldXI6IHRoaXMucmVnbGUubG9uZ3VldXIsIHRlbXBvIDogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyfVxuICAgKi9cbiAgdGhpcy5yZWdsZURyb2l0ZSA9IGZ1bmN0aW9uIChBLCBCLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnMubG9uZ3VldXIpIHtcbiAgICAgIG9wdGlvbnMubG9uZ3VldXIgPSB0aGlzLnJlZ2xlLmxvbmd1ZXVyXG4gICAgfVxuICAgIGNvbnN0IE0gPSBob21vdGhldGllKEIsIEEsIGNhbGN1bCgoLW9wdGlvbnMubG9uZ3VldXIgKiAwLjUgKyBsb25ndWV1cihBLCBCKSAqIDAuNSkgLyBsb25ndWV1cihBLCBCKSkpXG4gICAgY29uc3QgTiA9IGhvbW90aGV0aWUoQSwgQiwgY2FsY3VsKCgtb3B0aW9ucy5sb25ndWV1ciAqIDAuNSArIGxvbmd1ZXVyKEEsIEIpICogMC41KSAvIGxvbmd1ZXVyKEEsIEIpKSlcbiAgICBpZiAodGhpcy54KEEpIDw9IHRoaXMueChCKSkge1xuICAgICAgdGhpcy5yZWdsZU1vbnRyZXIoTSlcbiAgICAgIHRoaXMucmVnbGVSb3RhdGlvbihOLCBvcHRpb25zKVxuICAgICAgdGhpcy5yZWdsZVNlZ21lbnQoTSwgTiwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdsZU1vbnRyZXIoTilcbiAgICAgIHRoaXMucmVnbGVSb3RhdGlvbihNLCBvcHRpb25zKVxuICAgICAgdGhpcy5yZWdsZVNlZ21lbnQoTiwgTSwgb3B0aW9ucylcbiAgICB9XG4gIH1cbiAgLyoqXG4gKiBBdmVjIGxhIHLDqGdsZSwgb24gcHJvbG9uZ2UgbGUgc2VnbWVudCBkZSBsIGNtIGR1IGNvdMOpIGRlIGxhIDJlIGV4dHLDqW1pdMOpIHNpIGwgZXN0IHBvc2l0aWYgc2lub24gZHUgY8O0dMOpIGRlIGxhIHByZW1pw6hyZSBleHRyw6ltaXTDqVxuICogQHBhcmFtIHtwb2ludH0gQVxuICogQHBhcmFtIHtwb2ludH0gQlxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IHtsb25ndWV1cjogMywgdGVtcG86IHRoaXMudGVtcG8sIHZpdGVzc2U6IHRoaXMudml0ZXNzZSwgc2VuczogdGhpcy52aXRlc3NlIC8gMn1cbiAqL1xuICB0aGlzLnJlZ2xlUHJvbG9uZ2VyU2VnbWVudCA9IGZ1bmN0aW9uIChBLCBCLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnMubG9uZ3VldXIpIHtcbiAgICAgIG9wdGlvbnMubG9uZ3VldXIgPSB0aGlzLnJlZ2xlLmxvbmd1ZXVyIC0gM1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb25ndWV1ciA+IDApIHtcbiAgICAgIGNvbnN0IEIxID0gcG9pbnRTdXJTZWdtZW50KEIsIEEsIDMpXG4gICAgICBjb25zdCBCMiA9IHBvaW50U3VyU2VnbWVudChCLCBBLCAtb3B0aW9ucy5sb25ndWV1cilcbiAgICAgIHRoaXMucmVnbGVTZWdtZW50KEIxLCBCMiwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgQTEgPSBwb2ludFN1clNlZ21lbnQoQSwgQiwgMylcbiAgICAgIGNvbnN0IEEyID0gcG9pbnRTdXJTZWdtZW50KEEsIEIsIG9wdGlvbnMubG9uZ3VldXIpXG4gICAgICB0aGlzLnJlZ2xlU2VnbWVudChBMSwgQTIsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqKioqKioqKiogVFJBSVRTICoqKioqKioqKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvKipcbiAqIExlIGNyYXlvbiB0cmFjZSB1biB0cmFpdCBkZSBzYSBwb3NpdGlvbiBjb3VyYW50ZSBqdXNxdSdhdSBwb2ludCBCXG4gKiBAcGFyYW0ge3BvaW50fSBCXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgeyB0ZW1wbzogdGhpcy50ZW1wbywgdml0ZXNzZTogdGhpcy52aXRlc3NlLCBlcGFpc3NldXI6IHRoaXMuZXBhaXNzZXVyLCBjb3VsZXVyOiB0aGlzLmNvdWxldXIsIHBvaW50aWxsZXM6IHRoaXMucG9pbnRpbGxlcywgdmVjdGV1cjogZmFsc2UgfVxuICogQHJldHVybiB7aWR9IGlkIHV0aWxpc8OpZSBwb3VyIGxlIHRyYWPDqVxuICovXG4gIHRoaXMudHJhY2VyID0gZnVuY3Rpb24gKEIsIHsgdGVtcG8gPSB0aGlzLnRlbXBvLCB2aXRlc3NlID0gdGhpcy52aXRlc3NlLCBlcGFpc3NldXIgPSB0aGlzLmVwYWlzc2V1ciwgY291bGV1ciA9IHRoaXMuY291bGV1ciwgcG9pbnRpbGxlcyA9IHRoaXMucG9pbnRpbGxlcywgdmVjdGV1ciA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IHBvaW50aWxsZXNUZXh0ZSA9IHBvaW50aWxsZXMgPyAncG9pbnRpbGxlPVwidGlyZXRcIicgOiAnJ1xuICAgIGNvbnN0IHZlY3RldXJUZXh0ZSA9IHZlY3RldXIgPyAnc3R5bGU9XCJ2ZWN0ZXVyXCInIDogJydcbiAgICB0aGlzLmlkSUVQICs9IDFcbiAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gYWJzY2lzc2U9XCIke3RoaXMueChCKX1cIiBvcmRvbm5lZT1cIiR7dGhpcy55KEIpfVwiIGVwYWlzc2V1cj1cIiR7ZXBhaXNzZXVyfVwiIGNvdWxldXI9XCIke2NvdWxldXJ9XCIgbW91dmVtZW50PVwidHJhY2VyXCIgb2JqZXQ9XCJjcmF5b25cIiB0ZW1wbz1cIiR7dGVtcG99XCIgdml0ZXNzZT1cIiR7dml0ZXNzZX1cIiAgJHtwb2ludGlsbGVzVGV4dGV9ICR7dmVjdGV1clRleHRlfSBpZD1cIiR7dGhpcy5pZElFUH1cIiAvPmBcbiAgICB0aGlzLmNyYXlvbi5wb3NpdGlvbiA9IEJcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGNvZGVYTUwpXG4gICAgcmV0dXJuIHRoaXMuaWRJRVBcbiAgfVxuICAvKipcbiAgICogVHJhY2UgYXUgY3JheW9uIGxlIHNlZ21lbnQgW0FCXVxuICAgKiBAcGFyYW0ge3BvaW50fSBBIFByZW1pw6hyZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0ge3BvaW50fSBCIERldXhpw6htZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHJldHVybiB7aWR9IGlkIHV0aWxpc8OpZSBwb3VyIGxlIHRyYWPDqVxuICAgKi9cbiAgdGhpcy50cmFpdCA9IGZ1bmN0aW9uIChBLCBCLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNyYXlvbkRlcGxhY2VyKEEsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMudHJhY2VyKEIsIG9wdGlvbnMpXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIGF1IGNyYXlvbiBsZSBzZWdtZW50IFtBQl0gc2FucyB0ZW1wbyBldCBhdmVjIHVuZSB2aXRlc3NlIG11bHRpcGxpw6llIHBhciAxIDAwMFxuICAgKiBAcGFyYW0ge3BvaW50fSBBIFByZW1pw6hyZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0ge3BvaW50fSBCIERldXhpw6htZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHJldHVybiB7aWR9IGlkIHV0aWxpc8OpZSBwb3VyIGxlIHRyYWPDqVxuICAgKi9cbiAgdGhpcy50cmFpdFJhcGlkZSA9IGZ1bmN0aW9uIChBLCBCLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLnRlbXBvID0gMFxuICAgIG9wdGlvbnMudml0ZXNzZSA9IDEwMDAwXG4gICAgdGhpcy5jcmF5b25EZXBsYWNlcihBLCBvcHRpb25zKVxuICAgIHJldHVybiB0aGlzLnRyYWNlcihCLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICogTWFzcXVlIGxlIHRyYWl0IGQnaWQgZm91cm5pXG4gKiBAcGFyYW0ge2ludH0gaWRcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgdGVtcG86IDAsIHZpdGVzc2U6IDIwMCB9XG4gKi9cbiAgdGhpcy50cmFpdE1hc3F1ZXIgPSBmdW5jdGlvbiAoaWQsIHsgdGVtcG8gPSAwLCB2aXRlc3NlID0gMjAwIH0gPSB7fSkge1xuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gbW91dmVtZW50PVwibWFzcXVlclwiIG9iamV0PVwidHJhaXRcIiBpZD1cIiR7aWR9XCIgdml0ZXNzZT1cIiR7dml0ZXNzZX1cIiAvPmApXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c2VnbWVudC9wb2ludH0gU2VnbWVudCDDoCB0cmFjZXIgb3UgcHJlbWnDqHJlIGV4dHLDqW1pdMOpXG4gICAqIEBwYXJhbSB7b2JqZXQvcG9pbnR9IG9wdGlvbnMgb3UgZGV1eGnDqG1lIGV4dHLDqW1pdMOpXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgc2kgbGVzIGRldXggcHJlbWllcnMgYXJndW1lbnRzIMOpdGFpZW50IGRlcyBwb2ludHNcbiAgICogQHJldHVybnMge2lkfSBpZGVudGlmaWFudCB1dGlsaXPDqSBwb3VyIGxlIHRyYWl0XG4gICAqL1xuICB0aGlzLnJlZ2xlU2VnbWVudCA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgbGV0IEEsIEIsIG9wdGlvbnMsIGlkXG4gICAgaWYgKGFyZzEudHlwZU9iamV0ID09PSAnc2VnbWVudCcpIHtcbiAgICAgIEEgPSBhcmcxLmV4dHJlbWl0ZTFcbiAgICAgIEIgPSBhcmcxLmV4dHJlbWl0ZTJcbiAgICAgIG9wdGlvbnMgPSBhcmcyXG4gICAgfSBlbHNlIHtcbiAgICAgIEEgPSBhcmcxXG4gICAgICBCID0gYXJnMlxuICAgICAgb3B0aW9ucyA9IGFyZzNcbiAgICB9XG4gICAgaWYgKEEueCA8PSBCLngpIHsgLy8gVG91am91cnMgYXZvaXIgbGEgcsOoZ2xlIGRlIGdhdWNoZSDDoCBkcm9pdGVcbiAgICAgIHRoaXMucmVnbGVNb250cmVyKEEsIG9wdGlvbnMpXG4gICAgICB0aGlzLnJlZ2xlUm90YXRpb24oQiwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdsZU1vbnRyZXIoQiwgb3B0aW9ucylcbiAgICAgIHRoaXMucmVnbGVSb3RhdGlvbihBLCBvcHRpb25zKVxuICAgIH1cbiAgICBpZiAobG9uZ3VldXIodGhpcy5jcmF5b24ucG9zaXRpb24sIEEpIDwgbG9uZ3VldXIodGhpcy5jcmF5b24ucG9zaXRpb24sIEIpKSB7IC8vIExlIGNyYXlvbiBpcmEgYXUgcG9pbnQgbGUgcGx1cyBwcm9jaGVcbiAgICAgIHRoaXMuY3JheW9uTW9udHJlcihBLCBvcHRpb25zKVxuICAgICAgaWQgPSB0aGlzLnRyYWNlcihCLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyYXlvbk1vbnRyZXIoQiwgb3B0aW9ucylcbiAgICAgIGlkID0gdGhpcy50cmFjZXIoQSwgb3B0aW9ucylcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIHVuIHBvbHlnb25lIGF2ZWMgbGVzIG9wdGlvbnMgcGFyIGTDqWZhdXQgcXVlIGwnb24gbmUgcGV1dCBwYXMgY2hhbmdlciBpY2lcbiAgICogQHBhcmFtICB7Li4ucG9pbnRzfSBzb21tZXRzIGR1IHBvbHlnb25uZSBzw6lwYXLDqXMgcGFyIGRlcyB2aXJndWxlc1xuICAgKi9cbiAgdGhpcy5wb2x5Z29uZVRyYWNlciA9IGZ1bmN0aW9uICguLi5zb21tZXRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb21tZXRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGhpcy5yZWdsZVNlZ21lbnQoc29tbWV0c1tpXSwgc29tbWV0c1tpICsgMV0pXG4gICAgfVxuICAgIHRoaXMucmVnbGVTZWdtZW50KHNvbW1ldHNbc29tbWV0cy5sZW5ndGggLSAxXSwgc29tbWV0c1swXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFjZSB1biBwb2x5Z29uZSBhdmVjIHRyYWl0UmFwaWRlKClcbiAgICogQHBhcmFtICB7Li4ucG9pbnRzfSBzb21tZXRzIGR1IHBvbHlnb25uZSBzw6lwYXLDqXMgcGFyIGRlcyB2aXJndWxlc1xuICAgKi9cbiAgdGhpcy5wb2x5Z29uZVJhcGlkZSA9IGZ1bmN0aW9uICguLi5zb21tZXRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb21tZXRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGhpcy50cmFpdFJhcGlkZShzb21tZXRzW2ldLCBzb21tZXRzW2kgKyAxXSlcbiAgICB9XG4gICAgdGhpcy50cmFpdFJhcGlkZShzb21tZXRzW3NvbW1ldHMubGVuZ3RoIC0gMV0sIHNvbW1ldHNbMF0pXG4gIH1cblxuICAvKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICoqKioqKioqKiBURVhURSAqKioqKioqKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4gIC8qKlxuICAgKiBFY3JpcyB1biB0ZXh0ZSBjb2xsw6kgYXUgcG9pbnQuIE9uIHBldXQgY2hvaXNpciB1biBmb25kLCB1biBjYWRyZSwgbCdvcGFjaXTDqSBkdSBmb25kLCBsYSBwb2xpY2UuLi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRlXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgcG9saWNlOiBmYWxzZSwgY291bGV1cjogdGhpcy5jb3VsZXVyVGV4dGUsIGNvdWxldXJGb25kLCBvcGFjaXRlRm9uZCwgY291bGV1ckNhZHJlLCBlcGFpc3NldXJDYWRyZSwgbWFyZ2UsIG1hcmdlR2F1Y2hlLCBtYXJnZURyb2l0ZSwgbWFyZ2VIYXV0LCBtYXJnZUJhcyB9XG4gICAqIEByZXR1cm4ge2lkfVxuICAgKi9cbiAgdGhpcy50ZXh0ZVBvaW50ID0gZnVuY3Rpb24gKHRleHRlLCBBLCB7IHRlbXBvID0gdGhpcy50ZW1wbywgcG9saWNlID0gZmFsc2UsIGNvdWxldXIgPSB0aGlzLmNvdWxldXJUZXh0ZSwgdGFpbGxlLCBjb3VsZXVyRm9uZCwgb3BhY2l0ZUZvbmQsIGNvdWxldXJDYWRyZSwgZXBhaXNzZXVyQ2FkcmUsIG1hcmdlLCBtYXJnZUdhdWNoZSwgbWFyZ2VEcm9pdGUsIG1hcmdlSGF1dCwgbWFyZ2VCYXMgfSA9IHt9KSB7XG4gICAgdGhpcy5pZElFUCsrXG4gICAgY29uc3QgcG9saWNlVGV4dGUgPSBwb2xpY2UgPyBgcG9saWNlPVwiJHtwb2xpY2V9XCJgIDogJydcbiAgICBsZXQgb3B0aW9ucyA9ICcnXG4gICAgaWYgKHR5cGVvZiBjb3VsZXVyRm9uZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgKz0gYCBjb3VsZXVyX2ZvbmQ9XCIke2NvdWxldXJGb25kfVwiYFxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wYWNpdGVGb25kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucyArPSBgIG9wYWNpdGVfZm9uZD1cIiR7b3BhY2l0ZUZvbmR9XCJgXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY291bGV1ckNhZHJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucyArPSBgIGNvdWxldXJfY2FkcmU9XCIke2NvdWxldXJDYWRyZX1cImBcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcGFpc3NldXJDYWRyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgKz0gYCBlcGFpc3NldXJfY2FkcmU9XCIke2VwYWlzc2V1ckNhZHJlfVwiYFxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucyArPSBgIG1hcmdlPVwiJHttYXJnZX1cImBcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJnZUdhdWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgKz0gYCBtYXJnZV9nYXVjaGU9XCIke21hcmdlR2F1Y2hlfVwiYFxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmdlRHJvaXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucyArPSBgIG1hcmdlX2Ryb2l0ZT1cIiR7bWFyZ2VEcm9pdGV9XCJgXG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFyZ2VCYXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zICs9IGAgbWFyZ2VfYmFzPVwiJHttYXJnZUJhc31cImBcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJnZUhhdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zICs9IGAgbWFyZ2VfaGF1dD1cIiR7bWFyZ2VIYXV0fVwiYFxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhaWxsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgKz0gYCB0YWlsbGU9XCIke3RhaWxsZX1cImBcbiAgICB9XG4gICAgbGV0IGNvZGVYTUwgPSBgPGFjdGlvbiBhYnNjaXNzZT1cIiR7dGhpcy54KEEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQSl9XCIgaWQ9XCIke3RoaXMuaWRJRVB9XCIgbW91dmVtZW50PVwiY3JlZXJcIiBvYmpldD1cInRleHRlXCIgLz5gXG4gICAgY29kZVhNTCArPSBgXFxuPGFjdGlvbiAke3BvbGljZVRleHRlfSBjb3VsZXVyPVwiJHtjb3VsZXVyfVwiIHRleHRlPVwiJHt0ZXh0ZX1cIiBpZD1cIiR7dGhpcy5pZElFUH1cIiBtb3V2ZW1lbnQ9XCJlY3JpcmVcIiBvYmpldD1cInRleHRlXCIgJHtvcHRpb25zfSB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChjb2RlWE1MKVxuICAgIHJldHVybiB0aGlzLmlkSUVQXG4gIH1cbiAgLyoqXG4gICAqIEVjcmlzIHVuIHRleHRlIGNvbGzDqSBhdSBwb2ludCBkZSBjb29yZG9ubsOpZXMgKHgseSkuIE9uIHBldXQgY2hvaXNpciB1biBmb25kLCB1biBjYWRyZSwgbCdvcGFjaXTDqSBkdSBmb25kLCBsYSBwb2xpY2UuLi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRlXG4gICAqIEBwYXJhbSB7aW50fSB4IEFic2Npc3NlIGR1IGNvaW4gZW4gaGF1dCDDoCBnYXVjaGVcbiAgICogQHBhcmFtIHtpbnR9IHkgT3Jkb25uw6llIGR1IGNvaW4gZW4gaGF1dCDDoCBnYXVjaGVcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgcG9saWNlOiBmYWxzZSwgY291bGV1cjogdGhpcy5jb3VsZXVyVGV4dGUsIGNvdWxldXJGb25kLCBvcGFjaXRlRm9uZCwgY291bGV1ckNhZHJlLCBlcGFpc3NldXJDYWRyZSwgbWFyZ2UsIG1hcmdlR2F1Y2hlLCBtYXJnZURyb2l0ZSwgbWFyZ2VIYXV0LCBtYXJnZUJhcyB9XG4gICAqL1xuICB0aGlzLnRleHRlUG9zaXRpb24gPSBmdW5jdGlvbiAodGV4dGUsIHgsIHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBBID0gcG9pbnQoeCwgeSlcbiAgICByZXR1cm4gdGhpcy50ZXh0ZVBvaW50KHRleHRlLCBBLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5sb25ndWV1clNlZ21lbnQgPSBmdW5jdGlvbiAoQSwgQiwgZHksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsID0gY2FsY3VsKGxvbmd1ZXVyKEEsIEIsIDEpKVxuICAgIGNvbnN0IHYgPSB2ZWN0ZXVyKEEsIEIpXG4gICAgY29uc3QgdyA9IHZlY3RldXIoLXYueSAqIGR5IC8gbm9ybWUodiksIHYueCAqIGR5IC8gbm9ybWUodikpXG4gICAgY29uc3QgYW5jcmFnZSA9IHRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uKHBvaW50U3VyU2VnbWVudChBLCBCLCBsIC8gMiAtIDAuNyksIHcpLCB2ZWN0ZXVyKDAsIDEpKVxuICAgIHJldHVybiB0aGlzLnRleHRlUG9pbnQoYCR7bH0gY21gLCBhbmNyYWdlLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5tZXN1cmVBbmdsZSA9IGZ1bmN0aW9uIChBLCBPLCBCKSB7XG4gICAgY29uc3QgYSA9IGFuZ2xlT3JpZW50ZShBLCBPLCBCKVxuICAgIGNvbnN0IEMgPSB0cmFuc2xhdGlvbihob21vdGhldGllKHJvdGF0aW9uKEEsIE8sIGEgLyAyKSwgTywgMS4zIC8gbG9uZ3VldXIoTywgQSkpLCB2ZWN0ZXVyKC0wLjIsIDAuNSkpXG4gICAgcmV0dXJuIHRoaXMudGV4dGVQb2ludChNYXRoLmFicyhhKSArICfCsCcsIEMpXG4gIH1cbiAgLyoqXG4gKiBNYXNxdWUgbGUgdHJhaXQgZCdpZCBmb3VybmlcbiAqIEBwYXJhbSB7aW50fSBpZFxuICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogMCB9XG4gKi9cbiAgdGhpcy50ZXh0ZU1hc3F1ZXIgPSBmdW5jdGlvbiAoaWQsIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goYDxhY3Rpb24gbW91dmVtZW50PVwibWFzcXVlclwiIG9iamV0PVwidGV4dGVcIiBpZD1cIiR7aWR9XCIgIC8+YClcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXQgbCdhbmltYXRpb24gZW4gcGF1c2UgZm9yw6dhbnQgbCd1dGlsaXNhdGV1ciDDoCBhcHB1eWVyIHN1ciBsZWN0dXJlIHBvdXIgdm9pciBsYSBzdWl0ZVxuICAgKi9cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKCc8YWN0aW9uIG1vdXZlbWVudD1cInBhdXNlXCIgLz4nKVxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqKioqKioqIENPREFHRVMgKioqKioqKioqKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzZWdtZW50L3BvaW50fSBTZWdtZW50IMOgIGNvZGVyIG91IHByZW1pw6hyZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0ge29iamV0L3BvaW50fSBvcHRpb25zIG91IGRldXhpw6htZSBleHRyw6ltaXTDqVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIHNpIGxlcyBkZXV4IHByZW1pZXJzIGFyZ3VtZW50cyDDqXRhaWVudCBkZXMgcG9pbnRzLiBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbywgY291bGV1cjogdGhpcy5jb3VsZXVyQ29kYWdlLCBjb2RhZ2U6ICcvLycsIH1cbiAgICogQHJldHVybiB7aWR9XG4gICovXG4gIHRoaXMuc2VnbWVudENvZGFnZSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyID0ge30sIGFyZzMgPSB7fSkge1xuICAgIGxldCBzXG4gICAgbGV0IG9wdGlvbnMgPSB7fVxuICAgIGlmIChhcmcxLnR5cGVPYmpldCA9PT0gJ3NlZ21lbnQnKSB7XG4gICAgICBzID0gYXJnMVxuICAgICAgb3B0aW9ucyA9IGFyZzJcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHNlZ21lbnQoYXJnMSwgYXJnMilcbiAgICAgIG9wdGlvbnMgPSB7IC4uLmFyZzMgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW1wbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnRlbXBvID0gdGhpcy50ZW1wb1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb3VsZXVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY291bGV1ciA9IHRoaXMuY291bGV1ckNvZGFnZVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb2RhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5jb2RhZ2UgPSAnXFxcXCdcbiAgICB9XG4gICAgdGhpcy5pZElFUCsrXG4gICAgY29uc3QgaWQgPSB0aGlzLmlkSUVQXG4gICAgY29uc3QgTSA9IG1pbGlldShzLmV4dHJlbWl0ZTEsIHMuZXh0cmVtaXRlMilcbiAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gYWJzY2lzc2U9XCIke3RoaXMueChNKX1cIiBvcmRvbm5lZT1cIiR7dGhpcy55KE0pfVwiIGZvcm1lPVwiJHtvcHRpb25zLmNvZGFnZX1cIiAgY291bGV1cj1cIiR7b3B0aW9ucy5jb3VsZXVyfVwiIGlkPVwiJHtpZH1cIiB0ZW1wbz1cIiR7b3B0aW9ucy50ZW1wb31cIiBtb3V2ZW1lbnQ9XCJjcmVlclwiIG9iamV0PVwibG9uZ3VldXJcIiAvPmBcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGNvZGVYTUwpXG4gICAgcmV0dXJuIGlkXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW50fSBpZCBJZGVudGlmaWFudCBkdSBjb2RhZ2VcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gICAqL1xuICB0aGlzLnNlZ21lbnRDb2RhZ2VNYXNxdWVyID0gZnVuY3Rpb24gKGlkLCB7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGlkPVwiJHtpZH1cIiBtb3V2ZW1lbnQ9XCJtYXNxdWVyXCIgb2JqZXQ9XCJsb25ndWV1clwiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmApXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW50fSBpZCBJZGVudGlmaWFudCBkdSBjb2RhZ2VcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IDogeyB0ZW1wbzogdGhpcy50ZW1wbyB9XG4gICAqL1xuICB0aGlzLnNlZ21lbnRDb2RhZ2VNb250cmVyID0gZnVuY3Rpb24gKGlkLCB7IHRlbXBvID0gdGhpcy50ZW1wbyB9ID0ge30pIHtcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGlkPVwiJHtpZH1cIiBtb3V2ZW1lbnQ9XCJtb250cmVyXCIgb2JqZXQ9XCJsb25ndWV1clwiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmApXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIGxlIHBldGl0IGNhcnLDqSBhdSBjcmF5b25cbiAgICogQHBhcmFtIHtwb2ludH0gQSBQb2ludCBzdXIgdW4gY8O0dMOpIGRlIGwnYW5nbGVcbiAgICogQHBhcmFtIHtwb2ludH0gQiBTb21tZXQgZGUgbCdhbmdsZVxuICAgKiBAcGFyYW0ge3BvaW50fSBDIFBvaW50IHN1ciB1biBjw7R0w6kgZGUgbCdhbmdsZVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIETDqWZhdXQgOiB7bG9uZ3VldXIgOiAwLjMsIGNvdWxldXI6IHRoaXMuY291bGV1ckNvZGFnZX1cbiAgICogQHJldHVybiB7YXJyYXl9IFtpZFRyYWl0MSwgaWRUcmFpdDJdXG4gICAqL1xuICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQgPSBmdW5jdGlvbiAoQSwgQiwgQywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jcmF5b25Nb250cmVyKClcbiAgICBpZiAob3B0aW9ucy5sb25ndWV1ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxvbmd1ZXVyID0gMC4zXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdWxldXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5jb3VsZXVyID0gdGhpcy5jb3VsZXVyQ29kYWdlXG4gICAgfVxuICAgIGNvbnN0IEMxID0gcG9pbnRTdXJTZWdtZW50KEIsIEMsIG9wdGlvbnMubG9uZ3VldXIpXG4gICAgY29uc3QgQTEgPSBwb2ludFN1clNlZ21lbnQoQiwgQSwgb3B0aW9ucy5sb25ndWV1cilcbiAgICBjb25zdCBNID0gdHJhbnNsYXRpb24yUG9pbnRzKEExLCBCLCBDMSlcbiAgICBjb25zdCBvcHRpb25zMSA9IHsgLi4ub3B0aW9ucyB9IC8vIE9uIHJlY29waWUgb3B0aW9ucyBwb3VyIG91dm9pciBlbiBjaGFuZ2VyIGxlIHRlbXBvIGR1IHByZW1pZXIgdHJhY8OpXG4gICAgb3B0aW9uczEudGVtcG8gPSAwXG4gICAgY29uc3QgdHJhaXQxID0gdGhpcy50cmFpdChDMSwgTSwgb3B0aW9uczEpXG4gICAgY29uc3QgdHJhaXQyID0gdGhpcy50cmFpdChNLCBBMSwgb3B0aW9ucylcbiAgICByZXR1cm4gW3RyYWl0MSwgdHJhaXQyXVxuICB9XG4gIC8qKlxuICAgKiBNYXNxdWUgbGUgY29kYWdlIGQndW4gYW5nbGUgZHJvaXRcbiAgICogQHBhcmFtIHtpbnR9IGlkIElkZW50aWZpYW50IGR1IGNvZGFnZSBkJ3VuIGFuZ2xlIGRyb2l0XG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCB7IHRlbXBvOiAwIH1cbiAgICovXG4gIHRoaXMuY29kYWdlQW5nbGVEcm9pdE1hc3F1ZXIgPSBmdW5jdGlvbiAoaWQsIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIHRoaXMudHJhaXRNYXNxdWVyKGlkWzBdLCB7IHRlbXBvOiB0ZW1wbyB9KVxuICAgIHRoaXMudHJhaXRNYXNxdWVyKGlkWzFdLCB7IHRlbXBvOiB0ZW1wbyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENvZGUgdW4gYW5nbGUuIEwnb3B0aW9uIGNvZGFnZSBwZXV0IMOqdHJlIFwic2ltcGxlXCIsIFwiL1wiLCBcIi8vXCIsIFwiLy8vXCIsIFwiT1wiXG4gICAqIFwiZG91YmxlXCIsIFwiZG91YmxlL1wiLCBcImRvdWJsZS8vXCIsIFwiZG91YmxlLy8vXCIsIFwiZG91YmxlT1wiXG4gICAqIFwidHJpcGxlXCIsIFwidHJpcGxlL1wiLCBcInRyaXBsZS8vXCIsIFwidHJpcGxlLy8vXCIsIFwidHJpcGxlT1wiXG4gICAqIFwicGxlaW5cIiwgXCJwbGVpbi9cIiwgXCJwbGVpbi8vXCIsIFwicGxlaW4vLy9cIiwgXCJwbGVpbk9cIlxuICAgKiBAcGFyYW0ge3BvaW50fSBBIFBvaW50IHN1ciB1biBjw7R0w6kgZGUgbCdhbmdsZVxuICAgKiBAcGFyYW0ge3BvaW50fSBCIFNvbW1ldCBkZSBsJ2FuZ2xlXG4gICAqIEBwYXJhbSB7cG9pbnR9IEMgUG9pbnQgc3VyIHVuIGPDtHTDqSBkZSBsJ2FuZ2xlXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHsgcmF5b24gOiAxLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb2RhZ2UsIGNvZGFnZTogJ3BsZWluJ31cbiAgICogQHJldHVybiB7aWR9IEwnaWRlbnRpZmlhbnQgY29ycmVzcG9uZCDDoCBsJ2lkZW50aWZpYW50IGRlcyAzIHBvaW50cyBkZSBsJ2FuZ2xlIHPDqXBhcsOpcyBwYXIgX1xuICAgKi9cbiAgdGhpcy5hbmdsZUNvZGFnZSA9IGZ1bmN0aW9uIChCLCBBLCBDLCB7IGNvdWxldXIgPSB0aGlzLmNvdWxldXJDb2RhZ2UsIGNvZGFnZSA9ICdwbGVpbicsIHJheW9uID0gMSwgdGVtcG8gPSB0aGlzLnRlbXBvIH0gPSB7fSkge1xuICAgIGNvbnN0IGlkID0gQi5pZCArICdfJyArIEEuaWQgKyAnXycgKyBDLmlkXG4gICAgY29uc3QgZDEgPSBkcm9pdGUoQSwgQilcbiAgICBjb25zdCBkMiA9IGRyb2l0ZShBLCBDKVxuICAgIGQxLmlzVmlzaWJsZSA9IGZhbHNlXG4gICAgZDIuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBhbmdsZTEgPSAtZDEuYW5nbGVBdmVjSG9yaXpvbnRhbGVcbiAgICBjb25zdCBhbmdsZTIgPSAtZDIuYW5nbGVBdmVjSG9yaXpvbnRhbGVcbiAgICBjb25zdCBjb2RlWE1MID0gYDxhY3Rpb24gYWJzY2lzc2U9XCIke3RoaXMueChBKX1cIiBvcmRvbm5lZT1cIiR7dGhpcy55KEEpfVwiIHJheW9uPVwiJHtyYXlvbiAqIDMwfVwiIGFuZ2xlMT1cIiR7YW5nbGUxfVwiIGFuZ2xlMj1cIiR7YW5nbGUyfVwiIGZvcm1lPVwiJHtjb2RhZ2V9XCIgIGNvdWxldXI9XCIke2NvdWxldXJ9XCIgaWQ9XCIke2lkfVwiIHRlbXBvPVwiJHt0ZW1wb31cIiBtb3V2ZW1lbnQ9XCJjcmVlclwiIG9iamV0PVwiYW5nbGVcIiAvPmBcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGNvZGVYTUwpXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICAvKipcbiAgICogTWFzcXVlIHVuIGNvZGFnZSBwcsOpYWxhYmxlbWVudCBjcsOpw6lcbiAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgKiBAcGFyYW0ge3BvaW50fSBCXG4gICAqIEBwYXJhbSB7cG9pbnR9IENcbiAgICogQHBhcmFtIHtvYmpldH0gb3B0aW9ucyBEw6lmYXV0IHsgdGVtcG86IDAgfVxuICAgKi9cbiAgdGhpcy5hbmdsZUNvZGFnZU1hc3F1ZXIgPSBmdW5jdGlvbiAoQiwgQSwgQywgeyB0ZW1wbyA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3QgaWQgPSBCLmlkICsgJ18nICsgQS5pZCArICdfJyArIEMuaWRcbiAgICB0aGlzLmxpc3RlX3NjcmlwdC5wdXNoKGA8YWN0aW9uIGlkPVwiJHtpZH1cIiBtb3V2ZW1lbnQ9XCJtYXNxdWVyXCIgb2JqZXQ9XCJhbmdsZVwiIHRlbXBvPVwiJHt0ZW1wb31cIiAvPmApXG4gIH1cbiAgLyoqXG4gICAqIE1vbnRyZSB1biBjb2RhZ2UgcHLDqWFsYWJsZW1lbnQgY3LDqcOpXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtwb2ludH0gQlxuICAgKiBAcGFyYW0ge3BvaW50fSBDXG4gICAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCB7IHRlbXBvOiAwIH1cbiAgICovXG4gIHRoaXMuYW5nbGVDb2RhZ2VNb250cmVyID0gZnVuY3Rpb24gKEIsIEEsIEMsIHsgdGVtcG8gPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IGlkID0gQi5pZCArICdfJyArIEEuaWQgKyAnXycgKyBDLmlkXG4gICAgdGhpcy5saXN0ZV9zY3JpcHQucHVzaChgPGFjdGlvbiBpZD1cIiR7aWR9XCIgbW91dmVtZW50PVwibW9udHJlclwiIG9iamV0PVwiYW5nbGVcIiB0ZW1wbz1cIiR7dGVtcG99XCIgLz5gKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmZmljaGUgdW5lIGltYWdlIChkb25uw6llIHBhciBzb24gVVJMKSBhdSBwb2ludCBBXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHJldHVybnMge2lkfVxuICAgKi9cbiAgdGhpcy5pbWFnZSA9IGZ1bmN0aW9uICh1cmwsIEEgPSBwb2ludCgwLCAwKSkge1xuICAgIHRoaXMuaWRJRVArK1xuICAgIGxldCBjb2RlWE1MXG4gICAgY29kZVhNTCA9IGA8YWN0aW9uIGlkPVwiJHt0aGlzLmlkSUVQfVwiIHVybD1cIiR7dXJsfVwiIG1vdXZlbWVudD1cImNoYXJnZW1lbnRcIiBvYmpldD1cImltYWdlXCIgLz5gXG4gICAgY29kZVhNTCArPSBgXFxuPGFjdGlvbiBhYnNjaXNzZT1cIiR7dGhpcy54KEEpfVwiIG9yZG9ubmVlPVwiJHt0aGlzLnkoQSl9XCIgaWQ9XCIke3RoaXMuaWRJRVB9XCIgbW91dmVtZW50PVwidHJhbnNsYXRpb25cIiBvYmpldD1cImltYWdlXCIgdml0ZXNzZT1cIjEwMDAwMFwiIC8+YFxuICAgIHRoaXMubGlzdGVfc2NyaXB0LnB1c2goY29kZVhNTClcbiAgICByZXR1cm4gdGhpcy5pZElFUFxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqKioqKioqKiogTUFDUk9TLUNPTlNUUlVDVElPTlMgKioqKioqKioqKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvKipcbiAgICogVHJhY2UgbGEgcGFyYWxsw6hsZSDDoCAoQUIpIHBhc3NhbnQgcGFyIEMgYXZlYyBsYSByw6hnbGUgZXQgbCfDqXF1ZXJyZS4gUGV1dCBwcm9sb25nZXIgbGUgc2VnbWVudCBbQUJdIHNpIGxlIHBpZWQgZGUgbGEgaGF1dGV1ciBlc3QgdHJvcCDDqWxvaWduw6kgZGVzIGV4dHLDqW1pdMOpcyBkdSBzZWdtZW50XG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtwb2ludH0gQlxuICAgKiBAcGFyYW0ge3BvaW50fSBDXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5wYXJhbGxlbGVSZWdsZUVxdWVycmUycG9pbnRzM2Vwb2ludCA9IGZ1bmN0aW9uIChBLCBCLCBDLCBvcHRpb25zKSB7XG4gICAgbGV0IEcsIEQsIEgxXG4gICAgLy8gRyBlc3QgbGUgcG9pbnQgbGUgcGx1cyDDoCBnYXVjaGUsIEQgbGUgcGx1cyDDoCBkcm9pdGUgZXQgSCBsZSBwcm9qZXTDqSBkZSBDIHN1ciAoQUIpXG4gICAgLy8gSDEgZXN0IHVuIHBvaW50IGRlIChBQikgw6AgZ2F1Y2hlIGRlIEgsIGMnZXN0IGzDoCBvw7kgc2Vyb250IGxhIHLDqGdsZSBldCBsJ8OpcXVlcnJlIGF2YW50IGRlIGdsaXNzZXJcbiAgICBpZiAoQS54IDwgQi54KSB7XG4gICAgICBHID0gQVxuICAgICAgRCA9IEJcbiAgICB9IGVsc2Uge1xuICAgICAgRyA9IEJcbiAgICAgIEQgPSBBXG4gICAgfVxuICAgIGNvbnN0IGQgPSBkcm9pdGUoQSwgQilcbiAgICBjb25zdCBIID0gcHJvamVjdGlvbk9ydGhvKEMsIGQpXG4gICAgaWYgKEgueCA8IEQueCkge1xuICAgICAgSDEgPSBwb2ludFN1clNlZ21lbnQoSCwgRCwgLTIpIC8vIEgxIHNlcmEgcGx1cyDDoCBnYXVjaGUgcXVlIEhcbiAgICB9IGVsc2UgaWYgKEgueCA+IEQueCkge1xuICAgICAgSDEgPSBwb2ludFN1clNlZ21lbnQoSCwgRCwgMilcbiAgICB9IGVsc2Uge1xuICAgICAgSDEgPSBwb2ludFN1clNlZ21lbnQoSCwgRywgMilcbiAgICB9XG4gICAgY29uc3QgQzEgPSBwcm9qZWN0aW9uT3J0aG8oSDEsIGRyb2l0ZVBhclBvaW50RXRQYXJhbGxlbGUoQywgZCkpXG4gICAgLy8gQzEgZXN0IGxlIHBvaW50IGQnYXJyaXbDqWUgZGUgbCfDqXF1ZXJyZSBhcHLDqHMgYXZvaXIgZ2xpc3PDqVxuICAgIGNvbnN0IE0gPSBwb2ludFN1clNlZ21lbnQoQzEsIEMsIDYpXG4gICAgLy8gTGUgdHJhY8OpIGRlIGxhIHBhcmFsbMOobGUgbmUgZmVyYSBxdWUgNiBjbSBwb3VyIG5lIHBhcyBkw6lwYXNzciBkZSBsJ8OpcXVlcnJlLiBNIGVzdCBsYSBmaW4gZGUgY2UgdHJhY8OpXG5cbiAgICBpZiAoSC54IDwgRy54ICYmIGxvbmd1ZXVyKEgsIEcpID4gMykgeyAvLyBTaSBsZSBwaWVkIGRlIGxhIGhhdXRldXIgZXN0IHRyb3Agw6AgZ2F1Y2hlXG4gICAgICB0aGlzLnJlZ2xlUHJvbG9uZ2VyU2VnbWVudChELCBHKVxuICAgICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIH1cbiAgICBpZiAoSC54ID4gRC54ICYmIGxvbmd1ZXVyKEgsIEQpID4gMykgeyAvLyBTaSBsZSBwaWVkIGRlIGxhIGhhdXRldXIgZXN0IHRyb3Agw6AgZ2F1Y2hlXG4gICAgICB0aGlzLnJlZ2xlUHJvbG9uZ2VyU2VnbWVudChHLCBEKVxuICAgIH1cblxuICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoSDEpXG4gICAgaWYgKE0ueCA+IEMxLngpIHtcbiAgICAgIHRoaXMuZXF1ZXJyZVJvdGF0aW9uKGQuYW5nbGVBdmVjSG9yaXpvbnRhbGUgLSA5MClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcXVlcnJlUm90YXRpb24oZC5hbmdsZUF2ZWNIb3Jpem9udGFsZSArIDkwKVxuICAgIH1cbiAgICBpZiAoSDEueSA+IEMxLnkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2xlLnZpc2liaWxpdGUpIHtcbiAgICAgICAgdGhpcy5yZWdsZURlcGxhY2VyKEgxLCB7IHZpdGVzc2U6IHRoaXMudml0ZXNzZSwgdGVtcG86IDAgfSlcbiAgICAgICAgdGhpcy5yZWdsZVJvdGF0aW9uKEMxLCB7IHNlbnM6IHRoaXMudml0ZXNzZSAvIDIsIHRlbXBvOiAwIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZ2xlRGVwbGFjZXIoSDEsIHsgdml0ZXNzZTogMTAwMCwgdGVtcG86IDAgfSlcbiAgICAgICAgdGhpcy5yZWdsZVJvdGF0aW9uKEMxLCB7IHNlbnM6IDEwMDAsIHRlbXBvOiAwIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IEMxMiA9IHBvaW50U3VyU2VnbWVudChDMSwgSDEsIC0yKSAvLyBPbiBtb250ZSB1biBwZXUgcGx1cyBsYSByw6hnbGUgcG91ciBxdWUgw6dhIHNvaXQgcGx1cyBjcsOpZGlibGVcbiAgICAgIGlmICh0aGlzLnJlZ2xlLnZpc2liaWxpdGUpIHtcbiAgICAgICAgdGhpcy5yZWdsZURlcGxhY2VyKEMxMiwgeyB2aXRlc3NlOiB0aGlzLnZpdGVzc2UsIHRlbXBvOiAwIH0pXG4gICAgICAgIHRoaXMucmVnbGVSb3RhdGlvbihIMSwgeyBzZW5zOiB0aGlzLnZpdGVzc2UgLyAyLCB0ZW1wbzogMCB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWdsZURlcGxhY2VyKEMxMiwgeyB2aXRlc3NlOiAxMDAwLCB0ZW1wbzogMCB9KVxuICAgICAgICB0aGlzLnJlZ2xlUm90YXRpb24oSDEsIHsgc2VuczogMTAwMCwgdGVtcG86IDAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWdsZU1vbnRyZXIoKVxuICAgIHRoaXMuZXF1ZXJyZURlcGxhY2VyKEMxLCBvcHRpb25zKVxuICAgIHRoaXMuY3JheW9uTW9udHJlcigpXG4gICAgdGhpcy5jcmF5b25EZXBsYWNlcihDMSwgb3B0aW9ucylcbiAgICB0aGlzLnRyYWNlcihNLCBvcHRpb25zKVxuICB9XG4gIC8qKlxuICAgICAqIFRyYWNlIGxhIHBlcnBlbmRpY3VsYWlyZSDDoCAoQUIpIHBhc3NhbnQgcGFyIEMgYXZlYyBsYSByw6hnbGUgZXQgbCfDqXF1ZXJyZS4gUGV1dCBwcm9sb25nZXIgbGUgc2VnbWVudCBbQUJdIHNpIGxlIHBpZWQgZGUgbGEgaGF1dGV1ciBlc3QgdHJvcCDDqWxvaWduw6kgZGVzIGV4dHLDqW1pdMOpcyBkdSBzZWdtZW50XG4gICAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgICAqIEBwYXJhbSB7cG9pbnR9IEJcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBDXG4gICAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAgICovXG4gIHRoaXMucGVycGVuZGljdWxhaXJlUmVnbGVFcXVlcnJlMnBvaW50czNlcG9pbnQgPSBmdW5jdGlvbiAoQSwgQiwgQywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvbmd1ZXVyUmVnbGUgPSB0aGlzLnJlZ2xlLmxvbmd1ZXVyXG4gICAgY29uc3Qgem9vbUVxdWVycmUgPSB0aGlzLmVxdWVycmUuem9vbVxuICAgIGNvbnN0IGQgPSBkcm9pdGUoQSwgQilcbiAgICBsZXQgZGlzdFxuICAgIGlmIChhcHBhcnRpZW50RHJvaXRlKEMsIEEsIEIpKSB7XG4gICAgICBkaXN0ID0gNy41XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IEggPSBwcm9qZWN0aW9uT3J0aG8oQywgZClcbiAgICAgIGRpc3QgPSBsb25ndWV1cihILCBDKSArIDJcbiAgICB9XG4gICAgdGhpcy5lcXVlcnJlWm9vbShjYWxjdWwoZGlzdCAqIDEwMCAvIDcuNSkpXG4gICAgdGhpcy5yZWdsZU1vZGlmaWVyTG9uZ3VldXIoTWF0aC5tYXgoZGlzdCAqIDIsIDE1KSlcblxuICAgIHRoaXMucGVycGVuZGljdWxhaXJlUmVnbGVFcXVlcnJlRHJvaXRlUG9pbnQoZCwgQylcbiAgICB0aGlzLmVxdWVycmVab29tKHpvb21FcXVlcnJlKVxuICAgIHRoaXMucmVnbGVNb2RpZmllckxvbmd1ZXVyKGxvbmd1ZXVyUmVnbGUpXG4gIH1cblxuICB0aGlzLnBlcnBlbmRpY3VsYWlyZVJlZ2xlRXF1ZXJyZURyb2l0ZVBvaW50ID0gZnVuY3Rpb24gKGQsIFApIHtcbiAgICBjb25zdCBIID0gcHJvamVjdGlvbk9ydGhvKFAsIGQpXG4gICAgY29uc3QgQSA9IHJvdGF0aW9uKFAsIEgsIDkwKVxuICAgIGNvbnN0IEIgPSByb3RhdGlvbihBLCBILCAxODApXG4gICAgY29uc3QgYWxwaGEgPSBhbmdsZU9yaWVudGUocG9pbnQoMTAwMDAsIEgueSksIEgsIEIpXG4gICAgdGhpcy5lcXVlcnJlUm90YXRpb24oYWxwaGEpXG4gICAgdGhpcy5lcXVlcnJlTW9udHJlcihIKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEgsIFApXG4gICAgdGhpcy5lcXVlcnJlTWFzcXVlcigpXG4gICAgdGhpcy5jb2RhZ2VBbmdsZURyb2l0KEEsIEgsIFApXG4gICAgdGhpcy5yZWdsZVByb2xvbmdlclNlZ21lbnQoUCwgSCwgeyBsb25ndWV1cjogbG9uZ3VldXIoUCwgSCkgKiAyIH0pXG4gIH1cblxuICAvKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICoqKioqKioqKiBEUk9JVEVTIFJFTUFSUVVBQkxFUyAqKioqKioqKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4gIC8qKlxuICogVHJhY2UgbGEgbcOpZGlhdHJpY2UgZGUgW0FCXSBhdSBjb21wYXMuIExlIHBhcmFtw6l0cmFnZSBkZXMgbG9uZ3VldXJzIGNvcnJlc3BvbmQgw6AgbGEgZGlzdGFuY2UgZW50cmUgbGUgbWlsaWV1IGR1IHNlZ21lbnQgZXQgbGUgcG9pbnQgZCdpbnRlcnNlY3Rpb24gZGVzIGFyY3MgZGUgY2VyY2xlc1xuICpcbiAqIEBwYXJhbSB7cG9pbnR9IEFcbiAqIEBwYXJhbSB7cG9pbnR9IEJcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnMgRMOpZmF1dCA6IHtsb25ndWV1cjE6IDMsIGxvbmd1ZXVyMjogMywgY29kYWdlOiAnWCcsIGNvdWxldXJDb2RhZ2UgOiB0aGlzLmNvdWxldXJDb2RhZ2UsIGNvdWxldXJDb21wYXM6IHRoaXMuY291bGV1ckNvbXBhc31cbiAqIEByZXR1cm4ge2FycmF5fSBbYXJjMSwgYXJjMiwgYXJjMywgYXJjNCwgY29kYWdlMSwgY29kYWdlMiwgY29kYWdlQ2FycmVdXG4gICovXG4gIHRoaXMubWVkaWF0cmljZUF1Q29tcGFzID0gZnVuY3Rpb24gKEEsIEIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zLmxvbmd1ZXVyMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxvbmd1ZXVyMSA9IDNcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9uZ3VldXIyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubG9uZ3VldXIyID0gLTNcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY29kYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY29kYWdlID0gJ1gnXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdWxldXJDb2RhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5jb3VsZXVyQ29kYWdlID0gdGhpcy5jb3VsZXVyQ29kYWdlXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdWxldXJDb21wYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5jb3VsZXVyQ29tcGFzID0gdGhpcy5jb3VsZXVyQ29tcGFzXG4gICAgfVxuICAgIGNvbnN0IE8gPSBtaWxpZXUoQSwgQilcbiAgICBjb25zdCBPMiA9IHJvdGF0aW9uKEEsIE8sIC05MClcbiAgICBjb25zdCBNID0gcG9pbnRTdXJTZWdtZW50KE8sIE8yLCBvcHRpb25zLmxvbmd1ZXVyMSlcbiAgICBjb25zdCBOID0gcG9pbnRTdXJTZWdtZW50KE8sIE8yLCBvcHRpb25zLmxvbmd1ZXVyMilcbiAgICB0aGlzLmNvbXBhc01vbnRyZXIoKVxuICAgIHRoaXMuY29tcGFzRGVwbGFjZXIoQSwgb3B0aW9ucylcbiAgICBsZXQgYXJjMSwgYXJjMiwgYXJjMywgYXJjNFxuICAgIGlmIChvcHRpb25zLmxvbmd1ZXVyMSA9PT0gLTEgKiBvcHRpb25zLmxvbmd1ZXVyMikgeyAvLyBTaSBsYSBkaXN0YW5jZSBlc3QgbGEgbcOqbWUgZGVzIGRldXggY8O0dMOpcywgb24gcGV1dCBmYWlyZSBsZXMgYXJjcyBkZSBwYXJ0IGV0IGQnYXV0cmVcbiAgICAgIHRoaXMuY29tcGFzRWNhcnRlcihsb25ndWV1cihBLCBNKSwgeyB2aXRlc3NlOiBvcHRpb25zLnZpdGVzc2UsIHNlbnM6IG9wdGlvbnMudml0ZXNzZSB9KVxuICAgICAgYXJjMSA9IHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQSwgTSwgeyBkZWx0YTogb3B0aW9ucy5kZWx0YSwgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29tcGFzLCBzZW5zOiBvcHRpb25zLnNlbnMsIHZpdGVzc2U6IG9wdGlvbnMudml0ZXNzZSwgdGVtcG86IG9wdGlvbnMudGVtcG8gfSlcbiAgICAgIGFyYzIgPSB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEEsIE4sIHsgZGVsdGE6IG9wdGlvbnMuZGVsdGEsIGNvdWxldXI6IG9wdGlvbnMuY291bGV1ckNvbXBhcywgc2Vuczogb3B0aW9ucy5zZW5zLCB2aXRlc3NlOiBvcHRpb25zLnZpdGVzc2UsIHRlbXBvOiBvcHRpb25zLnRlbXBvIH0pXG4gICAgICBhcmMzID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChCLCBNLCB7IGRlbHRhOiBvcHRpb25zLmRlbHRhLCBjb3VsZXVyOiBvcHRpb25zLmNvdWxldXJDb21wYXMsIHNlbnM6IG9wdGlvbnMuc2Vucywgdml0ZXNzZTogb3B0aW9ucy52aXRlc3NlLCB0ZW1wbzogb3B0aW9ucy50ZW1wbyB9KVxuICAgICAgYXJjNCA9IHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQiwgTiwgeyBkZWx0YTogb3B0aW9ucy5kZWx0YSwgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29tcGFzLCBzZW5zOiBvcHRpb25zLnNlbnMsIHZpdGVzc2U6IG9wdGlvbnMudml0ZXNzZSwgdGVtcG86IG9wdGlvbnMudGVtcG8gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21wYXNFY2FydGVyKGxvbmd1ZXVyKEEsIE0pLCBvcHRpb25zKVxuICAgICAgYXJjMSA9IHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQSwgTSwgeyBkZWx0YTogb3B0aW9ucy5kZWx0YSwgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29tcGFzLCBzZW5zOiBvcHRpb25zLnNlbnMsIHZpdGVzc2U6IG9wdGlvbnMudml0ZXNzZSwgdGVtcG86IG9wdGlvbnMudGVtcG8gfSlcbiAgICAgIGFyYzIgPSB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEIsIE0sIHsgZGVsdGE6IG9wdGlvbnMuZGVsdGEsIGNvdWxldXI6IG9wdGlvbnMuY291bGV1ckNvbXBhcywgc2Vuczogb3B0aW9ucy5zZW5zLCB2aXRlc3NlOiBvcHRpb25zLnZpdGVzc2UsIHRlbXBvOiBvcHRpb25zLnRlbXBvIH0pXG4gICAgICBhcmMzID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChCLCBOLCB7IGRlbHRhOiBvcHRpb25zLmRlbHRhLCBjb3VsZXVyOiBvcHRpb25zLmNvdWxldXJDb21wYXMsIHNlbnM6IG9wdGlvbnMuc2Vucywgdml0ZXNzZTogb3B0aW9ucy52aXRlc3NlLCB0ZW1wbzogb3B0aW9ucy50ZW1wbyB9KVxuICAgICAgYXJjNCA9IHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQSwgTiwgeyBkZWx0YTogb3B0aW9ucy5kZWx0YSwgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29tcGFzLCBzZW5zOiBvcHRpb25zLnNlbnMsIHZpdGVzc2U6IG9wdGlvbnMudml0ZXNzZSwgdGVtcG86IG9wdGlvbnMudGVtcG8gfSlcbiAgICB9XG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICBpZiAoTS54IDw9IE4ueCkge1xuICAgICAgdGhpcy5yZWdsZURyb2l0ZShNLCBOLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZ2xlRHJvaXRlKE4sIE0sIG9wdGlvbnMpXG4gICAgfVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICBjb25zdCBjb2RhZ2UxID0gdGhpcy5zZWdtZW50Q29kYWdlKEEsIE8sIHsgY29kYWdlOiBvcHRpb25zLmNvZGFnZSwgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29kYWdlLCB0ZW1wbzogb3B0aW9ucy50ZW1wbyB9KVxuICAgIGNvbnN0IGNvZGFnZTIgPSB0aGlzLnNlZ21lbnRDb2RhZ2UoTywgQiwgeyBjb2RhZ2U6IG9wdGlvbnMuY29kYWdlLCBjb3VsZXVyOiBvcHRpb25zLmNvdWxldXJDb2RhZ2UsIHRlbXBvOiBvcHRpb25zLnRlbXBvIH0pXG4gICAgY29uc3QgY29kYWdlQ2FycmUgPSB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQoQSwgTywgTzIsIHsgY291bGV1cjogb3B0aW9ucy5jb3VsZXVyQ29kYWdlLCB0ZW1wbzogb3B0aW9ucy50ZW1wbywgdml0ZXNzZTogb3B0aW9ucy52aXRlc3NlIH0pXG4gICAgcmV0dXJuIFthcmMxLCBhcmMyLCBhcmMzLCBhcmM0LCBjb2RhZ2UxLCBjb2RhZ2UyLCBjb2RhZ2VDYXJyZV1cbiAgfVxuICAvKipcbiAgICogVHJhY2UgbGEgbcOpZGlhdHJpY2UgZHUgc2VnbWVudCBbQUJdIGF2ZWMgbGEgbcOpdGhvZGUgUsOoZ2xlICsgw6lxdWVycmUuXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtwb2ludH0gQlxuICAgKiBAcGFyYW0ge2Jvb2zDqWVufSBjb2RhZ2VcbiAgICovXG4gIHRoaXMubWVkaWF0cmljZVJlZ2xlRXF1ZXJyZSA9IGZ1bmN0aW9uIChBLCBCLCBjb2RhZ2UgPSAnWCcpIHtcbiAgICBjb25zdCBPID0gbWlsaWV1KEEsIEIpXG4gICAgdGhpcy5yZWdsZU1vbnRyZXIoKVxuICAgIHRoaXMucmVnbGVEZXBsYWNlcihBKVxuICAgIHRoaXMucmVnbGVSb3RhdGlvbihCKVxuICAgIHRoaXMuY3JheW9uTW9udHJlcigpXG4gICAgY29uc3QgTzIgPSByb3RhdGlvbihBLCBPLCAtOTApXG4gICAgY29uc3QgTzMgPSByb3RhdGlvbihBLCBPLCA5MClcbiAgICBjb25zdCBNID0gcG9pbnRTdXJTZWdtZW50KE8sIE8yLCAwLjIpXG4gICAgY29uc3QgTiA9IHBvaW50U3VyU2VnbWVudChPLCBPMywgMC4yKVxuICAgIGlmICh0aGlzLnkoTSkgPiB0aGlzLnkoTikpIHtcbiAgICAgIHRoaXMudHJhaXQoTywgTSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFpdChPLCBOKVxuICAgIH1cbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgaWYgKHRoaXMueChBKSA8IHRoaXMueChCKSkge1xuICAgICAgdGhpcy5lcXVlcnJlRGVwbGFjZXIoQSlcbiAgICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoKVxuICAgICAgdGhpcy5lcXVlcnJlUm90YXRpb24oQilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcXVlcnJlRGVwbGFjZXIoQilcbiAgICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoKVxuICAgICAgdGhpcy5lcXVlcnJlUm90YXRpb24oQSlcbiAgICB9XG4gICAgdGhpcy5lcXVlcnJlRGVwbGFjZXIoTylcbiAgICB0aGlzLmNyYXlvbkRlcGxhY2VyKE8pXG4gICAgdGhpcy50cmFpdChPLCBPMilcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlRHJvaXRlKE8yLCBPMylcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIE8sIGNvZGFnZSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoTywgQiwgY29kYWdlKVxuICAgIHRoaXMuY29kYWdlQW5nbGVEcm9pdChBLCBPLCBPMilcbiAgfVxuICAvKipcbiAgICogVHJhY2UgbGEgaGF1dGV1ciBpc3N1ZSBkZSBDIGRhbnMgdW4gdHJpYW5nbGUgQUJDLiBQcm9sb25nZSBzaSBiZXNvaW4gbGUgc2VnbWVudCBbQUJdIHBvdXIgYXZvaXIgbGUgcGllZCBkZSBsYSBoYXV0ZXVyIGV0IGxlIGNvZGFnZSBkZSBsJ2FuZ2xlIGRyb2l0LlxuICAgKiBAcGFyYW0ge3BvaW50fSBBIDFlciBwb2ludCBkZSBsYSBiYXNlXG4gICAqIEBwYXJhbSB7cG9pbnR9IEIgMmUgcG9pbnQgZGUgbGEgYmFzZVxuICAgKiBAcGFyYW0ge3BvaW50fSBDIFNvbW1ldCBkb250IGVzdCBpc3N1ZSBsYSBoYXV0ZXVyXG4gICAqIEBwYXJhbSB7Ym9vbMOpZW59IGNvZGFnZSBhbmdsZSBkcm9pdCBham91dMOpIHNpIHRydWVcbiAgICovXG4gIHRoaXMuaGF1dGV1ciA9IGZ1bmN0aW9uIChBLCBCLCBDLCBjb2RhZ2UgPSB0cnVlKSB7XG4gICAgY29uc3QgZCA9IGRyb2l0ZShBLCBCKVxuICAgIGQuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBIID0gcHJvamVjdGlvbk9ydGhvKEMsIGQpXG4gICAgbGV0IEcsIERcbiAgICBpZiAodGhpcy54KEEpIDwgdGhpcy54KEIpKSB7XG4gICAgICBHID0gQVxuICAgICAgRCA9IEJcbiAgICB9IGVsc2Uge1xuICAgICAgRyA9IEJcbiAgICAgIEQgPSBBXG4gICAgfVxuICAgIGlmICh0aGlzLngoSCkgPCB0aGlzLngoRykpIHsgLy8gc2kgbGUgcGllZCBkZSBsYSBoYXV0ZXVyIGVzdCB0cm9wIMOgIGdhdWNoZVxuICAgICAgdGhpcy5yZWdsZVByb2xvbmdlclNlZ21lbnQoRCwgRywgbG9uZ3VldXIoRywgSCkgKyAyLCB0aGlzLmNvdWxldXIsIHRoaXMudGVtcG8sIHRoaXMudml0ZXNzZSwgdGhpcy5lcGFpc3NldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiwgdHJ1ZSlcbiAgICB9XG4gICAgaWYgKHRoaXMueChIKSA+IHRoaXMueChEKSkgeyAvLyBzaSBsZSBwaWVkIGRlIGxhIGhhdXRldXIgZXN0IHRyb3Agw6AgZHJvaXRlXG4gICAgICB0aGlzLnJlZ2xlUHJvbG9uZ2VyU2VnbWVudChHLCBELCBsb25ndWV1cihELCBIKSArIDIsIHRoaXMuY291bGV1ciwgdGhpcy50ZW1wbywgdGhpcy52aXRlc3NlLCB0aGlzLmVwYWlzc2V1clRyYWl0c0RlQ29uc3RydWN0aW9uLCB0cnVlKVxuICAgIH1cbiAgICBpZiAodGhpcy54KEgpIDwgdGhpcy54KEcpIHx8IHRoaXMueChIKSA+IHRoaXMueChEKSkge1xuICAgICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIH1cbiAgICBpZiAodGhpcy54KEEpIDwgdGhpcy54KEIpKSB7XG4gICAgICB0aGlzLmVxdWVycmVEZXBsYWNlcihBKVxuICAgICAgdGhpcy5lcXVlcnJlTW9udHJlcigpXG4gICAgICB0aGlzLmVxdWVycmVSb3RhdGlvbihCKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVxdWVycmVEZXBsYWNlcihCKVxuICAgICAgdGhpcy5lcXVlcnJlTW9udHJlcigpXG4gICAgICB0aGlzLmVxdWVycmVSb3RhdGlvbihBKVxuICAgIH1cbiAgICB0aGlzLmVxdWVycmVEZXBsYWNlcihIKVxuICAgIHRoaXMuY3JheW9uTW9udHJlcigpXG4gICAgdGhpcy5jcmF5b25EZXBsYWNlcihIKVxuICAgIHRoaXMudHJhaXQoSCwgQylcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICBpZiAoY29kYWdlKSB7XG4gICAgICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQoQSwgSCwgQylcbiAgICB9XG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgfVxuICAvKipcbiAqIFRyYWNlIGxhIG3DqWRpYW5lIGlzc3VlIGRlIEMgcGFzc2FudCBwYXIgbGUgbWlsaWV1IGRlIFtBQl1cbiAqIEBwYXJhbSB7cG9pbnR9IEFcbiAqIEBwYXJhbSB7cG9pbnR9IEJcbiAqIEBwYXJhbSB7cG9pbnR9IENcbiAqIEBwYXJhbSB7b2JqZXR9IG9wdGlvbnNcbiAqL1xuICB0aGlzLm1lZGlhbmUgPSBmdW5jdGlvbiAoQSwgQiwgQywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuY29kYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY29kYWdlID0gJ1gnXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiA9IHRoaXMuY291bGV1clRyYWl0c0RlQ29uc3RydWN0aW9uXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVwYWlzc2V1clRyYWl0c0RlQ29uc3RydWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuZXBhaXNzZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24gPSB0aGlzLmVwYWlzc2V1clRyYWl0c0RlQ29uc3RydWN0aW9uXG4gICAgfVxuICAgIGNvbnN0IE8gPSBtaWxpZXUoQSwgQilcbiAgICB0aGlzLnJlZ2xlTW9udHJlcihBLCBvcHRpb25zKVxuICAgIHRoaXMucmVnbGVSb3RhdGlvbihCLCBvcHRpb25zKVxuICAgIHRoaXMuY3JheW9uTW9udHJlcigpXG4gICAgY29uc3QgTzIgPSByb3RhdGlvbihBLCBPLCAtOTApXG4gICAgY29uc3QgTzMgPSByb3RhdGlvbihBLCBPLCA5MClcbiAgICBjb25zdCBNID0gcG9pbnRTdXJTZWdtZW50KE8sIE8yLCAwLjIpXG4gICAgY29uc3QgTiA9IHBvaW50U3VyU2VnbWVudChPLCBPMywgMC4yKVxuICAgIGlmIChNLnkgPiBOLnkpIHtcbiAgICAgIHRoaXMudHJhaXQoTywgTSwgeyB2aXRlc3NlOiBvcHRpb25zLnZpdGVzc2UsIHRlbXBvOiBvcHRpb25zLnRlbXBvLCBjb3VsZXVyOiBvcHRpb25zLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiwgZXBhaXNzZXVyOiBvcHRpb25zLmVwYWlzc2V1clRyYWl0c0RlQ29uc3RydWN0aW9uIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhaXQoTywgTiwgeyB2aXRlc3NlOiBvcHRpb25zLnZpdGVzc2UsIHRlbXBvOiBvcHRpb25zLnRlbXBvLCBjb3VsZXVyOiBvcHRpb25zLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiwgZXBhaXNzZXVyOiBvcHRpb25zLmVwYWlzc2V1clRyYWl0c0RlQ29uc3RydWN0aW9uIH0pXG4gICAgfVxuICAgIHRoaXMucmVnbGVTZWdtZW50KE8sIEMsIG9wdGlvbnMpXG4gICAgaWYgKG9wdGlvbnMuY29kYWdlKSB7XG4gICAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoQSwgTywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2VnbWVudENvZGFnZShPLCBCLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICAvKipcbiAqIFRyYWNlIGxhIGJpc3NlY3RyaWNlIGRlIGwnYW5nbGUgQUJDIGF1IGNvbXBhcy5cbiAqIEBwYXJhbSB7cG9pbnR9IEFcbiAqIEBwYXJhbSB7cG9pbnR9IEJcbiAqIEBwYXJhbSB7cG9pbnR9IENcbiAqIEBwYXJhbSB7b2JqZXR9IHBhcmFtM1xuICogQHJldHVybnMge29iamV0fSB7YXJjMSwgYXJjMiwgYXJjMywgYXJjNH1cbiAqL1xuICB0aGlzLmJpc3NlY3RyaWNlQXVDb21wYXMgPSBmdW5jdGlvbiAoQSwgQiwgQywgeyBjb2RhZ2UgPSAnLycsIGwgPSAyLCBjb3VsZXVyID0gdGhpcy5jb3VsZXVyLCB0ZW1wbyA9IHRoaXMudGVtcG8sIHZpdGVzc2UgPSB0aGlzLnZpdGVzc2UsIHNlbnMgPSBjYWxjdWwodGhpcy52aXRlc3NlIC8gMiwgMCksIGVwYWlzc2V1ciA9IHRoaXMuZXBhaXNzZXVyLCBwb2ludGlsbGVzID0gdGhpcy5wb2ludGlsbGVzLCBjb3VsZXVyQ29kYWdlID0gdGhpcy5jb3VsZXVyQ29kYWdlLCBtYXNxdWVyVHJhaXRzRGVDb25zdHJ1Y3Rpb25zID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCBBMSA9IHBvaW50U3VyU2VnbWVudChCLCBBLCBsKVxuICAgIGNvbnN0IEMxID0gcG9pbnRTdXJTZWdtZW50KEIsIEMsIGwpXG4gICAgLy8gY29uc3QgZGVtaWFuZ2xlID0gY2FsY3VsKGFuZ2xlT3JpZW50ZShBLCBCLCBDKSAvIDIpO1xuICAgIGNvbnN0IGFuZ2xlID0gYW5nbGVPcmllbnRlKEEsIEIsIEMpXG4gICAgY29uc3QgTSA9IHJvdGF0aW9uKEIsIEExLCAtKDE4MCAtIGFuZ2xlKSlcbiAgICBjb25zdCBvcHRpb25zID0geyBjb3VsZXVyOiBjb3VsZXVyLCB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UsIHNlbnM6IHNlbnMsIHBvaW50aWxsZXM6IGZhbHNlIH1cbiAgICBjb25zdCBhcmMxID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChCLCBBMSwgb3B0aW9ucylcbiAgICBjb25zdCBhcmMyID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChCLCBDMSwgb3B0aW9ucylcbiAgICBjb25zdCBhcmMzID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChBMSwgTSwgb3B0aW9ucylcbiAgICBjb25zdCBhcmM0ID0gdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChDMSwgTSwgb3B0aW9ucylcbiAgICB0aGlzLmNvbXBhc01hc3F1ZXIoKVxuICAgIHRoaXMucmVnbGVEZW1pRHJvaXRlT3JpZ2luZVBvaW50KEIsIE0sIHsgbG9uZ3VldXI6IGxvbmd1ZXVyKEIsIEEpLCBjb3VsZXVyOiBjb3VsZXVyLCB0ZW1wbzogdGVtcG8sIHZpdGVzc2U6IHZpdGVzc2UsIHNlbnM6IHNlbnMsIGVwYWlzc2V1cjogZXBhaXNzZXVyLCBwb2ludGlsbGVzOiBwb2ludGlsbGVzIH0pXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgaWYgKGNvZGFnZSkge1xuICAgICAgdGhpcy5hbmdsZUNvZGFnZShBLCBCLCBNLCB7IGNvdWxldXI6IGNvdWxldXJDb2RhZ2UsIGNvZGFnZTogY29kYWdlLCB0ZW1wbzogdGVtcG8gfSlcbiAgICAgIHRoaXMuYW5nbGVDb2RhZ2UoTSwgQiwgQywgeyBjb3VsZXVyOiBjb3VsZXVyQ29kYWdlLCBjb2RhZ2U6IGNvZGFnZSwgdGVtcG86IHRlbXBvIH0pXG4gICAgfVxuICAgIGlmIChtYXNxdWVyVHJhaXRzRGVDb25zdHJ1Y3Rpb25zKSB7XG4gICAgICB0aGlzLnRyYWl0TWFzcXVlcihhcmMxKVxuICAgICAgdGhpcy50cmFpdE1hc3F1ZXIoYXJjMilcbiAgICAgIHRoaXMudHJhaXRNYXNxdWVyKGFyYzMpXG4gICAgICB0aGlzLnRyYWl0TWFzcXVlcihhcmM0KVxuICAgIH1cbiAgICByZXR1cm4geyBhcmMxOiBhcmMxLCBhcmMyOiBhcmMyLCBhcmMzOiBhcmMzLCBhcmM0OiBhcmM0IH1cbiAgfVxuICAvKipcbiAqIENvbnN0cnVpdCBsZXMgMyBtw6lkaWF0cmljZXMgZGVzIGPDtHTDqXMgZHUgdHJpYW5nbGUgQUJDIHB1aXMgbGUgY2VyY2xlIGNpcmNvbnNjcml0IGF1IHRyaWFuZ2xlXG4gKiBAcGFyYW0ge3BvaW50fSBBXG4gKiBAcGFyYW0ge3BvaW50fSBCXG4gKiBAcGFyYW0ge3BvaW50fSBDXG4gKiBAcGFyYW0ge29iamV0fSBvcHRpb25zXG4gKi9cbiAgdGhpcy5jZXJjbGVDaXJjb25zY3JpdCA9IGZ1bmN0aW9uIChBLCBCLCBDLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5jb3VsZXVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY291bGV1ciA9IHRoaXMuY291bGV1clxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb3VsZXVyTWVkaWF0cmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmNvdWxldXJNZWRpYXRyaWNlID0gb3B0aW9ucy5jb3VsZXVyXG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdWxldXJDZXJjbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5jb3VsZXVyQ2VyY2xlID0gb3B0aW9ucy5jb3VsZXVyXG4gICAgfVxuICAgIG9wdGlvbnMuY29kYWdlID0gJ1gnXG4gICAgb3B0aW9ucy5jb3VsZXVyID0gb3B0aW9ucy5jb3VsZXVyTWVkaWF0cmljZVxuICAgIGNvbnN0IG0xID0gdGhpcy5tZWRpYXRyaWNlQXVDb21wYXMoQSwgQiwgb3B0aW9ucylcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtMVswXSkgLy8gT24gY2FjaGUgbGVzIGFyY3MgZGUgY2VyY2xlIHVuZSBmb2lzIGxhIG3DqWRpYXRyaWNlIHRyYWPDqWVcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtMVsxXSlcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtMVsyXSlcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtMVszXSlcbiAgICBvcHRpb25zLmNvZGFnZSA9ICd8fCdcbiAgICBjb25zdCBtMiA9IHRoaXMubWVkaWF0cmljZUF1Q29tcGFzKEIsIEMsIG9wdGlvbnMpXG4gICAgdGhpcy50cmFpdE1hc3F1ZXIobTJbMF0pXG4gICAgdGhpcy50cmFpdE1hc3F1ZXIobTJbMV0pXG4gICAgdGhpcy50cmFpdE1hc3F1ZXIobTJbMl0pXG4gICAgdGhpcy50cmFpdE1hc3F1ZXIobTJbM10pXG4gICAgb3B0aW9ucy5jb2RhZ2UgPSAnLy8vJ1xuICAgIGNvbnN0IG0zID0gdGhpcy5tZWRpYXRyaWNlQXVDb21wYXMoQSwgQywgb3B0aW9ucylcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtM1swXSlcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtM1sxXSlcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtM1syXSlcbiAgICB0aGlzLnRyYWl0TWFzcXVlcihtM1szXSlcbiAgICBjb25zdCBPID0gY2VudHJlQ2VyY2xlQ2lyY29uc2NyaXQoQSwgQiwgQylcbiAgICBvcHRpb25zLmNvdWxldXIgPSBvcHRpb25zLmNvdWxldXJDZXJjbGVcbiAgICB0aGlzLmNvbXBhc0NlcmNsZUNlbnRyZVBvaW50KE8sIEEsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICoqKioqKioqKioqKioqIFRSSUFOR0xFUyAqKioqKioqKioqKioqKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4gIC8qKlxuICAgKiBNYWNybyBkZSBjb25zdHJ1Y3Rpb24gZCd1biB0cmlhbmdsZSDDoCBwYXJ0aXIgZGUgc2VzIDMgZGltZW5zaW9ucy4gTGUgcHJlbWllciBwb2ludCBhdXJhIHBvdXIgY29vcmRvbm7DqWVzICg2LDApLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gQUJDIFVuZSBjaGFpbmUgZGUgY2FyYWN0w6hyZSBkZSAzIGxldHRyZVxuICAgKiBAcGFyYW0geyp9IEFCIERpc3RhbmNlIGVudHJlIGxlIDFlciBldCBsZSAyZSBzb21tZXRcbiAgICogQHBhcmFtIHsqfSBBQyBEaXN0YW5jZSBlbnRyZSBsZSAxZXIgZXQgbGUgM2Ugc29tbWV0XG4gICAqIEBwYXJhbSB7Kn0gQkMgRGlzdGFuY2UgZW50cmUgbGUgMmUgZXQgbGUgM2Ugc29tbWV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY3JpcHRpb24gQWZmaWNoYWdlIGQndW4gdGV4dGUgZGVzY3JpcHRpZiBkZXMgw6l0YXBlcyBkZSBsYSBjb25zdHJ1Y3Rpb25cbiAgICogQHJldHVybiB7YXJyYXl9IFtBLCBCLCBDXSBsZXMgMyBzb21tZXRzIGR1IHRyaWFuZ2xlIChvYmpldHMgTWF0aEFMRUEyRClcbiAgICovXG4gIHRoaXMudHJpYW5nbGUzbG9uZ3VldXJzID0gZnVuY3Rpb24gKEFCQywgQUIsIEFDLCBCQywgZGVzY3JpcHRpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgQSA9IHBvaW50KDYsIDApXG4gICAgY29uc3QgQiA9IHBvaW50QWRpc3RhbmNlKEEsIEFCLCByYW5kaW50KC0yMCwgMjApKVxuICAgIGNvbnN0IHAgPSB0cmlhbmdsZTJwb2ludHMybG9uZ3VldXJzKEEsIEIsIEFDLCBCQylcbiAgICBjb25zdCBDID0gcC5saXN0ZVBvaW50c1syXVxuICAgIGlmIChBQkMubGVuZ3RoICE9PSAzKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIEEubm9tID0gQUJDWzBdXG4gICAgICBCLm5vbSA9IEFCQ1sxXVxuICAgICAgQy5ub20gPSBBQkNbMl1cbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgJHtBLm5vbSArIEIubm9tfSA9ICR7bm9tYnJlQXZlY0VzcGFjZShBQil9IGNtYCwgMCwgLTIpXG4gICAgdGhpcy5wb2ludENyZWVyKEEpXG4gICAgLy8gdGhpcy5yZWdsZVJvdGF0aW9uKGRyb2l0ZShBLEIpLmFuZ2xlQXZlY0hvcml6b250YWxlKVxuICAgIC8vIHRoaXMucmVnbGVNb250cmVyKEEpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgQilcbiAgICB0aGlzLnBvaW50Q3JlZXIoQilcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Eubm9tICsgQy5ub219ID0gJHtub21icmVBdmVjRXNwYWNlKEFDKX0gY20gZG9uYyAke0Mubm9tfSBhcHBhcnRpZW50IGF1IGNlcmNsZSBkZSBjZW50cmUgJHtBLm5vbX0gZXQgZGUgcmF5b24gJHtub21icmVBdmVjRXNwYWNlKEFDKX0gY20uYCwgMCwgLTMpXG4gICAgdGhpcy5jb3VsZXVyID0gJ2ZvcmVzdGdyZWVuJ1xuICAgIHRoaXMuZXBhaXNzZXVyID0gMlxuICAgIHRoaXMuY29tcGFzTW9udHJlcihBKVxuICAgIHRoaXMuY29tcGFzRWNhcnRlckF2ZWNSZWdsZShBQylcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEEsIEMsIDQwKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Iubm9tICsgQy5ub219ID0gJHtub21icmVBdmVjRXNwYWNlKEJDKX0gY20gZG9uYyAke0Mubm9tfSBhcHBhcnRpZW50IGF1IGNlcmNsZSBkZSBjZW50cmUgJHtCLm5vbX0gZXQgZGUgcmF5b24gJHtub21icmVBdmVjRXNwYWNlKEJDKX0gY20uYCwgMCwgLTQpXG4gICAgdGhpcy5jb21wYXNEZXBsYWNlcihCKVxuICAgIHRoaXMuY29tcGFzRWNhcnRlckF2ZWNSZWdsZShCQylcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEIsIEMpXG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLmNvdWxldXIgPSAnYmx1ZSdcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDNcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgTGUgcG9pbnQgJHtDLm5vbX0gZXN0IMOgIHVuZSBpbnRlcnNlY3Rpb24gZGVzIGRldXggY2VyY2xlcy5gLCAwLCAtNSlcbiAgICB0aGlzLnBvaW50Q3JlZXIoQylcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChCLCBDKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEMsIEEpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgcmV0dXJuIFtBLCBCLCBDXVxuICB9XG4gIC8qKlxuICAgKiBNYWNybyBkZSBjb25zdHJ1Y3Rpb24gZCd1biB0cmlhbmdsZSByZWN0YW5nbGUgKGwnYW5nbGUgZHJvaXQgZXN0IGxlIDJlIHBvaW50IGRhbnMgbCdvcmRyZSBkdSBub20pXG4gICAqICDDoCBwYXJ0aXIgZGUgbGEgZG9ubsOpZSBkZSBsYSBsb25ndWV1ciBkJ3VuIGPDtHTDqSBldCBkZSBsYSBsb25ndWV1ciBkZSBsJ2h5cG90w6ludXNlLlxuICAgKiAgTGUgcHJlbWllciBzb21tZXQgYXVyYSBwb3VyIGNvb3Jkb25uw6llcyAoNiwgMClcbiAgICogQHBhcmFtIHtzdHJpbmd9IEFCQyBVbmUgY2hhaW5lIGRlIGNhcmFjdMOocmUgZGUgMyBsZXR0cmVcbiAgICogQHBhcmFtIHsqfSBBQiBEaXN0YW5jZSBlbnRyZSBsZSAxZXIgZXQgbGUgMmUgc29tbWV0XG4gICAqIEBwYXJhbSB7Kn0gQUMgRGlzdGFuY2UgZW50cmUgbGUgMWVyIGV0IGxlIDNlIHNvbW1ldCAoaHlwb3TDqW51c2UpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY3JpcHRpb24gQWZmaWNoYWdlIGQndW4gdGV4dGUgZGVzY3JpcHRpZiBkZXMgw6l0YXBlcyBkZSBsYSBjb25zdHJ1Y3Rpb25cbiAgICogQHJldHVybiB7YXJyYXl9IFtBLCBCLCBDXSBsZXMgMyBzb21tZXRzIGR1IHRyaWFuZ2xlIChvYmpldHMgTWF0aEFMRUEyRClcbiAgICovXG4gIHRoaXMudHJpYW5nbGVSZWN0YW5nbGVDb3RlSHlwb3RlbnVzZSA9IGZ1bmN0aW9uIChBQkMsIEFCLCBBQywgZGVzY3JpcHRpb24gPSB0cnVlKSB7IC8vIFRyaWFuZ2xlIHJlY3RhbmdsZSBlbiBCXG4gICAgY29uc3QgQSA9IHBvaW50KDYsIDApXG4gICAgY29uc3QgQiA9IHBvaW50QWRpc3RhbmNlKEEsIEFCLCByYW5kaW50KC0yMCwgMjApKVxuICAgIGNvbnN0IGRBQiA9IGRyb2l0ZShBLCBCKVxuICAgIGRBQi5pc1Zpc2libGUgPSBmYWxzZVxuICAgIGNvbnN0IGRCQyA9IGRyb2l0ZVBhclBvaW50RXRQZXJwZW5kaWN1bGFpcmUoQiwgZEFCKVxuICAgIGRCQy5pc1Zpc2libGUgPSBmYWxzZVxuICAgIGNvbnN0IGNBQyA9IGNlcmNsZShBLCBBQylcbiAgICBjQUMuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBDID0gcG9pbnRJbnRlcnNlY3Rpb25MQyhkQkMsIGNBQylcbiAgICBjb25zdCBjID0gaG9tb3RoZXRpZShDLCBCLCAxLjIpXG4gICAgaWYgKEFCQy5sZW5ndGggIT09IDMpIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgQS5ub20gPSBBQkNbMF1cbiAgICAgIEIubm9tID0gQUJDWzFdXG4gICAgICBDLm5vbSA9IEFCQ1syXVxuICAgIH1cblxuICAgIGlmIChsb25ndWV1cihBLCBDKSA+IDgpIHRoaXMuZXF1ZXJyZVpvb20oMTUwKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Eubm9tICsgQi5ub219ID0gJHtub21icmVBdmVjRXNwYWNlKEFCKX0gY21gLCAwLCAtMilcbiAgICB0aGlzLmVxdWVycmVSb3RhdGlvbihkQUIuYW5nbGVBdmVjSG9yaXpvbnRhbGUpXG4gICAgdGhpcy5wb2ludENyZWVyKEEpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgQilcbiAgICB0aGlzLnBvaW50Q3JlZXIoQilcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgJHtBLm5vbSArIEIubm9tICsgQy5ub219IGVzdCB1biB0cmlhbmdsZSByZWN0YW5nbGUgZW4gJHtCLm5vbX0gZG9uYyAke0Mubm9tfSBhcHBhcnRpZW50IMOgIGxhIHBlcnBlbmRpY3VsYWlyZSDDoCAoJHtBLm5vbSArIEIubm9tfSkgcGFzc2FudCBwYXIgJHtCLm5vbX0uYCwgMCwgLTMpXG4gICAgdGhpcy5lcXVlcnJlTW9udHJlcihBKVxuICAgIHRoaXMuZXF1ZXJyZURlcGxhY2VyKEIpXG4gICAgdGhpcy50cmFjZXIoYylcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQoQSwgQiwgQylcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Eubm9tICsgQy5ub219ID0gJHtub21icmVBdmVjRXNwYWNlKEFDKX0gY20gZG9uYyAke0Mubm9tfSBhcHBhcnRpZW50IGF1IGNlcmNsZSBkZSBjZW50cmUgJHtBLm5vbX0gZXQgZGUgcmF5b24gJHtub21icmVBdmVjRXNwYWNlKEFDKX0gY20uYCwgMCwgLTQpXG4gICAgdGhpcy5jb21wYXNNb250cmVyKEEpXG4gICAgdGhpcy5jb21wYXNFY2FydGVyQXZlY1JlZ2xlKEFDKVxuICAgIHRoaXMuY291bGV1ciA9ICdmb3Jlc3RncmVlbidcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDJcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEEsIEMpXG4gICAgdGhpcy5jb3VsZXVyID0gJ2JsdWUnXG4gICAgdGhpcy5lcGFpc3NldXIgPSAyXG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRleHRlUG9zaXRpb24oYCR7Qy5ub219IGVzdCDDoCB1bmUgaW50ZXJzZWN0aW9uIGRlIGxhIHBlcnBlbmRpY3VsYWlyZSBldCBkdSBjZXJjbGUuYCwgMCwgLTUpXG4gICAgdGhpcy5jcmF5b25Nb250cmVyKEMpXG4gICAgdGhpcy5wb2ludENyZWVyKEMpXG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChBLCBDKVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIHJldHVybiBbQSwgQiwgQ11cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWNybyBkZSBjb25zdHJ1Y3Rpb24gZCd1biB0cmlhbmdsZSByZWN0YW5nbGUgKGwnYW5nbGUgZHJvaXQgZXN0IGxlIDJlIHBvaW50IGRhbnMgbCdvcmRyZSBkdSBub20pXG4gICAqICDDoCBwYXJ0aXIgZGUgbGEgZG9ubsOpZSBkZSBsYSBsb25ndWV1ciBkZXMgZGV1eCBjw7R0w6lzIGRlIGwnYW5nbGUgZHJvaXQuXG4gICAqICBMZSBwcmVtaWVyIHNvbW1ldCBhdXJhIHBvdXIgY29vcmRvbm7DqWVzICg2LCAwKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gQUJDIFVuZSBjaGFpbmUgZGUgY2FyYWN0w6hyZSBkZSAzIGxldHRyZVxuICAgKiBAcGFyYW0geyp9IEFCIERpc3RhbmNlIGVudHJlIGxlIDFlciBldCBsZSAyZSBzb21tZXRcbiAgICogQHBhcmFtIHsqfSBBQyBEaXN0YW5jZSBlbnRyZSBsZSAxZXIgZXQgbGUgM2Ugc29tbWV0IChoeXBvdMOpbnVzZSlcbiAgICogQHBhcmFtIHtib29sZWFufSBkZXNjcmlwdGlvbiBBZmZpY2hhZ2UgZCd1biB0ZXh0ZSBkZXNjcmlwdGlmIGRlcyDDqXRhcGVzIGRlIGxhIGNvbnN0cnVjdGlvblxuICAgKiBAcmV0dXJuIHthcnJheX0gW0EsIEIsIENdIGxlcyAzIHNvbW1ldHMgZHUgdHJpYW5nbGUgKG9iamV0cyBNYXRoQUxFQTJEKVxuICAgKi9cbiAgdGhpcy50cmlhbmdsZVJlY3RhbmdsZTJDb3RlcyA9IGZ1bmN0aW9uIChBQkMsIEFCLCBCQywgZGVzY3JpcHRpb24gPSB0cnVlKSB7IC8vIFRyaWFuZ2xlIHJlY3RhbmdsZSBlbiBCXG4gICAgY29uc3QgQSA9IHBvaW50KDYsIDApXG4gICAgY29uc3QgQiA9IHBvaW50QWRpc3RhbmNlKEEsIEFCLCByYW5kaW50KC0yMCwgMjApKVxuICAgIGNvbnN0IGRBQiA9IGRyb2l0ZShBLCBCKVxuICAgIGRBQi5pc1Zpc2libGUgPSBmYWxzZVxuICAgIGNvbnN0IGRCQyA9IGRyb2l0ZVBhclBvaW50RXRQZXJwZW5kaWN1bGFpcmUoQiwgZEFCKVxuICAgIGRCQy5pc1Zpc2libGUgPSBmYWxzZVxuICAgIGNvbnN0IGNCQyA9IGNlcmNsZShCLCBCQylcbiAgICBjQkMuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBDID0gcG9pbnRJbnRlcnNlY3Rpb25MQyhkQkMsIGNCQylcbiAgICBjb25zdCBjID0gaG9tb3RoZXRpZShDLCBCLCAxLjIpXG4gICAgaWYgKEFCQy5sZW5ndGggIT09IDMpIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgQS5ub20gPSBBQkNbMF1cbiAgICAgIEIubm9tID0gQUJDWzFdXG4gICAgICBDLm5vbSA9IEFCQ1syXVxuICAgIH1cblxuICAgIGlmIChsb25ndWV1cihBLCBDKSA+IDgpIHRoaXMuZXF1ZXJyZVpvb20oMTUwKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Eubm9tICsgQi5ub219ID0gJHtub21icmVBdmVjRXNwYWNlKEFCKX0gY21gLCAwLCAtMilcbiAgICB0aGlzLmVxdWVycmVSb3RhdGlvbihkQUIuYW5nbGVBdmVjSG9yaXpvbnRhbGUpXG4gICAgdGhpcy5wb2ludENyZWVyKEEpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgQilcbiAgICB0aGlzLnBvaW50Q3JlZXIoQilcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgJHtBLm5vbSArIEIubm9tICsgQy5ub219IGVzdCB1biB0cmlhbmdsZSByZWN0YW5nbGUgZW4gJHtCLm5vbX0gZG9uYyAke0Mubm9tfSBhcHBhcnRpZW50IMOgIGxhIHBlcnBlbmRpY3VsYWlyZSDDoCAoJHtBLm5vbSArIEIubm9tfSkgcGFzc2FudCBwYXIgJHtCLm5vbX0uYCwgMCwgLTMpXG4gICAgdGhpcy5lcXVlcnJlTW9udHJlcihBKVxuICAgIHRoaXMuZXF1ZXJyZURlcGxhY2VyKEIpXG4gICAgdGhpcy50cmFjZXIoYylcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQoQSwgQiwgQylcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgJHtCLm5vbSArIEMubm9tfSA9ICR7bm9tYnJlQXZlY0VzcGFjZShCQyl9IGNtIGRvbmMgJHtDLm5vbX0gZXN0IMOgICR7bm9tYnJlQXZlY0VzcGFjZShCQyl9IGNtIGRlICR7Qi5ub219IHN1ciBsYSBwZXJwZW5kaWN1bGFpcmUgw6AgKCR7QS5ub20gKyBCLm5vbX0pIHBhc3NhbnQgcGFyICR7Qi5ub219LmAsIDAsIC00KVxuICAgIHRoaXMucmVnbGVNb250cmVyKEIpXG4gICAgdGhpcy5yZWdsZVJvdGF0aW9uKEMpXG4gICAgdGhpcy5jcmF5b25EZXBsYWNlcihDKVxuICAgIHRoaXMucG9pbnRDcmVlcihDKVxuICAgIHRoaXMuY291bGV1ciA9ICdibHVlJ1xuICAgIHRoaXMuZXBhaXNzZXVyID0gMlxuICAgIHRoaXMuY29tcGFzTWFzcXVlcigpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgQylcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcblxuICAgIHJldHVybiBbQSwgQiwgQ11cbiAgfVxuICAvKipcbiAgICogTWFjcm8gZGUgY29uc3RydWN0aW9uIGQndW4gdHJpYW5nbGUgw6AgcGFydGlyIGQndW5lIGxvbmd1ZXVyIGV0IGRlcyAyIGFuZ2xlcyBhZGFqY2VudHMgYXUgY8O0dMOpIGNvbm51LiBMZSBwcmVtaWVyIHBvaW50IGF1cmEgcG91ciBjb29yZG9ubsOpZXMgKDYsMCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBBQkMgVW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlIGRlIDMgbGV0dHJlXG4gICAqIEBwYXJhbSB7Kn0gQUIgRGlzdGFuY2UgZW50cmUgbGUgMWVyIGV0IGxlIDJlIHNvbW1ldFxuICAgKiBAcGFyYW0geyp9IEJBQyBBbmdsZSBhdSAxZXIgc29tbWV0XG4gICAqIEBwYXJhbSB7Kn0gQ0JBIEFuZ2xlIGF1IDJlIHNvbW1ldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlc2NyaXB0aW9uIEFmZmljaGFnZSBkJ3VuIHRleHRlIGRlc2NyaXB0aWYgZGVzIMOpdGFwZXMgZGUgbGEgY29uc3RydWN0aW9uXG4gICAqIEByZXR1cm4ge2FycmF5fSBbQSwgQiwgQ10gbGVzIDMgc29tbWV0cyBkdSB0cmlhbmdsZSAob2JqZXRzIE1hdGhBTEVBMkQpXG4gICAqL1xuICB0aGlzLnRyaWFuZ2xlMWxvbmd1ZXVyMmFuZ2xlcyA9IGZ1bmN0aW9uIChOT00sIEFCLCBCQUMsIENCQSwgZGVzY3JpcHRpb24gPSB0cnVlLCBtZXN1cmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFuZ2xlID0gcmFuZGludCgtMjAsIDIwKVxuICAgIGNvbnN0IGExID0gQkFDXG4gICAgY29uc3QgYTIgPSBDQkFcbiAgICBjb25zdCBBID0gcG9pbnQoNiwgMClcbiAgICBjb25zdCBCID0gcG9pbnRBZGlzdGFuY2UoQSwgQUIsIGFuZ2xlKVxuICAgIGNvbnN0IEQgPSBwb2ludEFkaXN0YW5jZShBLCA1LjIsIGExICsgYW5nbGUpXG4gICAgY29uc3QgRDIgPSBwb2ludFN1clNlZ21lbnQoQSwgRCwgMTApXG4gICAgY29uc3QgRDEgPSBwb2ludFN1clNlZ21lbnQoRCwgRDIsIDAuNClcbiAgICBjb25zdCBFID0gcG9pbnRBZGlzdGFuY2UoQiwgMywgMTgwIC0gYTIgKyBhbmdsZSlcbiAgICBjb25zdCBFMiA9IHBvaW50U3VyU2VnbWVudChCLCBFLCAxMClcbiAgICBjb25zdCBFMSA9IHBvaW50U3VyU2VnbWVudChFLCBFMiwgLTAuNClcbiAgICBjb25zdCBGID0gcG9pbnRBZGlzdGFuY2UoQiwgNS4yLCAxODAgLSBhMiArIGFuZ2xlKVxuICAgIGNvbnN0IEYxID0gcG9pbnRTdXJTZWdtZW50KEYsIEUyLCAwLjQpXG4gICAgY29uc3QgZCA9IHJvdGF0aW9uKGRyb2l0ZShBLCBCKSwgQSwgYTEpXG4gICAgRC5pc1Zpc2libGUgPSBmYWxzZVxuICAgIGNvbnN0IGQyID0gcm90YXRpb24oZHJvaXRlKEIsIEEpLCBCLCAtYTIpXG4gICAgZDIuaXNWaXNpYmxlID0gZmFsc2VcbiAgICBjb25zdCBDID0gcG9pbnRJbnRlcnNlY3Rpb25ERChkLCBkMilcbiAgICBpZiAoTk9NLmxlbmd0aCAhPT0gMykge1xuICAgICAgZGVzY3JpcHRpb24gPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBBLm5vbSA9IE5PTVswXVxuICAgICAgQi5ub20gPSBOT01bMV1cbiAgICAgIEMubm9tID0gTk9NWzJdXG4gICAgfVxuICAgIHRoaXMuY291bGV1ciA9ICdibHVlJ1xuICAgIHRoaXMuZXBhaXNzZXVyID0gM1xuICAgIHRoaXMucG9pbnRDcmVlcihBKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGBPbiB0cmFjZSBsZSBjw7R0w6kgWyR7QS5ub20gKyBCLm5vbX1dIGRlICR7bm9tYnJlQXZlY0VzcGFjZShBQil9IGNtLmAsIDAsIC00KVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEEsIEIpXG4gICAgdGhpcy5wb2ludENyZWVyKEIpXG4gICAgdGhpcy5jb3VsZXVyID0gJ2dyZXknXG4gICAgdGhpcy5lcGFpc3NldXIgPSAxXG4gICAgdGhpcy5yYXBwb3J0ZXVyTW9udHJlcihBKVxuICAgIHRoaXMucmFwcG9ydGV1ckRlcGxhY2VyKEEpXG4gICAgdGhpcy5yYXBwb3J0ZXVyUm90YXRpb24oYW5nbGUpXG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRleHRlUG9zaXRpb24oYE9uIHBsYWNlIHVuIHJlcMOocmUgw6AgJHthMX0gZGVncsOpcyBwb3VyIHRyYWNlciBsYSBkZW1pLWRyb2l0ZSBbJHtBLm5vbSArIEMubm9tfSkuYCwgMCwgLTUpXG4gICAgdGhpcy5lcGFpc3NldXIgPSAzXG4gICAgdGhpcy50cmFpdChELCBEMSwgMjApXG4gICAgdGhpcy5lcGFpc3NldXIgPSAxXG4gICAgdGhpcy5yYXBwb3J0ZXVyTWFzcXVlcigpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgRDIpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuYW5nbGVDb2RhZ2UoQiwgQSwgQylcbiAgICB0aGlzLnJhcHBvcnRldXJNb250cmVyKEEpXG4gICAgdGhpcy5yYXBwb3J0ZXVyRGVwbGFjZXIoQilcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGV4dGVQb3NpdGlvbihgT24gcGxhY2UgdW4gcmVww6hyZSDDoCAke2EyfSBkZWdyw6lzIHBvdXIgdHJhY2VyIGxhIGRlbWktZHJvaXRlIFske0Iubm9tICsgQy5ub219KS5gLCAwLCAtNilcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDNcbiAgICB0aGlzLnRyYWl0KEUsIEUxLCAxMClcbiAgICB0aGlzLnRyYWl0KEYsIEYxLCAyMClcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDFcbiAgICB0aGlzLnJhcHBvcnRldXJNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlTW9udHJlcihCKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEIsIEUyKVxuICAgIHRoaXMuYW5nbGVDb2RhZ2UoQywgQiwgQSlcbiAgICB0aGlzLnBvaW50Q3JlZXIoQywgJycsIDApXG4gICAgdGhpcy5wb2ludE5vbW1lcihDLCBDLm5vbSwgLTAuNSwgMSlcbiAgICB0aGlzLmNvdWxldXIgPSAnYmx1ZSdcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDNcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChCLCBDKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEMsIEEpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgaWYgKGRlc2NyaXB0aW9uICYmIG1lc3VyZSkgdGhpcy50ZXh0ZVBvc2l0aW9uKGBPbiBwZXV0IG1lc3VyZXIgJHtBLm5vbSArIEMubm9tfSDiiYggJHtub21icmVBdmVjRXNwYWNlKGxvbmd1ZXVyKEEsIEMsIDEpKX0gY20gZXQgJHtCLm5vbSArIEMubm9tfSDiiYggJHtub21icmVBdmVjRXNwYWNlKGxvbmd1ZXVyKEIsIEMsIDEpKX0gY20uYCwgMCwgLTcpXG5cbiAgICByZXR1cm4gW0EsIEIsIENdXG4gIH1cbiAgLyoqXG4gICAqIE1hY3JvIGRlIGNvbnN0cnVjdGlvbiBkJ3VuIHRyaWFuZ2xlIMOgIHBhcnRpciBkZXMgbG9uZ3VldXJzIGRlcyBkZXV4IGPDtHTDqXMgZCd1biBhbmdsZSBMZSBwcmVtaWVyIHBvaW50IGEgcG91ciBjb29yZG9ubsOpZXMgKDYsMCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBBQkMgVW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlIGRlIDMgbGV0dHJlXG4gICAqIEBwYXJhbSB7Kn0gQUIgRGlzdGFuY2UgZW50cmUgbGUgMWVyIGV0IGxlIDJlIHNvbW1ldFxuICAgKiBAcGFyYW0geyp9IEFDIERpc3RhbmNlIGVudHJlIGxlIDFlciBldCBsZSAzZSBzb21tZXRcbiAgICogQHBhcmFtIHsqfSBCQUMgQW5nbGUgYXUgMWVyIHNvbW1ldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlc2NyaXB0aW9uIEFmZmljaGFnZSBkJ3VuIHRleHRlIGRlc2NyaXB0aWYgZGVzIMOpdGFwZXMgZGUgbGEgY29uc3RydWN0aW9uXG4gICAqIEByZXR1cm4ge2FycmF5fSBbQSwgQiwgQ10gbGVzIDMgc29tbWV0cyBkdSB0cmlhbmdsZSAob2JqZXRzIE1hdGhBTEVBMkQpXG4gICAqL1xuICB0aGlzLnRyaWFuZ2xlMmxvbmd1ZXVyczFhbmdsZSA9IGZ1bmN0aW9uIChOT00sIEFCLCBBQywgQkFDLCBkZXNjcmlwdGlvbiA9IHRydWUsIG1lc3VyZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgYW5nbGUgPSByYW5kaW50KC0yMCwgMjApXG4gICAgY29uc3QgYTEgPSBCQUNcbiAgICBjb25zdCBBID0gcG9pbnQoNiwgMClcbiAgICBjb25zdCBCID0gcG9pbnRBZGlzdGFuY2UoQSwgQUIsIGFuZ2xlKVxuICAgIGNvbnN0IEQgPSBwb2ludEFkaXN0YW5jZShBLCA1LjIsIGExICsgYW5nbGUpXG4gICAgY29uc3QgRDIgPSBwb2ludFN1clNlZ21lbnQoQSwgRCwgMTApXG4gICAgY29uc3QgRDEgPSBwb2ludFN1clNlZ21lbnQoRCwgRDIsIDAuNClcbiAgICBjb25zdCBDID0gcG9pbnRTdXJTZWdtZW50KEEsIEQyLCBBQylcbiAgICBpZiAoTk9NLmxlbmd0aCAhPT0gMykge1xuICAgICAgZGVzY3JpcHRpb24gPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBBLm5vbSA9IE5PTVswXVxuICAgICAgQi5ub20gPSBOT01bMV1cbiAgICAgIEMubm9tID0gTk9NWzJdXG4gICAgfVxuICAgIHRoaXMuY291bGV1ciA9ICdibHVlJ1xuICAgIHRoaXMuZXBhaXNzZXVyID0gM1xuICAgIHRoaXMucG9pbnRDcmVlcihBKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGBPbiB0cmFjZSBsZSBjw7R0w6kgWyR7QS5ub20gKyBCLm5vbX1dIGRlICR7bm9tYnJlQXZlY0VzcGFjZShBQil9IGNtLmAsIDAsIC00KVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEEsIEIpXG4gICAgdGhpcy5wb2ludENyZWVyKEIpXG4gICAgdGhpcy5jb3VsZXVyID0gJ2dyZXknXG4gICAgdGhpcy5lcGFpc3NldXIgPSAxXG4gICAgdGhpcy5yYXBwb3J0ZXVyTW9udHJlcihBKVxuICAgIHRoaXMucmFwcG9ydGV1ckRlcGxhY2VyKEEpXG4gICAgdGhpcy5yYXBwb3J0ZXVyUm90YXRpb24oYW5nbGUpXG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRleHRlUG9zaXRpb24oYE9uIHBsYWNlIHVuIHJlcMOocmUgw6AgJHthMX0gZGVncsOpcyBwb3VyIHRyYWNlciBsYSBkZW1pLWRyb2l0ZSBbJHtBLm5vbSArIEMubm9tfSkuYCwgMCwgLTUpXG4gICAgdGhpcy5lcGFpc3NldXIgPSAzXG4gICAgdGhpcy50cmFpdChELCBEMSwgMjApXG4gICAgdGhpcy5lcGFpc3NldXIgPSAxXG4gICAgdGhpcy5yYXBwb3J0ZXVyTWFzcXVlcigpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgRDIpXG4gICAgdGhpcy5hbmdsZUNvZGFnZShCLCBBLCBDKVxuICAgIHRoaXMucmFwcG9ydGV1ck1hc3F1ZXIoKVxuICAgIGlmIChkZXNjcmlwdGlvbikgdGhpcy50ZXh0ZVBvc2l0aW9uKGBPbiBwbGFjZSBsZSBwb2ludCAke0Mubm9tfSBzdXIgbGEgZGVtaS1kcm9pdGUgWyR7QS5ub20gKyBDLm5vbX0pIMOgICR7QUN9IGNtIGRlICR7QS5ub219LmAsIDAsIC02KVxuICAgIHRoaXMuZXBhaXNzZXVyID0gM1xuICAgIHRoaXMuY291bGV1ciA9ICdibHVlJ1xuICAgIHRoaXMuY3JheW9uRGVwbGFjZXIoQylcbiAgICB0aGlzLnBvaW50Q3JlZXIoQylcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChBLCBDKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRleHRlUG9zaXRpb24oYE9uIHRyYWNlIGxlIGPDtHTDqSBbJHtCLm5vbSArIEMubm9tfV0uYCwgMCwgLTcpXG4gICAgdGhpcy5yZWdsZU1vbnRyZXIoQylcbiAgICB0aGlzLmNyYXlvbk1vbnRyZXIoQylcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChDLCBCKVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIHJldHVybiBbQSwgQiwgQ11cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFjZSB1biB0cmlhbmdsZSDDqXF1aWxhdMOpcmFsIMOgIHBhcnRpciBkZSBsYSBkb25uw6llIGRlIDIgcG9pbnRzXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtwb2ludH0gQlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9tQ1xuICAgKiBAcmV0dXJuIHthcnJheX0gW0EsIEIsIENdXG4gICAqL1xuICB0aGlzLnRyaWFuZ2xlRXF1aWxhdGVyYWwyU29tbWV0cyA9IGZ1bmN0aW9uIChBLCBCLCBub21DID0gJycpIHtcbiAgICBjb25zdCBDID0gcm90YXRpb24oQiwgQSwgNjApXG4gICAgQy5ub20gPSBub21DXG4gICAgdGhpcy50cmFpdFJhcGlkZShBLCBCKVxuICAgIHRoaXMucG9pbnRDcmVlcihBLCBBLm5vbSwgMClcbiAgICB0aGlzLnBvaW50Q3JlZXIoQiwgQi5ub20sIDApXG4gICAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyhBLCBCKVxuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQSwgQylcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEIsIEMpXG4gICAgdGhpcy5wb2ludENyZWVyKEMpXG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChBLCBDKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEMsIEIpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIEIpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIEMpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEIsIEMpXG4gICAgcmV0dXJuIFtBLCBCLCBDXVxuICB9XG4gIC8qKlxuICAgKiBUcmFjZSB1biB0cmlhbmdsZSDDqXF1aWxhdMOpcmFsIMOgIHBhcnRpciBkZSBsYSBkb25uw6llIGRlIGxhIGxvbmd1ZXVyIGR1IGPDtHTDqS4gTGUgcHJlbWllciBwb2ludCBhIHBvdXIgY29vcmRvbm7DqWVzICg2OzApXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBOT01cbiAgICogQHBhcmFtIHtudW1iZXJ9IEFCXG4gICAqIEByZXR1cm4ge2FycmF5fSBbQSwgQiwgQ11cbiAgICovXG5cbiAgdGhpcy50cmlhbmdsZUVxdWlsYXRlcmFsID0gZnVuY3Rpb24gKE5PTSwgQUIpIHtcbiAgICBjb25zdCBBID0gcG9pbnQoNiwgMClcbiAgICBjb25zdCBCID0gcG9pbnRBZGlzdGFuY2UoQSwgQUIsIHJhbmRpbnQoLTIwLCAyMCkpXG4gICAgY29uc3QgQyA9IHJvdGF0aW9uKEIsIEEsIDYwKVxuICAgIGlmIChOT00ubGVuZ3RoID09PSAzKSB7XG4gICAgICBBLm5vbSA9IE5PTVswXVxuICAgICAgQi5ub20gPSBOT01bMV1cbiAgICAgIEMubm9tID0gTk9NWzJdXG4gICAgfVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEEsIEIpXG4gICAgdGhpcy5wb2ludENyZWVyKEEpXG4gICAgdGhpcy5wb2ludENyZWVyKEIpXG4gICAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyhBLCBCKVxuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQSwgQylcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEIsIEMpXG4gICAgdGhpcy5wb2ludENyZWVyKEMpXG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChBLCBDKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEMsIEIpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIEIpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIEMpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEIsIEMpXG4gICAgcmV0dXJuIFtBLCBCLCBDXVxuICB9XG5cbiAgLyoqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKioqKioqKioqKioqKiogUEFSQUxMRUxPR1JBTU1FUyAqKioqKioqKioqKioqKioqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuICAvKipcbiAgICogVHJhY2UgdW4gcGFyYWxsw6lsb2dyYW1tZSDDoCBwYXJ0aXIgZGUgbGEgZG9ubsOpZSBkZSAzIHNvbW1ldHMgY29uc8OpY3V0aWZzXG4gICAqIEBwYXJhbSB7cG9pbnR9IEFcbiAgICogQHBhcmFtIHtwb2ludH0gQlxuICAgKiBAcGFyYW0ge3BvaW50fSBDXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub21EXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBjc0RlamFUcmFjZXMgw4AgdHJ1ZSAocGFyIGTDqWZhdXQpLCBsZXMgMiBjw7R0w6lzIHNlcm9udCBmYWl0cyBpbW3DqWRpYXRlbWVudCwgc2lub24sIG9uIGxlcyB0cmFjZXJhIMOgIGxhIHLDqGdsZS5cbiAgICovXG4gIHRoaXMucGFyYWxsZWxvZ3JhbW1lM3NvbW1ldHNDb25zZWN1dGlmcyA9IGZ1bmN0aW9uIChBLCBCLCBDLCBub21EID0gJycsIGRlc2NyaXB0aW9uID0gdHJ1ZSwgY3NEZWphVHJhY2VzID0gdHJ1ZSkge1xuICAgIGNvbnN0IEQgPSB0cmFuc2xhdGlvbjJQb2ludHMoQywgQiwgQSlcbiAgICBELm5vbSA9IG5vbURcbiAgICBjb25zdCB4TWluID0gTWF0aC5taW4oQS54LCBCLngsIEMueCwgRC54KVxuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbihBLnksIEIueSwgQy55LCBELnkpXG4gICAgLy8gY29uc3QgeE1heCA9IE1hdGgubWF4KEEueCwgQi54LCBDLngsIEQueClcbiAgICAvLyBjb25zdCB5TWF4ID0gTWF0aC5tYXgoQS55LCBCLnksIEMueSwgRC55KVxuICAgIHRoaXMudHJhaXRSYXBpZGUoQSwgQilcbiAgICB0aGlzLnRyYWl0UmFwaWRlKEIsIEMpXG4gICAgdGhpcy5wb2ludENyZWVyKEEsIEEubm9tLCAwKVxuICAgIHRoaXMucG9pbnRDcmVlcihCLCBCLm5vbSwgMClcbiAgICB0aGlzLnBvaW50Q3JlZXIoQywgQy5ub20sIDApXG4gICAgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Eubm9tICsgQi5ub20gKyBDLm5vbSArIEQubm9tfSBlc3QgdW4gcGFyYWxsw6lsb2dyYW1tZSBkb25jIHNlcyBjw7R0w6lzIG9wcG9zw6lzIHNvbnQgZGUgbcOqbWUgbG9uZ3VldXIuYCwgeE1pbiAtIDEsIHlNaW4gLSAxKVxuICAgIHRoaXMuY29tcGFzRWNhcnRlcjJQb2ludHMoQiwgQSlcbiAgICB0aGlzLnRleHRlUG9zaXRpb24oYCR7Qi5ub20gKyBBLm5vbX0gPSAke0Mubm9tICsgRC5ub219YCwgeE1pbiAtIDEsIHlNaW4gLSAyKVxuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoQywgRClcbiAgICB0aGlzLmNvbXBhc0VjYXJ0ZXIyUG9pbnRzKEIsIEMpXG4gICAgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Iubm9tICsgQy5ub219ID0gJHtBLm5vbSArIEQubm9tfWAsIHhNaW4gLSAxLCB5TWluIC0gMylcbiAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEEsIEQsIDEwKVxuICAgIHRoaXMucG9pbnRDcmVlcihEKVxuICAgIHRoaXMuY29tcGFzTWFzcXVlcigpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQywgRClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChELCBBKVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShBLCBCLCB7IGNvZGFnZTogJy8vLycsIGNvdWxldXI6IHRoaXMuY291bGV1ckNvZGFnZSwgdGVtcG86IDAgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoRCwgQywgeyBjb2RhZ2U6ICcvLy8nLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb2RhZ2UsIHRlbXBvOiAwIH0pXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEIsIEMsIHsgY29kYWdlOiAnLy8nLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb2RhZ2UsIHRlbXBvOiAwIH0pXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEEsIEQsIHsgY29kYWdlOiAnLy8nLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb2RhZ2UsIHRlbXBvOiAwIH0pXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIGxlIHBhcmFsbMOpbG9ncmFtbWUgQUJDRCBkZSBjZW50cmUgTyDDoCBwYXJ0aXIgZGUgW0FCXSBldCBPLlxuICAgKiBAcGFyYW0ge3BvaW50fSBBXG4gICAqIEBwYXJhbSB7cG9pbnR9IEJcbiAgICogQHBhcmFtIHtwb2ludH0gT1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9tQ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9tRFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlc2NyaXB0aW9uXG4gICAqL1xuICB0aGlzLnBhcmFsbGVsb2dyYW1tZTJzb21tZXRzQ29uc2VjdXRpZnNDZW50cmUgPSBmdW5jdGlvbiAoQSwgQiwgTywgbm9tQyA9ICcnLCBub21EID0gJycsIGRlc2NyaXB0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IEMgPSB0cmFuc2xhdGlvbjJQb2ludHMoTywgQSwgTylcbiAgICBDLm5vbSA9IG5vbUNcbiAgICBjb25zdCBEID0gdHJhbnNsYXRpb24yUG9pbnRzKE8sIEIsIE8pXG4gICAgRC5ub20gPSBub21EXG4gICAgY29uc3Qgbm9tID0gQS5ub20gKyBCLm5vbSArIEMubm9tICsgRC5ub21cbiAgICBpZiAobG9uZ3VldXIoQSwgQykgPiAxMiB8fCBsb25ndWV1cihCLCBEKSA+IDEyKSB7XG4gICAgICB0aGlzLnJlZ2xlTW9kaWZpZXJMb25ndWV1cigzMClcbiAgICB9XG4gICAgY29uc3QgeE1pbiA9IE1hdGgubWluKEEueCwgQi54LCBDLngsIEQueClcbiAgICBjb25zdCB5TWluID0gTWF0aC5taW4oQS55LCBCLnksIEMueSwgRC55KVxuICAgIC8vIGNvbnN0IHhNYXggPSBNYXRoLm1heChBLngsIEIueCwgQy54LCBELngpXG4gICAgLy8gY29uc3QgeU1heCA9IE1hdGgubWF4KEEueSwgQi55LCBDLnksIEQueSlcbiAgICB0aGlzLnRyYWl0UmFwaWRlKEEsIEIpXG4gICAgdGhpcy5wb2ludENyZWVyKEEsIHsgdGVtcG86IDAgfSlcbiAgICB0aGlzLnBvaW50Q3JlZXIoQiwgeyB0ZW1wbzogMCB9KVxuICAgIHRoaXMucG9pbnRDcmVlcihPLCB7IHRlbXBvOiAwIH0pXG4gICAgaWYgKGRlc2NyaXB0aW9uICYmIG5vbS5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRoaXMudGV4dGVQb3NpdGlvbihgJHtBLm5vbSArIEIubm9tICsgQy5ub20gKyBELm5vbX0gZXN0IHVuIHBhcmFsbMOpbG9ncmFtbWUgZG9uYyBzZXMgZGlhZ29uYWxlcyBzZSBjb3VwZW50IGVuIGxldXIgbWlsaWV1LmAsIHhNaW4gLSAxLCB5TWluIC0gMSlcbiAgICB9XG4gICAgdGhpcy5wb2ludGlsbGVzID0gdHJ1ZVxuICAgIHRoaXMuZXBhaXNzZXVyID0gMVxuICAgIHRoaXMuY291bGV1ciA9IHRoaXMuY291bGV1clRyYWl0c0RlQ29uc3RydWN0aW9uXG4gICAgdGhpcy5yZWdsZURlbWlEcm9pdGVPcmlnaW5lUG9pbnQoQSwgTywgeyBsb25ndWV1cjogbG9uZ3VldXIoQSwgQykgKyAzIH0pXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uTWFzcXVlcigpXG4gICAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyhBLCBPKVxuICAgIGlmIChkZXNjcmlwdGlvbiAmJiBub20ubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aGlzLnRleHRlUG9zaXRpb24oYCR7QS5ub20gKyBPLm5vbX0gPSAke08ubm9tICsgQy5ub219YCwgeE1pbiAtIDEsIHlNaW4gLSAyKVxuICAgIH1cbiAgICB0aGlzLnBvaW50aWxsZXMgPSBmYWxzZVxuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoTywgQylcbiAgICB0aGlzLmNvbXBhc01hc3F1ZXIoKVxuICAgIHRoaXMucG9pbnRpbGxlcyA9IHRydWVcbiAgICB0aGlzLnJlZ2xlRGVtaURyb2l0ZU9yaWdpbmVQb2ludChCLCBPLCB7IGxvbmd1ZXVyOiBsb25ndWV1cihCLCBEKSArIDMgfSlcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICB0aGlzLnBvaW50aWxsZXMgPSBmYWxzZVxuICAgIHRoaXMuY29tcGFzRWNhcnRlcjJQb2ludHMoQiwgTylcbiAgICBpZiAoZGVzY3JpcHRpb24gJiYgbm9tLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhpcy50ZXh0ZVBvc2l0aW9uKGAke0Iubm9tICsgTy5ub219ID0gJHtPLm5vbSArIEQubm9tfWAsIHhNaW4gLSAxLCB5TWluIC0gMylcbiAgICB9XG4gICAgdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChPLCBEKVxuICAgIHRoaXMuY29tcGFzTWFzcXVlcigpXG4gICAgdGhpcy5jb3VsZXVyID0gJ2JsdWUnXG4gICAgdGhpcy5lcGFpc3NldXIgPSAzXG4gICAgdGhpcy5wb2ludENyZWVyKEQpXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQSwgRClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChELCBDKVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEMsIEIpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuY29tcGFzTWFzcXVlcigpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoQSwgTywgeyBjb2RhZ2U6ICcvLycsIGNvdWxldXI6IHRoaXMuY291bGV1ckNvZGFnZSwgdGVtcG86IDAgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoTywgQywgeyBjb2RhZ2U6ICcvLycsIGNvdWxldXI6IHRoaXMuY291bGV1ckNvZGFnZSwgdGVtcG86IDAgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoQiwgTywgeyBjb2RhZ2U6ICdPJywgY291bGV1cjogdGhpcy5jb3VsZXVyQ29kYWdlLCB0ZW1wbzogMCB9KVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShPLCBELCB7IGNvZGFnZTogJ08nLCBjb3VsZXVyOiB0aGlzLmNvdWxldXJDb2RhZ2UsIHRlbXBvOiAwIH0pXG4gIH1cbiAgLyoqXG4gICAqIFRyYWNlIGxhIHBhcmFsbMOpbG9ncmFtbWUgQUJDRCBkZSBjZW50cmUgTyBlbiBwYXJ0YW50IGRlIFtBRCksIFtBQikgZXQgTyAobWFpcyBzYW5zIHZvaXIgbGEgcG9zaXRpb24gZGUgQiBldCBEIGF1IGTDqXBhcnQpXG4gICAqIEBwYXJhbSB7cG9pbnR9IERcbiAgICogQHBhcmFtIHtwb2ludH0gQVxuICAgKiBAcGFyYW0ge3BvaW50fSBCXG4gICAqIEBwYXJhbSB7cG9pbnR9IE9cbiAgICovXG4gIHRoaXMucGFyYWxsZWxvZ3JhbW1lQW5nbGVDZW50cmUgPSBmdW5jdGlvbiAoRCwgQSwgQiwgTykge1xuICAgIGNvbnN0IEIxID0gcG9pbnRTdXJTZWdtZW50KEEsIEIsIGxvbmd1ZXVyKEEsIEIpICsgMilcbiAgICBjb25zdCBEMSA9IHBvaW50U3VyU2VnbWVudChBLCBELCBsb25ndWV1cihBLCBEKSArIDIpXG4gICAgY29uc3QgQyA9IHRyYW5zbGF0aW9uMlBvaW50cyhCLCBBLCBEKVxuICAgIHRoaXMudHJhaXRSYXBpZGUoQSwgQjEpXG4gICAgdGhpcy50cmFpdFJhcGlkZShBLCBEMSlcbiAgICB0aGlzLnBvaW50Q3JlZXIoTywgeyB0ZW1wbzogMCB9KVxuICAgIHRoaXMucG9pbnRDcmVlcihBLCB7IHRlbXBvOiAwIH0pXG4gICAgdGhpcy5yZWdsZURlbWlEcm9pdGVPcmlnaW5lUG9pbnQoQSwgTywgeyBjb3VsZXVyOiB0aGlzLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiwgZXBhaXNzZXVyOiAxLCBwb2ludGlsbGVzOiB0cnVlIH0pXG4gICAgdGhpcy5wb2ludGlsbGVzID0gZmFsc2VcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICB0aGlzLmNvbXBhc0VjYXJ0ZXIyUG9pbnRzKEEsIE8pXG4gICAgdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChPLCBDLCB7IGNvdWxldXI6IHRoaXMuY291bGV1clRyYWl0c0RlQ29uc3RydWN0aW9uIH0pXG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLnBhcmFsbGVsZVJlZ2xlRXF1ZXJyZTJwb2ludHMzZXBvaW50KEIxLCBBLCBDLCB7IGNvdWxldXI6IHRoaXMuY291bGV1clRyYWl0c0RlQ29uc3RydWN0aW9uLCBlcGFpc3NldXI6IDEgfSlcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICB0aGlzLnJlZ2xlRHJvaXRlKEMsIEQsIHsgY291bGV1cjogdGhpcy5jb3VsZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24sIGVwYWlzc2V1cjogMSB9KVxuICAgIHRoaXMucGFyYWxsZWxlUmVnbGVFcXVlcnJlMnBvaW50czNlcG9pbnQoQSwgRDEsIEMsIHsgY291bGV1cjogdGhpcy5jb3VsZXVyVHJhaXRzRGVDb25zdHJ1Y3Rpb24sIGVwYWlzc2V1cjogMSB9KVxuICAgIHRoaXMuZXF1ZXJyZU1hc3F1ZXIoKVxuICAgIHRoaXMucmVnbGVEcm9pdGUoQywgQiwgeyBjb3VsZXVyOiB0aGlzLmNvdWxldXJUcmFpdHNEZUNvbnN0cnVjdGlvbiwgZXBhaXNzZXVyOiAxIH0pXG4gICAgdGhpcy5wb2ludENyZWVyKEQsIHsgdGVtcG86IDAgfSlcbiAgICB0aGlzLnBvaW50Q3JlZXIoQiwgeyB0ZW1wbzogMCB9KVxuICAgIHRoaXMucG9pbnRDcmVlcihDLCB7IHRlbXBvOiAwIH0pXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQiwgQylcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChDLCBEKVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICoqKioqKioqKioqKioqIENhcnLDqXMgKioqKioqKioqKioqKioqKlxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNYWNybyBjcsOpZSBwYXIgU29waGllIERlc3J1ZWxsZVxuICAgKiBAcGFyYW0ge29iamV0fSBBXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gICAqIEByZXR1cm5zIHBvbHlnb25lQXZlY05vbVxuICAgKi9cbiAgdGhpcy5jYXJyZTFwb2ludDFsb25ndWV1ciA9IGZ1bmN0aW9uIChub20sIEEsIGMpIHtcbiAgICBjb25zdCBpbnRlcmxpZ25lID0gMVxuICAgIEEgPSBwb2ludCg1LCAwLCBub21bMF0pXG4gICAgY29uc3QgQiA9IHBvaW50QWRpc3RhbmNlKEEsIGMsIHJhbmRpbnQoLTIwLCAyMCksIG5vbVsxXSlcbiAgICBjb25zdCBDID0gcm90YXRpb24oQSwgQiwgLTkwLCBub21bMl0pXG4gICAgY29uc3QgRCA9IHJvdGF0aW9uKEIsIEEsIDkwLCBub21bM10pXG4gICAgY29uc3QgRSA9IHBvaW50U3VyU2VnbWVudChBLCBELCBjICsgMiwgJ0UnKVxuICAgIGNvbnN0IEYgPSBwb2ludFN1clNlZ21lbnQoRCwgQywgYyArIDIsICdGJylcbiAgICB0aGlzLmVxdWVycmVab29tKChjICsgMykgKiAxMDAgLyA3LjUpXG4gICAgdGhpcy50ZW1wbyA9IDIwXG5cbiAgICB0aGlzLnRleHRlUG9zaXRpb24oYDEpIE9uIHZldXQgY29uc3RydWlyZSB1biBjYXJyw6kgZG9udCBsZXMgY8O0dMOpcyBtZXN1cmVudCAke2N9IGNtLCBkb25jIG9uIGNvbW1lbmNlIHBhciB0cmFjZXIgdW4gc2VnbWVudCwgaWNpIFske25vbVswXSArIG5vbVsxXX1dLCBkZSBjZXR0ZSBsb25ndWV1ci5gLCAwLCAtMilcblxuICAgIHRoaXMucG9pbnRDcmVlcihBLCB7IHRlbXBvOiAwIH0pIC8vIE9uIGNvdXBlIGxhIHBhdXNlIHBvdXIgbmUgcGFzIHZvaXIgbGUgZMOpcGxhY2VtZW50IGR1IHBvaW50XG4gICAgdGhpcy5wb2ludE5vbW1lcihBLCBBLm5vbSwgeyBkeDogLTAuNSwgZHk6IDAgfSkgLy8gT24gZMOpcGxhY2UgbGUgbGFiZWwgZHUgcG9pbnQgQSB2ZXJzIGxhIGdhdWNoZVxuICAgIHRoaXMucmVnbGVTZWdtZW50KEEsIEIpXG4gICAgdGhpcy5wb2ludENyZWVyKEIpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMubG9uZ3VldXJTZWdtZW50KEEsIEIsIC0xKVxuXG4gICAgdGhpcy50ZXh0ZVBvc2l0aW9uKGAyKSBVbiBjYXJyw6kgcG9zc8OoZGUgNCBhbmdsZXMgZHJvaXRzLCBkb25jIG9uIHRyYWNlIGxhIHBlcnBlbmRpY3VsYWlyZSDDoCAoJHtub21bMF0gKyBub21bMV19KSBwYXNzYW50IHBhciAke25vbVswXX0uYCwgMCwgLTIgLSAxICogaW50ZXJsaWduZSlcblxuICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoKVxuICAgIHRoaXMuZXF1ZXJyZURlcGxhY2VyKEEpXG4gICAgdGhpcy5lcXVlcnJlUm90YXRpb24oQilcbiAgICB0aGlzLnRyYWl0KEEsIEUpXG4gICAgdGhpcy5lcXVlcnJlTWFzcXVlcigpXG4gICAgdGhpcy5jb2RhZ2VBbmdsZURyb2l0KEIsIEEsIEQpXG5cbiAgICB0aGlzLnRleHRlUG9zaXRpb24oYDMpIExlcyA0IGPDtHTDqXMgZCd1biBjYXJyw6kgc29udCBkZSBsYSBtw6ptZSBsb25ndWV1ciwgZG9uYyBvbiBwbGFjZSBsZSBwb2ludCAke25vbVszXX0gc3VyIGNldHRlIHBlcnBlbmRpY3VsYWlyZSwgw6AgJHtjfSBjbSBkZSAke25vbVswXX0uYCwgMCwgLTIgLSAyICogaW50ZXJsaWduZSlcblxuICAgIHRoaXMucmVnbGVTZWdtZW50KEEsIEQpXG4gICAgdGhpcy5wb2ludENyZWVyKEQsIHsgdGVtcG86IDAgfSlcbiAgICB0aGlzLnBvaW50Tm9tbWVyKEQsIEQubm9tLCB7IGR4OiAtMC43LCBkeTogMC41IH0pXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShBLCBCKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShBLCBEKVxuXG4gICAgdGhpcy50ZXh0ZVBvc2l0aW9uKGA0KSBEZSBtw6ptZSwgb24gdHJhY2UgbGEgcGVycGVuZGljdWxhaXJlIMOgICgke25vbVswXSArIG5vbVszXX0pIHBhc3NhbnQgcGFyICR7bm9tWzNdfSwgcHVpcyBvbiBwbGFjZSBsZSBwb2ludCAke25vbVsyXX0gc3VyIGNldHRlIHBlcnBlbmRpY3VsYWlyZSwgw6AgJHtjfSBjbSBkZSAke25vbVszXX0uYCwgMCwgLTIgLSAzICogaW50ZXJsaWduZSlcblxuICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoKVxuICAgIHRoaXMuZXF1ZXJyZURlcGxhY2VyKEQpXG4gICAgdGhpcy5lcXVlcnJlUm90YXRpb24oQSlcbiAgICB0aGlzLnRyYWl0KEQsIEYpXG4gICAgdGhpcy5lcXVlcnJlTWFzcXVlcigpXG4gICAgdGhpcy5jb2RhZ2VBbmdsZURyb2l0KEEsIEQsIEMpXG5cbiAgICB0aGlzLnJlZ2xlU2VnbWVudChELCBDKVxuICAgIHRoaXMucG9pbnRDcmVlcihDLCB7IHRlbXBvOiAwIH0pXG4gICAgdGhpcy5wb2ludE5vbW1lcihDLCBDLm5vbSwgeyBkeDogMCwgZHk6IDAuOSB9KVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoRCwgQylcblxuICAgIHRoaXMudGV4dGVQb3NpdGlvbihgNSkgT24gdHJhY2UgbGUgc2VnbWVudCBbJHtub21bMV0gKyBub21bMl19XS5gLCAwLCAtMiAtIDQgKiBpbnRlcmxpZ25lKVxuXG4gICAgdGhpcy5yZWdsZVNlZ21lbnQoQywgQilcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5zZWdtZW50Q29kYWdlKEIsIEMpXG5cbiAgICB0aGlzLnRleHRlUG9zaXRpb24oYDYpIE9uIHbDqXJpZmllIHF1ZSAke25vbVsxXSArIG5vbVsyXX0gPSAke2N9IGNtIGV0IHF1ZSBsZXMgZGV1eCBkZXJuaWVycyBhbmdsZXMgdHJhY8OpcyBzb250IGRyb2l0cy5gLCAwLCAtMiAtIDUgKiBpbnRlcmxpZ25lKVxuXG4gICAgdGhpcy5lcXVlcnJlTW9udHJlcihDLCB7IHRlbXBvOiAwIH0pXG4gICAgdGhpcy5lcXVlcnJlUm90YXRpb24oRClcbiAgICB0aGlzLmVxdWVycmVNYXNxdWVyKClcbiAgICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQoRCwgQywgQilcblxuICAgIHRoaXMuZXF1ZXJyZU1vbnRyZXIoQiwgeyB0ZW1wbzogMCB9KVxuICAgIHRoaXMuZXF1ZXJyZVJvdGF0aW9uKEMpXG4gICAgdGhpcy5lcXVlcnJlTWFzcXVlcigpXG4gICAgdGhpcy5jb2RhZ2VBbmdsZURyb2l0KEMsIEIsIEEpXG4gICAgcmV0dXJuIHBvbHlnb25lQXZlY05vbShBLCBCLCBDLCBEKVxuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiogKioqKioqKioqKiogVHJhbnNmb3JtYXRpb25zICoqKioqKioqKioqKioqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IHAgIGxlIHBvaW50IGRvbnQgb24gdmV1dCBjb25zdHJ1aXJlIGwnaW1hZ2VcbiAgICogQHBhcmFtIHtvYmpldH0gY2VudHJlIGxlIGNlbnRyZSBkZSBsYSByb3RhdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgbCdhbmdsZSBkZSBsYSByb3RhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9tIGxlIG5vbSBkZSBsJ2ltYWdlIChzaSBwYXMgcHLDqWNpc8OpIGNlIHNlcmEgbGUgbm9tIGRlIGwnYW50w6ljw6lkZW50IGF2ZWMgdW4gJylcbiAgICogQHBhcmFtIHtvYmpldH0gcGFyYW00IG9wdGlvbnMgY291bGV1ciBldCBjb3VsZXVyQ29kYWdlXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICovXG4gIHRoaXMucm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIChwLCBjZW50cmUsIGFuZ2xlLCBub20sIHsgY291bGV1ciA9IHRoaXMuY291bGV1ciwgY291bGV1ckNvZGFnZSA9IHRoaXMuY291bGV1ckNvZGFnZSwgY29kYWdlID0gdHJ1ZSB9ID0ge30pIHtcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDAuNSAvLyDDqXBhaXNzZXVyIGV0IGNvdWxldXIgZGUgY3JheW9uIGRlIHBhcGllciBiaWVuIHRhaWxsw6kgcG91ciBsYSBjb25zdHJ1Y3Rpb25cbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBpZiAobm9tID09PSB1bmRlZmluZWQgfHwgbm9tID09PSAnJykge1xuICAgICAgbm9tID0gcC5ub20gKyBcIidcIlxuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IHJvdGF0aW9uKHAsIGNlbnRyZSwgYW5nbGUsIG5vbSkgLy8gb24gZMOpZmluaXQgbGUgcG9pbnQgaW1hZ2UgKHBvdXIgbGUgdmlzZXIgYXZlYyBsYSByw6hnbGUgb24gYWpvdXRlIHVuZSBhcG9zdHJvcGhlIGF1IG5vbSlcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChjZW50cmUsIHApIC8vIE9uIHRyYWNlIGxlIHN1cHBvcnQgZHUgcmFwcG9ydGV1clxuICAgIHRoaXMucmFwcG9ydGV1ck1vbnRyZXIoY2VudHJlKVxuICAgIHRoaXMucmFwcG9ydGV1clRyYWNlckRlbWlEcm9pdGVBbmdsZShjZW50cmUsIHAsIGFuZ2xlKSAvLyBPbiB0cmFjZSBsZSBkZXV4acOobWUgY8O0dMOpXG4gICAgdGhpcy5yZWdsZU1hc3F1ZXIoKVxuICAgIHRoaXMucmFwcG9ydGV1ck1hc3F1ZXIoKVxuICAgIHRoaXMuY29tcGFzRWNhcnRlcjJQb2ludHMoY2VudHJlLCBwKSAvLyBvbiBwcmVuZCBsJ8OpY2FydGVtZW50IGR1IGNvbXBhc1xuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoY2VudHJlLCBpbWFnZSkgLy8gT24gZmFpdCBsJ2FyYyBxdWkgY291cGUgbGEgZGVtaS1kcm9pdGVcbiAgICB0aGlzLmNvbXBhc01hc3F1ZXIoKVxuICAgIHRoaXMucG9pbnRDcmVlcihpbWFnZSwgeyBjb3VsZXVyOiBjb3VsZXVyLCBjb3VsZXVyTGFiZWw6IGNvdWxldXIgfSkgLy8gT24gbWFycXVlIGxlIHBvaW50IGltYWdlIChxdWkgZXN0IG5vbW3DqSlcbiAgICBpZiAoY29kYWdlKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYW5nbGUpID09PSA5MCkge1xuICAgICAgICB0aGlzLmNvZGFnZUFuZ2xlRHJvaXQocCwgY2VudHJlLCBpbWFnZSwgeyBjb3VsZXVyOiBjb3VsZXVyQ29kYWdlIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFuZ2xlQ29kYWdlKHAsIGNlbnRyZSwgaW1hZ2UsIHsgY291bGV1cjogY291bGV1ckNvZGFnZSB9KVxuICAgICAgICB0aGlzLnRleHRlUG9pbnQoTWF0aC5hYnMoYW5nbGUpICsgJ8KwJywgdHJhbnNsYXRpb24oaG9tb3RoZXRpZShyb3RhdGlvbihwLCBjZW50cmUsIGFuZ2xlIC8gMiksIGNlbnRyZSwgMS4zIC8gbG9uZ3VldXIoY2VudHJlLCBwKSksIHZlY3RldXIoLTAuMiwgMC41KSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IHAgcG9pbnQgZG9udCBvbiBjb25zdHJ1aXQgbCdpbWFnZSBldCBxdWkgZG9pdCDDqnRyZSB0cmFjw6kuXG4gICAqIEBwYXJhbSB7b2JqZXR9IGQgYXhlIGRlIHN5bcOpdHJpZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vbSBub20gZGUgbCdpbWFnZVxuICAgKiBAcGFyYW0ge29iamV0fSBvcHRpb25zIGNvdWxldXIgZXQgY291bGV1ckNvZGFnZVxuICAgKiBAYXV0ZXVyIExpb3ViYSBMZXJvdXggZXQgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICovXG4gIHRoaXMuc3ltZXRyaWVBeGlhbGVQb2ludCA9IGZ1bmN0aW9uIChwLCBkLCBub20sIHsgY291bGV1ciA9IHRoaXMuY291bGV1ciwgY291bGV1ckNvZGFnZSA9IHRoaXMuY291bGV1ckNvZGFnZSwgY29kYWdlID0gJy8vJyB9ID0ge30pIHtcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDAuNSAvLyDDqXBhaXNzZXVyIGV0IGNvdWxldXIgZGUgY3JheW9uIGRlIHBhcGllciBiaWVuIHRhaWxsw6kgcG91ciBsYSBjb25zdHJ1Y3Rpb25cbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBpZiAobm9tID09PSB1bmRlZmluZWQgfHwgbm9tID09PSAnJykge1xuICAgICAgbm9tID0gcC5ub20gKyBcIidcIlxuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IHN5bWV0cmllQXhpYWxlKHAsIGQsIG5vbSkgLy8gb24gZMOpZmluaXQgbGUgcG9pbnQgaW1hZ2UgKHBvdXIgbGUgdmlzZXIgYXZlYyBsYSByw6hnbGUgb24gYWpvdXRlIHVuZSBhcG9zdHJvcGhlIGF1IG5vbSlcbiAgICBpZiAobG9uZ3VldXIocCwgaW1hZ2UpICE9PSAwKSB7XG4gICAgICBjb25zdCBNID0gbWlsaWV1KHAsIGltYWdlKSAvLyBvbiBjcsOpZSBsZSBwb2ludCBtaWxpZXVcbiAgICAgIGNvbnN0IE4gPSByb3RhdGlvbihwLCBNLCA5MClcbiAgICAgIGNvbnN0IEQgPSByb3RhdGlvbihOLCBNLCAxODApXG4gICAgICB0aGlzLnJlZ2xlTWFzcXVlckdyYWR1YXRpb25zKClcbiAgICAgIHRoaXMucGVycGVuZGljdWxhaXJlUmVnbGVFcXVlcnJlMnBvaW50czNlcG9pbnQoTiwgRCwgcClcbiAgICAgIHRoaXMuY29tcGFzRWNhcnRlcjJQb2ludHMoTSwgcClcbiAgICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoTSwgaW1hZ2UpXG4gICAgICB0aGlzLnJlZ2xlU2VnbWVudChwLCBpbWFnZSlcbiAgICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICAgIHRoaXMuZXF1ZXJyZU1hc3F1ZXIoKVxuICAgICAgdGhpcy5zZWdtZW50Q29kYWdlKHAsIE0sIHsgY29kYWdlOiBjb2RhZ2UsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgICAgIHRoaXMuc2VnbWVudENvZGFnZShpbWFnZSwgTSwgeyBjb2RhZ2U6IGNvZGFnZSwgY291bGV1cjogY291bGV1ckNvZGFnZSB9KVxuICAgICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICAgIHRoaXMuY29tcGFzTWFzcXVlcigpXG4gICAgfVxuICAgIHRoaXMucG9pbnRDcmVlcihpbWFnZSwgeyBjb3VsZXVyOiBjb3VsZXVyLCBjb3VsZXVyTGFiZWw6IGNvdWxldXIgfSkgLy8gb24gY29uc3RydWl0IGwnaW1hZ2VcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamV0fSBwICBsZSBwb2ludCBkb250IG9uIHZldXQgY29uc3RydWlyZSBsJ2ltYWdlXG4gICAqIEBwYXJhbSB7b2JqZXR9IGxlIHBvaW50IGRlIGTDqXBhcnQgZGUgbGEgdHJhbnNsYXRpb25cbiAgICogQHBhcmFtIHtvYmpldH0gbGUgcG9pbnQgZCdhcnJpdsOpZSBkZSBsYSB0cmFuc2xhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9tIGxlIG5vbSBkZSBsJ2ltYWdlIChzaSBwYXMgcHLDqWNpc8OpIGNlIHNlcmEgbGUgbm9tIGRlIGwnYW50w6ljw6lkZW50IGF2ZWMgdW4gJylcbiAgICogQHBhcmFtIHtvYmpldH0gcGFyYW00IG9wdGlvbnMgY291bGV1ciBldCBjb3VsZXVyQ29kYWdlXG4gICAqIEBBdXRldXIgSmVhbi1DbGF1ZGUgTGhvdGVcbiAgICovXG4gIHRoaXMudHJhbnNsYXRpb25Qb2ludCA9IGZ1bmN0aW9uIChwLCBBLCBCLCBub20sIHsgY291bGV1ciA9ICdibGFjaycsIGNvdWxldXJDb2RhZ2UgPSB0aGlzLmNvdWxldXJDb2RhZ2UgfSA9IHt9KSB7XG4gICAgY29uc3QgdiA9IHZlY3RldXIoQSwgQilcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDAuNSAvLyDDqXBhaXNzZXVyIGV0IGNvdWxldXIgZGUgY3JheW9uIGRlIHBhcGllciBiaWVuIHRhaWxsw6kgcG91ciBsYSBjb25zdHJ1Y3Rpb25cbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBpZiAobm9tID09PSB1bmRlZmluZWQgfHwgbm9tID09PSAnJykge1xuICAgICAgbm9tID0gcC5ub20gKyBcIidcIlxuICAgIH1cbiAgICBjb25zdCBpbWFnZSA9IHRyYW5zbGF0aW9uKHAsIHYsIG5vbSkgLy8gb24gZMOpZmluaXQgbGUgcG9pbnQgaW1hZ2UgKHBvdXIgbGUgdmlzZXIgYXZlYyBsYSByw6hnbGUgb24gYWpvdXRlIHVuZSBhcG9zdHJvcGhlIGF1IG5vbSlcbiAgICBpZiAobG9uZ3VldXIoQSwgcCkgIT09IDApIHsgLy8gc2kgbGUgcG9pbnQgZGUgZMOpcGFydCBBIGVzdCBsJ2FudMOpY8OpZGVudCwgYWxvcnMgbGUgcG9pbnQgZCdhcnJpdsOpZSBCIGVzdCBsJ2ltYWdlLi4uIHBhcyBiZXNvaW4gZGUgY29uc3RydWN0aW9uXG4gICAgICB0aGlzLmNvbXBhc0VjYXJ0ZXIyUG9pbnRzKEEsIHApXG4gICAgICB0aGlzLmNvbXBhc1RyYWNlckFyY0NlbnRyZVBvaW50KEIsIGltYWdlKVxuICAgICAgdGhpcy5jb21wYXNFY2FydGVyMlBvaW50cyhBLCBCKVxuICAgICAgdGhpcy5jb21wYXNUcmFjZXJBcmNDZW50cmVQb2ludChwLCBpbWFnZSlcbiAgICB9XG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLnBvaW50Q3JlZXIoaW1hZ2UsIHsgY291bGV1cjogY291bGV1ciwgY291bGV1ckxhYmVsOiBjb3VsZXVyIH0pXG4gICAgY29uc3QgY2hvaXgxID0gcmFuZGludCgwLCA0KVxuICAgIGNvbnN0IGNob2l4MiA9IHJhbmRpbnQoMCwgNCwgY2hvaXgxKVxuICAgIGNvbnN0IG1hcnF1ZXMgPSBbJy8nLCAnLy8nLCAnLy8vJywgJ08nLCAnXFxcXFxcXFwnXVxuICAgIGNvbnN0IG1hcnF1ZTEgPSBtYXJxdWVzW2Nob2l4MV1cbiAgICBjb25zdCBtYXJxdWUyID0gbWFycXVlc1tjaG9peDJdXG4gICAgdGhpcy5jb3VsZXVyID0gJ2dyZWVuJ1xuICAgIHRoaXMudHJhaXRSYXBpZGUocCwgaW1hZ2UpXG4gICAgdGhpcy50cmFpdFJhcGlkZShBLCBCKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShwLCBpbWFnZSwgeyBjb2RhZ2U6IG1hcnF1ZTEsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoQSwgQiwgeyBjb2RhZ2U6IG1hcnF1ZTEsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgICB0aGlzLmNvdWxldXIgPSAncmVkJ1xuICAgIHRoaXMudHJhaXRSYXBpZGUoQiwgaW1hZ2UpXG4gICAgdGhpcy50cmFpdFJhcGlkZShBLCBwKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShCLCBpbWFnZSwgeyBjb2RhZ2U6IG1hcnF1ZTIsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoQSwgcCwgeyBjb2RhZ2U6IG1hcnF1ZTIsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamV0fSBwICBsZSBwb2ludCBkb250IG9uIHZldXQgY29uc3RydWlyZSBsJ2ltYWdlXG4gICAqIEBwYXJhbSB7b2JqZXR9IGNlbnRyZSBsZSBjZW50cmUgZGUgc3ltw6l0cmllXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub20gbGUgbm9tIGRlIGwnaW1hZ2UgKHNpIHBhcyBwcsOpY2lzw6kgY2Ugc2VyYSBsZSBub20gZGUgbCdhbnTDqWPDqWRlbnQgYXZlYyB1biAnKVxuICAgKiBAcGFyYW0ge29iamV0fSBwYXJhbTMgb3B0aW9ucyBjb3VsZXVyLCBjb3VsZXVyQ29kYWdlIGV0IGNvZGFnZVxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqL1xuICB0aGlzLmRlbWlUb3VyUG9pbnQgPSBmdW5jdGlvbiAocCwgY2VudHJlLCBub20sIHsgY291bGV1ciA9ICdibGFjaycsIGNvdWxldXJDb2RhZ2UgPSB0aGlzLmNvdWxldXJDb2RhZ2UsIGNvZGFnZSA9ICcvLycgfSA9IHt9KSB7XG4gICAgdGhpcy5lcGFpc3NldXIgPSAwLjUgLy8gw6lwYWlzc2V1ciBldCBjb3VsZXVyIGRlIGNyYXlvbiBkZSBwYXBpZXIgYmllbiB0YWlsbMOpIHBvdXIgbGEgY29uc3RydWN0aW9uXG4gICAgdGhpcy5jb3VsZXVyID0gJ2dyZXknXG4gICAgaWYgKG5vbSA9PT0gdW5kZWZpbmVkIHx8IG5vbSA9PT0gJycpIHtcbiAgICAgIG5vbSA9IHAubm9tICsgXCInXCJcbiAgICB9XG4gICAgY29uc3QgaW1hZ2UgPSByb3RhdGlvbihwLCBjZW50cmUsIDE4MCwgbm9tKSAvLyBvbiBkw6lmaW5pdCBsZSBwb2ludCBpbWFnZSAocG91ciBsZSB2aXNlciBhdmVjIGxhIHLDqGdsZSBvbiBham91dGUgdW5lIGFwb3N0cm9waGUgYXUgbm9tKVxuICAgIHRoaXMuY29tcGFzRWNhcnRlcjJQb2ludHMoY2VudHJlLCBwKVxuICAgIHRoaXMuY29tcGFzVHJhY2VyQXJjQ2VudHJlUG9pbnQoY2VudHJlLCBpbWFnZSlcbiAgICB0aGlzLmNvbXBhc01hc3F1ZXIoKVxuICAgIHRoaXMuY3JheW9uRGVwbGFjZXIocClcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChwLCBpbWFnZSlcbiAgICB0aGlzLmNvdWxldXIgPSBjb3VsZXVyXG4gICAgdGhpcy5lcGFpc3NldXIgPSAyXG4gICAgdGhpcy5wb2ludENyZWVyKGltYWdlLCB7IGNvdWxldXI6IGNvdWxldXIsIGNvdWxldXJMYWJlbDogY291bGV1ciB9KSAvLyBvbiBjb25zdHJ1aXQgbCdpbWFnZVxuICAgIHRoaXMucmVnbGVNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIHRoaXMuc2VnbWVudENvZGFnZShwLCBjZW50cmUsIHsgY29kYWdlOiBjb2RhZ2UsIGNvdWxldXI6IGNvdWxldXJDb2RhZ2UgfSlcbiAgICB0aGlzLnNlZ21lbnRDb2RhZ2UoY2VudHJlLCBpbWFnZSwgeyBjb2RhZ2U6IGNvZGFnZSwgY291bGV1cjogY291bGV1ckNvZGFnZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IHAgcG9seWdvbmUgZG9udCBvbiBkb2l0IGNvbnN0cnVpcmUgbCdpbWFnZVxuICAgKiBAcGFyYW0ge29iamV0fSBjZW50cmUgZGUgbCdob21vdGjDqXRpZVxuICAgKiBAcGFyYW0ge251bWJlcn0gayByYXBwb3J0IGRlIGwnaG9tb3Row6l0aWVcbiAgICogQHBhcmFtIHthcnJheX0gbm9tcyB0YWJsZWF1IGNvbnRlbmFudCBsZXMgZGlmZsOpcmVudHMgbm9tcyBkZXMgc29tbWV0cyBkYW5zIGxlIG3Dqm1lIG9yZHJlIHF1ZSBjZXV4IGRlIHAuIFNpIHZpZGUsIGFsb3JzIG9uIGFqb3V0ZSAnIMOgIGNldXggZGUgcFxuICAgKiBAcGFyYW0ge29iamV0fSBwYXJhbTQgb3B0aW9ucyAoY291bGV1cilcbiAgICovXG4gIHRoaXMuaG9tb3RoZXRpZVBvaW50ID0gZnVuY3Rpb24gKHAsIGNlbnRyZSwgaywgbm9tLCB7IGNvdWxldXIgPSB0aGlzLmNvdWxldXIsIHBvc2l0aW9uVGV4dGUgPSB7IHg6IDAsIHk6IDAgfSB9ID0ge30pIHtcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDEgLy8gw6lwYWlzc2V1ciBldCBjb3VsZXVyIGRlIGNyYXlvbiBkZSBwYXBpZXIgYmllbiB0YWlsbMOpIHBvdXIgbGEgY29uc3RydWN0aW9uXG4gICAgY29uc3QgY291bGV1clNhdmUgPSB0aGlzLmNvdWxldXJcbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBsZXQgdFxuICAgIGlmIChub20gPT09IHVuZGVmaW5lZCB8fCBub20gPT09ICcnKSB7XG4gICAgICBub20gPSBwLm5vbSArIFwiJ1wiXG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gaG9tb3RoZXRpZShwLCBjZW50cmUsIGssIG5vbSkgLy8gb24gZMOpZmluaXQgbGUgcG9pbnQgaW1hZ2UgKHBvdXIgbGUgdmlzZXIgYXZlYyBsYSByw6hnbGUgb24gYWpvdXRlIHVuZSBhcG9zdHJvcGhlIGF1IG5vbSlcbiAgICBpZiAoayA+IDApIHtcbiAgICAgIHQgPSB0aGlzLnRleHRlUG9zaXRpb24oYENvbW1lIGxlIHJhcHBvcnQgZXN0IHBvc2l0aWYgYWxvcnMgbGVzIHBvaW50cyAke3Aubm9tfSBldCAke2ltYWdlLm5vbX0gc29udCBkdSBtw6ptZSBjw7R0w6kgZGUgJHtjZW50cmUubm9tfWAsIHBvc2l0aW9uVGV4dGUueCwgcG9zaXRpb25UZXh0ZS55LCB7IHRhaWxsZTogMTUgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9IHRoaXMudGV4dGVQb3NpdGlvbihgQ29tbWUgbGUgcmFwcG9ydCBlc3QgbsOpZ2F0aWYgYWxvcnMgJHtjZW50cmUubm9tfSBlc3QgZW50cmUgbGVzIHBvaW50cyAke3Aubm9tfSBldCAke2ltYWdlLm5vbX1gLCBwb3NpdGlvblRleHRlLngsIHBvc2l0aW9uVGV4dGUueSwgeyB0YWlsbGU6IDE1IH0pXG4gICAgfVxuICAgIHRoaXMucmVnbGVTZWdtZW50KHAsIGNlbnRyZSlcbiAgICBjb25zdCBsID0gYXJyb25kaShsb25ndWV1cihwLCBjZW50cmUpLCAxKVxuICAgIGNvbnN0IGxwcmltZSA9IGFycm9uZGkoY2FsY3VsKGwgKiBNYXRoLmFicyhrKSkpXG4gICAgY29uc3QgdDEgPSB0aGlzLnRleHRlUG9zaXRpb24oYExhIG1lc3VyZSBkZSAke2NlbnRyZS5ub219JHtwLm5vbX0gZXN0ICR7dGV4Tm9tYnJlKGFycm9uZGkobCwgMSkpfSBjbSBldCBsZSByYXBwb3J0IGRlIGwnaG9tb3RoZXRpZSBlc3QgJHt0ZXhOb21icmUoayl9YCwgcG9zaXRpb25UZXh0ZS54LCBwb3NpdGlvblRleHRlLnkgLSAxLCB7IHRhaWxsZTogMTUgfSlcbiAgICBjb25zdCB0MiA9IHRoaXMudGV4dGVQb3NpdGlvbihgZG9uYyAke2NlbnRyZS5ub219JHtpbWFnZS5ub219IG1lc3VyZSAke3RleE5vbWJyZShsKX0gY20gw5cgJHt0ZXhOb21icmUoTWF0aC5hYnMoaykpfSA9ICR7dGV4Tm9tYnJlKGxwcmltZSl9IGNtYCwgcG9zaXRpb25UZXh0ZS54LCBwb3NpdGlvblRleHRlLnkgLSAyLCB7IHRhaWxsZTogMTUgfSlcbiAgICB0aGlzLnJlZ2xlU2VnbWVudChjZW50cmUsIGltYWdlKVxuICAgIHRoaXMucG9pbnRDcmVlcihpbWFnZSwgeyBjb3VsZXVyOiBjb3VsZXVyLCBjb3VsZXVyTGFiZWw6IGNvdWxldXIgfSkgLy8gb24gY29uc3RydWl0IGwnaW1hZ2VcbiAgICB0aGlzLnJlZ2xlTWFzcXVlcigpXG4gICAgdGhpcy5jcmF5b25NYXNxdWVyKClcbiAgICB0aGlzLnBhdXNlKClcbiAgICB0aGlzLnRleHRlTWFzcXVlcih0MSlcbiAgICB0aGlzLnRleHRlTWFzcXVlcih0MilcbiAgICB0aGlzLnRleHRlTWFzcXVlcih0KVxuICAgIHRoaXMuY291bGV1ciA9IGNvdWxldXJTYXZlXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZXR9IHAgbGUgcG9seWdvbmUgcXVpIGVzdCBkw6lqw6AgdHJhY8OpXG4gICAqIEBwYXJhbSB7b2JqZXR9IGNlbnRyZSBsZSBjZW50cmUgZGUgbGEgcm90YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIGwnYW5nbGUgZGUgcm90YXRpb25cbiAgICogQEF1dGV1ciBKZWFuLUNsYXVkZSBMaG90ZVxuICAgKiBAcGFyYW0ge29iamV0fSBwYXJhbTQgb3B0aW9ucyBjb3VsZXVyIGV0IGNvdWxldXJDb2RhZ2VcbiAgKi9cbiAgdGhpcy5yb3RhdGlvblBvbHlnb25lID0gZnVuY3Rpb24gKHAsIGNlbnRyZSwgYW5nbGUsIG5vbXMgPSBbXSwgeyBjb3VsZXVyID0gdGhpcy5jb3VsZXVyLCBjb3VsZXVyQ29kYWdlID0gdGhpcy5jb3VsZXVyQ29kYWdlIH0gPSB7fSkge1xuICAgIGxldCBub21cbiAgICBjb25zdCBwMiA9IHJvdGF0aW9uKHAsIGNlbnRyZSwgYW5nbGUpIC8vIFBvdXIgdHJhY2VyIGxhIGZpZ3VyZSBpbWFnZSDDoCBsYSBmaW4gZGUgbCdhbmltYXRpb24gYXZlYyBwb2x5Z29uZVJhcGlkZVxuICAgIHRoaXMuZXBhaXNzZXVyID0gMC41IC8vIMOpcGFpc3NldXIgZXQgY291bGV1ciBkZSBjcmF5b24gZGUgcGFwaWVyIGJpZW4gdGFpbGzDqSBwb3VyIGxhIGNvbnN0cnVjdGlvblxuICAgIHRoaXMuY291bGV1ciA9ICdncmV5J1xuICAgIGxldCBpID0gMDsgbGV0IGNvZGFnZVxuICAgIGZvciAoY29uc3Qgc29tbWV0IG9mIHAubGlzdGVQb2ludHMpIHsgLy8gT24gcsOpcMOodGUgbGEgY29uc3RydWN0aW9uIHBvdXIgY2hhcXVlIHNvbW1ldCBkdSBwb2x5Z29uZVxuICAgICAgaWYgKG5vbXNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub20gPSBub21zW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub20gPSBzb21tZXQubm9tICsgXCInXCJcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgMSkge1xuICAgICAgICBjb2RhZ2UgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RhZ2UgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKGxvbmd1ZXVyKGNlbnRyZSwgc29tbWV0KSAhPT0gMCkge1xuICAgICAgICB0aGlzLnJvdGF0aW9uUG9pbnQoc29tbWV0LCBjZW50cmUsIGFuZ2xlLCBub20sIHsgY291bGV1cjogY291bGV1ciwgY291bGV1ckNvZGFnZTogY291bGV1ckNvZGFnZSwgY29kYWdlOiBjb2RhZ2UgfSlcbiAgICAgIH1cbiAgICAgIGkrK1xuICAgIH1cbiAgICB0aGlzLmVwYWlzc2V1ciA9IDJcbiAgICB0aGlzLmNvdWxldXIgPSBjb3VsZXVyXG4gICAgdGhpcy5wb2x5Z29uZVJhcGlkZSguLi5wMi5saXN0ZVBvaW50cykgLy8gb24gdHJhY2UgbGUgcG9seWdvbmUgaW1hZ2UgZW4gYmxldSDDqXBhaXNzZXVyIDJcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamV0fSBwIHBvbHlnb25lIGRvbnQgb24gY29uc3RydWl0IGwnaW1hZ2UgZXQgcXVpIGRvaXQgw6p0cmUgdHJhY8OpIGF2ZWMgc2VzIHBvaW50cyBub21tw6lzLlxuICAgKiBAcGFyYW0ge29iamV0fSBkIGF4ZSBkZSBzeW3DqXRyaWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub21zIHRhYmxlYXUgY29udGVuYW50IGxlcyBub21zIGRlcyBzb21tZXRzIGRhbnMgbGUgbcOqbWUgb3JkcmUgcXVlIHBcbiAgICogQHBhcmFtIHtvYmpldH0gcGFyYW0zIG9wdGlvbnMgY291bGV1ciBldCBjb3VsZXVyQ29kYWdlXG4gICAqIEBhdXRldXIgTGlvdWJhIExlcm91eCBldCBKZWFuLUNsYXVkZSBMaG90ZVxuICAgKi9cbiAgdGhpcy5zeW1ldHJpZUF4aWFsZVBvbHlnb25lID0gZnVuY3Rpb24gKHAsIGQsIG5vbXMgPSBbXSwgeyBjb3VsZXVyID0gdGhpcy5jb3VsZXVyLCBjb3VsZXVyQ29kYWdlID0gdGhpcy5jb3VsZXVyQ29kYWdlIH0gPSB7fSkge1xuICAgIGxldCBub21cbiAgICBjb25zdCBwMiA9IHN5bWV0cmllQXhpYWxlKHAsIGQpIC8vIFBvdXIgdHJhY2VyIGxhIGZpZ3VyZSBpbWFnZSDDoCBsYSBmaW4gZGUgbCdhbmltYXRpb24gYXZlYyBwb2x5Z29uZVJhcGlkZVxuICAgIC8vIGNvbnN0IE4gPSBob21vdGhldGllKG1pbGlldShwLmxpc3RlUG9pbnRzWzBdLCBwMi5saXN0ZVBvaW50c1swXSksIG1pbGlldShwLmxpc3RlUG9pbnRzWzFdLCBwMi5saXN0ZVBvaW50c1sxXSksIDEuMjM0NTYpIC8vIGNyw6llciB1bmggcG9pbnQgZGUgbCdheGUgZGUgc3ltw6l0cmllIHBvdXIgbGVzIGFsaWduZW1lbnRzIGV0IGxlcyBtZXN1cmUgZCdhbmdsZXNcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDAuNSAvLyDDqXBhaXNzZXVyIGV0IGNvdWxldXIgZGUgY3JheW9uIGRlIHBhcGllciBiaWVuIHRhaWxsw6kgcG91ciBsYSBjb25zdHJ1Y3Rpb25cbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBtYXJxdWVzID0gWycvJywgJy8vJywgJy8vLycsICdPJywgJ1xcXFxcXFxcJ11cbiAgICBmb3IgKGNvbnN0IHNvbW1ldCBvZiBwLmxpc3RlUG9pbnRzKSB7IC8vIE9uIHLDqXDDqHRlIGxhIGNvbnN0cnVjdGlvbiBwb3VyIGNoYXF1ZSBzb21tZXQgZHUgcG9seWdvbmVcbiAgICAgIGlmIChub21zW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9tID0gbm9tc1tpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9tID0gc29tbWV0Lm5vbSArIFwiJ1wiXG4gICAgICB9XG4gICAgICB0aGlzLnN5bWV0cmllQXhpYWxlUG9pbnQoc29tbWV0LCBkLCBub20sIHsgY291bGV1cjogY291bGV1ciwgY291bGV1ckNvZGFnZTogY291bGV1ckNvZGFnZSwgY29kYWdlOiBtYXJxdWVzW2ldIH0pXG4gICAgICBpKytcbiAgICB9XG4gICAgdGhpcy5jb21wYXNNYXNxdWVyKClcbiAgICB0aGlzLmNyYXlvbk1hc3F1ZXIoKVxuICAgIHRoaXMuZXBhaXNzZXVyID0gMlxuICAgIHRoaXMuY291bGV1ciA9IGNvdWxldXJcbiAgICB0aGlzLnBvbHlnb25lUmFwaWRlKC4uLnAyLmxpc3RlUG9pbnRzKSAvLyBvbiB0cmFjZSBsZSBwb2x5Z29uZSBpbWFnZSBlbiBibGV1IMOpcGFpc3NldXIgMlxuICAgIHRoaXMucG9seWdvbmVSYXBpZGUocDIpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmpldH0gcCBwb2x5Z29uZSBkb250IG9uIGNvbnN0cnVpdCBsJ2ltYWdlXG4gICAqIEBwYXJhbSB7b2JqZXR9IEEgcG9pbnQgZGUgZMOpcGFydCBkZSBsYSB0cmFuc2xhdGlvblxuICAgKiBAcGFyYW0ge29iamV0fSBCIHBvaW50IGQnYXJyaXbDqWUgZGUgbGEgdHJhbnNsYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vbXMgdGFibGVhdSBjb250ZW5hbnQgbGVzIG5vbXMgZGVzIHNvbW1ldHMgZGFucyBsZSBtw6ptZSBvcmRyZSBxdWUgcFxuICogQHBhcmFtIHtvYmpldH0gcGFyYW0zIG9wdGlvbnMgY291bGV1ciBldCBjb3VsZXVyQ29kYWdlXG4gKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4qL1xuICB0aGlzLnRyYW5zbGF0aW9uUG9seWdvbmUgPSBmdW5jdGlvbiAocCwgQSwgQiwgbm9tcyA9IFtdLCB7IGNvdWxldXIgPSB0aGlzLmNvdWxldXIsIGNvdWxldXJDb2RhZ2UgPSB0aGlzLmNvdWxldXJDb2RhZ2UsIGNvZGFnZSA9ICdPJyB9ID0ge30pIHtcbiAgICBsZXQgbm9tXG4gICAgY29uc3QgdiA9IHZlY3RldXIoQSwgQilcbiAgICBjb25zdCBwMiA9IHRyYW5zbGF0aW9uKHAsIHYpIC8vIFBvdXIgdHJhY2VyIGxhIGZpZ3VyZSBpbWFnZSDDoCBsYSBmaW4gZGUgbCdhbmltYXRpb24gYXZlYyBwb2x5Z29uZVJhcGlkZVxuICAgIHRoaXMuZXBhaXNzZXVyID0gMC41IC8vIMOpcGFpc3NldXIgZXQgY291bGV1ciBkZSBjcmF5b24gZGUgcGFwaWVyIGJpZW4gdGFpbGzDqSBwb3VyIGxhIGNvbnN0cnVjdGlvblxuICAgIHRoaXMuY291bGV1ciA9ICdncmV5J1xuICAgIGxldCBpID0gMFxuICAgIGZvciAoY29uc3Qgc29tbWV0IG9mIHAubGlzdGVQb2ludHMpIHsgLy8gT24gcsOpcMOodGUgbGEgY29uc3RydWN0aW9uIHBvdXIgY2hhcXVlIHNvbW1ldCBkdSBwb2x5Z29uZVxuICAgICAgaWYgKG5vbXNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub20gPSBub21zW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub20gPSBzb21tZXQubm9tICsgXCInXCJcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNsYXRpb25Qb2ludChzb21tZXQsIEEsIEIsIG5vbSwgeyBjb3VsZXVyOiBjb3VsZXVyLCBjb3VsZXVyQ29kYWdlOiBjb3VsZXVyQ29kYWdlLCBjb2RhZ2U6IGNvZGFnZSB9KVxuICAgIH1cbiAgICB0aGlzLmVwYWlzc2V1ciA9IDJcbiAgICB0aGlzLmNvdWxldXIgPSBjb3VsZXVyXG4gICAgdGhpcy5wb2x5Z29uZVJhcGlkZSguLi5wMi5saXN0ZVBvaW50cykgLy8gb24gdHJhY2UgbGUgcG9seWdvbmUgaW1hZ2UgZW4gYmxldSDDqXBhaXNzZXVyIDJcbiAgICB0aGlzLnBvbHlnb25lUmFwaWRlKHAyKVxuICAgIGkrK1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamV0fSBwICBsZSBwb2x5Z29uZSBkb250IG9uIHZldXQgY29uc3RydWlyZSBsJ2ltYWdlIHF1aSBkb2l0IMOqdHJlIHRyYWPDqVxuICAgKiBAcGFyYW0ge29iamV0fSBjZW50cmUgbGUgY2VudHJlIGRlIHN5bcOpdHJpZVxuICAgKiBAcGFyYW0ge2FycmF5fSBub21zIGxlcyBub21zIGRlcyBzb21tZXRzIGltYWdlcyAoc2kgcGFzIHByw6ljaXPDqSBjZSBzZXJhIGxlIG5vbSBkZSBsJ2FudMOpY8OpZGVudCBhdmVjIHVuICcpXG4gICAqIEBwYXJhbSB7b2JqZXR9IHBhcmFtMyBvcHRpb25zIGNvdWxldXIgZXQgY291bGV1ckNvZGFnZVxuICAgKiBAQXV0ZXVyIEplYW4tQ2xhdWRlIExob3RlXG4gICAqL1xuICB0aGlzLmRlbWlUb3VyUG9seWdvbmUgPSBmdW5jdGlvbiAocCwgY2VudHJlLCBub21zID0gW10sIHsgY291bGV1ciA9IHRoaXMuY291bGV1ciwgY291bGV1ckNvZGFnZSA9IHRoaXMuY291bGV1ckNvZGFnZSB9ID0ge30pIHtcbiAgICBjb25zdCBwMiA9IHJvdGF0aW9uKHAsIGNlbnRyZSwgMTgwKSAvLyBQb3VyIHRyYWNlciBsYSBmaWd1cmUgaW1hZ2Ugw6AgbGEgZmluIGRlIGwnYW5pbWF0aW9uIGF2ZWMgcG9seWdvbmVSYXBpZGVcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDAuNSAvLyDDqXBhaXNzZXVyIGV0IGNvdWxldXIgZGUgY3JheW9uIGRlIHBhcGllciBiaWVuIHRhaWxsw6kgcG91ciBsYSBjb25zdHJ1Y3Rpb25cbiAgICB0aGlzLmNvdWxldXIgPSAnZ3JleSdcbiAgICBsZXQgbm9tXG4gICAgbGV0IGkgPSAwXG4gICAgY29uc3QgbWFycXVlcyA9IFsnLycsICcvLycsICcvLy8nLCAnTycsICdcXFxcXFxcXCddXG4gICAgZm9yIChjb25zdCBzb21tZXQgb2YgcC5saXN0ZVBvaW50cykgeyAvLyBPbiByw6lww6h0ZSBsYSBjb25zdHJ1Y3Rpb24gcG91ciBjaGFxdWUgc29tbWV0IGR1IHBvbHlnb25lXG4gICAgICBpZiAobm9tc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vbSA9IG5vbXNbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vbSA9IHNvbW1ldC5ub20gKyBcIidcIlxuICAgICAgfVxuICAgICAgdGhpcy5kZW1pVG91clBvaW50KHNvbW1ldCwgY2VudHJlLCBub20sIHsgY291bGV1cjogY291bGV1ciwgY291bGV1ckNvZGFnZTogY291bGV1ckNvZGFnZSwgY29kYWdlOiBtYXJxdWVzW2ldIH0pXG4gICAgICBpKytcbiAgICB9XG4gICAgdGhpcy5lcGFpc3NldXIgPSAyXG4gICAgdGhpcy5jb3VsZXVyID0gY291bGV1clxuICAgIHRoaXMucG9seWdvbmVSYXBpZGUoLi4ucDIubGlzdGVQb2ludHMpIC8vIG9uIHRyYWNlIGxlIHBvbHlnb25lIGltYWdlIGVuIGJsZXUgw6lwYWlzc2V1ciAyXG4gICAgdGhpcy5wb2x5Z29uZVJhcGlkZShwMikvLyBmaWd1cmUgc3ZnIGRlIGwnZXhlcmNpY2VcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamV0fSBwIHBvbHlnb25lIGRvbnQgb24gZG9pdCBjb25zdHJ1aXJlIGwnaW1hZ2VcbiAgICogQHBhcmFtIHtvYmpldH0gY2VudHJlIGRlIGwnaG9tb3Row6l0aWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgcmFwcG9ydCBkZSBsJ2hvbW90aMOpdGllXG4gICAqIEBwYXJhbSB7YXJyYXl9IG5vbXMgdGFibGVhdSBjb250ZW5hbnQgbGVzIGRpZmbDqXJlbnRzIG5vbXMgZGVzIHNvbW1ldHMgZGFucyBsZSBtw6ptZSBvcmRyZSBxdWUgY2V1eCBkZSBwLiBTaSB2aWRlLCBhbG9ycyBvbiBham91dGUgJyDDoCBjZXV4IGRlIHBcbiAgICogQHBhcmFtIHtvYmpldH0gcGFyYW00IG9wdGlvbnMgKGNvdWxldXIpXG4gICAqL1xuICB0aGlzLmhvbW90aGV0aWVQb2x5Z29uZSA9IGZ1bmN0aW9uIChwLCBjZW50cmUsIGssIG5vbXMgPSBbXSwgeyBjb3VsZXVyID0gdGhpcy5jb3VsZXVyIH0gPSB7fSkge1xuICAgIGxldCBub21cbiAgICBjb25zdCBwMiA9IGhvbW90aGV0aWUocCwgY2VudHJlLCBrKSAvLyBQb3VyIHRyYWNlciBsYSBmaWd1cmUgaW1hZ2Ugw6AgbGEgZmluIGRlIGwnYW5pbWF0aW9uIGF2ZWMgcG9seWdvbmVSYXBpZGVcbiAgICB0aGlzLmVwYWlzc2V1ciA9IDEgLy8gw6lwYWlzc2V1ciBldCBjb3VsZXVyIGRlIGNyYXlvbiBkZSBwYXBpZXIgYmllbiB0YWlsbMOpIHBvdXIgbGEgY29uc3RydWN0aW9uXG4gICAgdGhpcy5jb3VsZXVyID0gJ2dyZXknXG4gICAgY29uc3QgdCA9IHRoaXMudGV4dGVQb3NpdGlvbignQ29tbWUgayBlc3QgJyArIChrID49IDAgPyAncG9zaXRpZicgOiAnbsOpZ2F0aWYnKSArICcgYWxvcnMgJyArIChrID49IDAgPyAnbGVzIGZpZ3VyZXMgc29udCBkdSBtw6ptZSBjw7R0w6kgZGUgJyArIGNlbnRyZS5ub20gOiBjZW50cmUubm9tICsgJyBlc3QgZW50cmUgbGVzIGZpZ3VyZXMnKSwgMCwgMCwgeyB0YWlsbGU6IDE1IH0pXG4gICAgbGV0IGkgPSAwXG4gICAgZm9yIChjb25zdCBzb21tZXQgb2YgcC5saXN0ZVBvaW50cykgeyAvLyBPbiByw6lww6h0ZSBsYSBjb25zdHJ1Y3Rpb24gcG91ciBjaGFxdWUgc29tbWV0IGR1IHBvbHlnb25lXG4gICAgICBpZiAobm9tc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vbSA9IG5vbXNbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vbSA9IHNvbW1ldC5ub20gKyBcIidcIlxuICAgICAgfVxuICAgICAgdGhpcy5ob21vdGhldGllUG9pbnQoc29tbWV0LCBjZW50cmUsIGssIG5vbSwgeyBjb3VsZXVyOiBjb3VsZXVyIH0pXG4gICAgICBpKytcbiAgICB9XG4gICAgdGhpcy5lcGFpc3NldXIgPSAyXG4gICAgdGhpcy5jb3VsZXVyID0gY291bGV1clxuICAgIHRoaXMucG9seWdvbmVSYXBpZGUoLi4ucDIubGlzdGVQb2ludHMpIC8vIG9uIHRyYWNlIGxlIHBvbHlnb25lIGltYWdlIGVuIGJsZXUgw6lwYWlzc2V1ciAyXG4gICAgdGhpcy50ZXh0ZU1hc3F1ZXIodClcbiAgfVxuICAvKiogKioqKiBGaW4gZGUgbGEgY2xhc3NlIEFsZWEyaWVwICovXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/modules/Alea2iep.js\n");

/***/ })

}]);