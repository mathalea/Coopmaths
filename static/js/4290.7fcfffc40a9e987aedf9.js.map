{"version":3,"sources":["webpack://mathalea/./src/js/exercices/4e/4C10-6.js","webpack://mathalea/./src/js/exercices/ClasseExercice.js"],"names":["titre","Exercice_tableau_multiplications_relatifs","Exercice","this","sup","consigne","correctionDetailleeDisponible","correctionDetaillee","spacing","nbQuestions","nbQuestionsModifiable","nouvelleVersion","type_de_questions_disponibles","parseInt","listeQuestions","listeCorrections","listeTypeDeQuestions","combinaisonListes","texte","texteCorr","i","cpt","nbMax","num","Relatif","randint","lettre_tab","lettre","length","nom_expression","lettreDepuisChiffre","signe_expression","nb_termes","place_lettre","liste_nombres","relatifs","slice","liste_termes","indice","push","ecritureNombreRelatif","splice","signe_lettre","calcul_nombres","calcul","texteEnCouleurEtGras","k","setRegleSigneProduit","getSigneProduitString","getSigneProduitNumber","nb_num","denom","setRegleSigneQuotient","nb_lettres","exp_lettre","indexOf","listeQuestionsToContenu","besoinFormulaireNumerique","consigneCorrection","introduction","contenu","contenuCorrection","nbCols","nbColsCorr","spacingCorr","beamer","besoinFormulaireTexte","besoinFormulaireCaseACocher","consigneModifiable","nbColsModifiable","nbColsCorrModifiable","spacingModifiable","spacingCorrModifiable","video","boutonAide","tailleDiaporama","pasDeVersionLatex","qcm","qcmDisponible","modeQcm","autoCorrection","tableauSolutionsDuQcm","mg32Editable","numeroExercice","listePackages"],"mappings":"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","file":"js/4290.7fcfffc40a9e987aedf9.js","sourcesContent":["import Exercice from '../ClasseExercice.js'\nimport {\n  listeQuestionsToContenu, randint, combinaisonListes,\n  Relatif, lettreDepuisChiffre, ecritureNombreRelatif,\n  texteEnCouleurEtGras\n} from '../../modules/outils.js'\nexport const titre = 'Multiplications et quotients de relatifs : signe avec une lettre'\n\n/**\n* Effectuer des multiplications de relatifs dans un tableau à double entrée\n*\n* @Auteur Cédric GROLLEAU\n* 4C10-6\n*/\nexport default function Exercice_tableau_multiplications_relatifs () {\n  Exercice.call(this) // Héritage de la classe Exercice()\n  this.sup = 3\n  this.titre = titre\n  this.consigne = ''\n  this.correctionDetailleeDisponible = true\n  this.correctionDetaillee = false\n  this.spacing = 2\n  this.nbQuestions = 3\n  this.nbQuestionsModifiable = true\n\n  this.nouvelleVersion = function () {\n    this.sup = parseInt(this.sup)\n    this.listeQuestions = [] // Liste de questions\n    this.listeCorrections = [] // Liste de questions corrigées\n    let type_de_questions_disponibles\n    switch (this.sup) {\n      case 1: // multiplications\n        type_de_questions_disponibles = [1]\n        break\n      case 2: // Quotient\n        type_de_questions_disponibles = [2]\n        break\n      case 3: // multiplications et quotients\n        type_de_questions_disponibles = [1, 2]\n        break\n      case 4: // avec puissances\n        type_de_questions_disponibles = [3, 4]\n        break\n      case 5: // mélange\n        type_de_questions_disponibles = [1, 2, 3, 4]\n        break\n    }\n    const listeTypeDeQuestions = combinaisonListes(type_de_questions_disponibles, this.nbQuestions)\n    for (let i = 0, texte, texteCorr, cpt = 0; i < this.nbQuestions && cpt < 50;) {\n      // on ne choisit que des nombres compris entre 1 et 20\n      const nbMax = 20\n      // Le tableau des relatifs necessaires, il m'en faut max 5 !\n      const num = new Relatif(\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax),\n        randint(-1, 1, [0]) * randint(1, nbMax)\n      )\n      const lettre_tab = ['n', 'x', 'y', 'a', 'm']\n      const lettre = lettre_tab[randint(0, lettre_tab.length - 1)]\n      const nom_expression = lettreDepuisChiffre(i + 1)\n      const signe_expression = randint(-1, 1, [0])\n      const nb_termes = listeTypeDeQuestions[i] == 1 ? randint(3, 5) : randint(4, 6)\n      let place_lettre = randint(0, nb_termes - 1)\n      const liste_nombres = num.relatifs.slice(0, nb_termes - 1)\n      const liste_termes = []\n      for (let indice = 0; indice < liste_nombres.length; indice++) {\n        liste_termes.push(ecritureNombreRelatif(liste_nombres[indice]))\n      }\n      liste_termes.splice(place_lettre, 0, lettre)\n      let calcul = ''\n      let signe_lettre, calcul_nombres\n      texte = `Donne le signe de $ ${lettre} $ pour que ${nom_expression} soit ${signe_expression == -1 ? 'negatif' : 'positif'}. <br>`\n      texteCorr = `${texteEnCouleurEtGras('Supposons que ' + lettre + ' soit positif : ')}`\n      switch (listeTypeDeQuestions[i]) {\n        case 1: // multiplications\n          calcul += `${liste_termes[0]} `\n          for (let k = 1; k < nb_termes; k++) {\n            calcul += `\\\\times ${liste_termes[k]}`\n          }\n          texte += ` ${nom_expression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            // texteCorr += `<br> $ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nb_termes-2 ; k++) {\n            //\ttexteCorr += `  , $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            // texteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[parseInt(nb_termes-2)])} $ est ${num.getSigneString()[parseInt(nb_termes-2)]}`;\n            liste_nombres.push(1)\n            texteCorr += `<br> ${num.setRegleSigneProduit(...liste_nombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...liste_nombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ')}`\n            // texteCorr += ` $ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nb_termes-1 ; k++) {\n            //\ttexteCorr += `  , $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]} `\n            // }\n            // texteCorr += ` et ${lettre} est négatif.`;\n            liste_nombres.push(-1)\n            texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...liste_nombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Conclusion :')} <br>` + texteEnCouleurEtGras(`Il faut donc que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'négatif' : 'positif'} pour que ${nom_expression} soit ${signe_expression == -1 ? 'négatif' : 'positif'}`, 'black')\n          } else {\n            texteCorr = `<br> Il faut que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'positif' : 'négatif'} pour que ${nom_expression} soit ${signe_expression == -1 ? 'négatif' : 'positif'}.`\n          }\n          break\n        case 2: // quotient de 2 produits\n          calcul += '\\\\dfrac {' + liste_termes[0]\n          const nb_num = randint(2, nb_termes - 2)\n          for (let k = 1; k < nb_num + 1; k++) {\n            calcul += `\\\\times ${liste_termes[k]}`\n          }\n          calcul += '}{' + liste_termes[nb_num + 1]\n          for (let denom = nb_num + 2; denom < nb_termes; denom++) {\n            calcul += `\\\\times ${liste_termes[denom]}`\n          }\n          calcul += '}'\n          texte += ` ${nom_expression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            // texteCorr += `$ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nb_termes-1 ; k++) {\n            //\ttexteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...liste_nombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est positif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...liste_nombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Supposons maintenant que ' + lettre + ' soit négatif : ')}`\n            // $ ${ecritureNombreRelatif(liste_nombres[0])} $ est ${num.getSigneString()[0]}`;\n            // for (let k=1; k<nb_termes-1 ; k++) {\n            //\ttexteCorr += `  et $ ${ecritureNombreRelatif(liste_nombres[k])} $ est ${num.getSigneString()[k]}`\n            // }\n            liste_nombres.push(-1)\n            texteCorr += `<br> ${num.setRegleSigneQuotient(...liste_nombres)}`\n            texteCorr += `<br><br> Donc si ${texteEnCouleurEtGras(lettre + ' est négatif', 'black')} $ ${calcul} $ est ${texteEnCouleurEtGras(num.getSigneProduitString(...liste_nombres), 'black')}.`\n            texteCorr += `<br><br> ${texteEnCouleurEtGras('Conclusion :')} <br>` + texteEnCouleurEtGras(`Il faut donc que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'négatif' : 'positif'} pour que ${nom_expression} soit ${signe_expression == -1 ? 'négatif' : 'positif'}`, 'black')\n          } else {\n            texteCorr = `<br> Il faut que $ ${lettre} $ soit ${signe_expression == num.getSigneProduitNumber(...liste_nombres) ? 'positif' : 'négatif'} pour que ${nom_expression} soit ${signe_expression == -1 ? 'négatif' : 'positif'}.`\n          }\n          break\n        case 3: // produit avec plusieurs fois la lettre\n          signe_lettre = randint(-1, 1, [0])\n          texte = `Donne le signe de ${nom_expression} si $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          const nb_lettres = randint(1, 3)\n          place_lettre = randint(0, nb_termes - 1)\n          for (let k = 0; k < nb_lettres; k++) {\n\t\t\t\t  liste_termes.splice(place_lettre, 0, lettre)\n          }\n          calcul += `${liste_termes[0]} `\n          for (let k = 1; k < nb_termes + nb_lettres; k++) {\n            calcul += `\\\\times ${liste_termes[k]}`\n          }\n          calcul_nombres = `${liste_nombres[0]} `\n          for (let k = 1; k < nb_termes - 1; k++) {\n            calcul_nombres += `\\\\times ${liste_nombres[k]}`\n          }\n          texte += ` ${nom_expression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (nb_lettres == 1 || nb_lettres == 3) {\n              texteCorr += `On trouve ${nb_lettres + 1} fois le facteur $ ${lettre} $.<br> Or ${nb_lettres + 1} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calcul_nombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n              texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.`, 'black')\n            } else {\n              texteCorr += `On trouve ${nb_lettres + 1} fois le facteur $ ${lettre} $. <br> Or ${nb_lettres + 1} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signe_lettre == -1 ? 'négatif' : 'positif'}.`\n              if (signe_lettre == -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n                liste_nombres.push(-1)\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}.`, 'black')\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}.`, 'black')\n              }\n            }\n          } else {\n            if (nb_lettres == 1 || nb_lettres == 3) {\n              texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.<br>`\n            } else {\n              if (signe_lettre == -1) {\n                liste_nombres.push(-1)\n                texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est négatif.<br>`\n              } else {\n                texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est positif.<br>`\n              }\n            }\n          }\n          break\n        case 4: // produit avec plusieurs fois la lettre\n          signe_lettre = randint(-1, 1, [0])\n          texte = `Donne le signe de ${nom_expression} si $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}. <br>`\n          texteCorr = ''\n          const exp_lettre = randint(2, 7)\n          if (place_lettre == 0) {\n            calcul += liste_termes[0] + '^{' + exp_lettre + '}'\n          } else {\n            calcul += liste_termes[0]\n          }\n          for (let k = 1; k < nb_termes; k++) {\n            if (k == place_lettre) {\n              calcul += '\\\\times ' + liste_termes[k] + '^{' + exp_lettre + '}'\n            } else {\n              calcul += '\\\\times ' + liste_termes[k]\n            }\n          }\n          calcul_nombres = `${liste_nombres[0]} `\n          for (let k = 1; k < nb_termes - 1; k++) {\n            calcul_nombres += `\\\\times ${liste_nombres[k]}`\n          }\n          texte += ` ${nom_expression} = $ ${calcul} $ <br>`\n          if (this.correctionDetaillee) {\n            if (exp_lettre % 2 == 0) {\n              texteCorr += `On trouve ${exp_lettre} fois le facteur $ ${lettre} $.<br> Or ${exp_lettre} est pair donc leur produit sera positif.`\n              texteCorr += `<br>Le signe de l'expression a donc le signe de : $ ${calcul_nombres} $`\n              texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n              texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.`, 'black')\n            } else {\n              texteCorr += `On trouve ${exp_lettre} fois le facteur $ ${lettre} $. <br> Or ${exp_lettre} est impair donc leur produit est du signe de $ ${lettre} $ soit ${signe_lettre == -1 ? 'négatif' : 'positif'}.`\n              if (signe_lettre == -1) {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n                liste_nombres.push(-1)\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}.`, 'black')\n              } else {\n                texteCorr += `<br>Le signe de l'expression a donc le signe opposé à : $ ${calcul_nombres} $`\n                texteCorr += `<br><br> ${num.setRegleSigneProduit(...liste_nombres)}`\n                texteCorr += '<br><br>' + texteEnCouleurEtGras(`Donc ${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quand $ ${lettre} $ est ${signe_lettre == -1 ? 'négatif' : 'positif'}.`, 'black')\n              }\n            }\n          } else {\n            if (exp_lettre % 2 == 0) {\n              texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} quelque soit le signe de $ ${lettre} $.<br>`\n            } else {\n              if (signe_lettre == -1) {\n                liste_nombres.push(-1)\n                texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est négatif.<br>`\n              } else {\n                texteCorr = `${nom_expression} est ${num.getSigneProduitString(...liste_nombres)} si $ ${lettre} $ est positif.<br>`\n              }\n            }\n          }\n          break\n      }\n      if (this.listeQuestions.indexOf(texte) == -1) {\n        // Si la question n'a jamais été posée, on en créé une autre\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n  this.besoinFormulaireNumerique = [\n    'Niveau de difficulté',\n    5,\n    '1 : Multiplications\\n2 : Quotients \\n3 : Multiplications et quotients \\n4 : Multiplications avec plusieurs fois la lettre (dont puissances) \\n5 : Mélange '\n  ]\n}\n","/**\n *\n *  Classe parente de tous les exercices\n *\n * @Auteur Rémi Angot\n */\nexport default function Exercice () {\n  // Classe parente de tous les exercices qui seront créés\n  this.titre = ''\n  this.consigne = ''\n  this.consigneCorrection = ''\n  this.listeQuestions = []\n  this.listeCorrections = []\n  this.introduction = ''\n  this.contenu = ''\n  this.contenuCorrection = ''\n  this.nbQuestions = 10\n  this.nbCols = 2\n  this.nbColsCorr = 2\n  this.spacing = 1\n  this.spacingCorr = 1\n  this.beamer = false\n\n  this.besoinFormulaireNumerique = false // Sinon this.besoinFormulaireNumerique = [texte,max,tooltip facultatif];\n  this.besoinFormulaireTexte = false // Sinon this.besoinFormulaireTexte = [texte,tooltip];\n  this.besoinFormulaireCaseACocher = false // Sinon this.besoinFormulaireCaseACocher = [texte];\n  this.consigneModifiable = true\n  this.nbQuestionsModifiable = true\n  this.nbColsModifiable = true\n  this.nbColsCorrModifiable = true\n  this.spacingModifiable = true\n  this.spacingCorrModifiable = true\n  this.correctionDetailleeDisponible = false\n  this.correctionDetaillee = true\n  this.video = ''\n  this.boutonAide = false\n  this.tailleDiaporama = 50 // Taille en pixels pour le calcul chronométré\n  // this.boutonAide = modalTexteCourt(numeroExercice,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalTexteLong(numeroExercice,titre,texte,label_bouton=\"Aide\",icone=\"info circle\")\n  // this.boutonAide = modalYoutube(numeroExercice,id_youtube,texte,label_bouton=\"Aide - Vidéo\",icone=\"youtube\")\n  // this.boutonAide = modalPdf(numeroExercice,url_pdf,texte=\"Aide\",label_bouton=\"Aide - PDF\",icone=\"file pdf\")\n  // this.vspace = -1 //Ajoute un \\vspace{-1cm} avant l'énoncé ce qui peut être pratique pour des exercices avec des figures.\n  this.pasDeVersionLatex = false\n  this.qcm = false // Pour les exercices de type QCM : contient un tableau.\n  this.qcmDisponible = false // Pour ajouter une case à cocher Mode QCM qui permet de changer le statut de this.modeQcm\n  this.modeQcm = false // Pour choisir la version QCM ou la version classique (false = version classique)\n  this.autoCorrection = [] // Liste des objets par question pour correction interactive || export AMC\n  this.tableauSolutionsDuQcm = [] // Pour sauvegarder les solutions des QCM\n  this.mg32Editable = false // pas d'interface par défaut pour les figures MG32\n  this.nouvelleVersion = function (numeroExercice) {}\n  this.listePackages = [] // string ou liste de string avec le nom des packages spécifiques à ajouter dans le préambule\n  // this.typeExercice = \"MG32\";\n  // this.dimensionsDivMg32 = [500, 450];\n  // this.typeExercice = \"Scratch\"\n  // this.qcm=[\"Quels sont les nombres pairs ?\",[7,12,34,25,18],[0,1,1,0,1]] =>[\"La question\",[les réponses],[bonne=1 et mauvaise=0]]\n}\n"],"sourceRoot":""}